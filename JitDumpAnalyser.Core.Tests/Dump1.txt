****** START compiling System.Console:WriteLine(System.String) (MethodHash=450bf92f)
Generating code for Windows x64
OPTIONS: compCodeOpt = BLENDED_CODE
OPTIONS: compDbgCode = true
OPTIONS: compDbgInfo = true
OPTIONS: compDbgEnC  = false
OPTIONS: compProcedureSplitting   = false
OPTIONS: compProcedureSplittingEH = false
OPTIONS: Jit invoked for ngen
IL to import:
IL_0000  28 50 00 00 06    call         0x6000050
IL_0005  02                ldarg.0     
IL_0006  6f 45 00 00 0a    callvirt     0xA000045
IL_000b  2a                ret         

lvaSetClass: setting class for V00 to (4000000000420148) System.String 
Arg #0    passed in register(s) rcx

lvaGrabTemp returning 1 (V01 tmp0) (a long lifetime temp) called for OutgoingArgSpace.
; Initial local variable assignments
;
;  V00 arg0              ref  class-hnd
;  V01 OutArgs        lclBlk <na>  "OutgoingArgSpace"
*************** In compInitDebuggingInfo() for System.Console:WriteLine(System.String)
getVars() returned cVars = 0, extendOthers = true
info.compVarScopesCount = 1
    	VarNum 	LVNum 	      Name 	Beg 	End
 0: 	00h 	00h 	  V00 arg0 	000h   	00Ch
New Basic Block BB01 [0000] created.
New scratch BB01
Debuggable code - Add new BB01 [0000] to perform initialization of variables
info.compStmtOffsetsCount    = 0
info.compStmtOffsetsImplicit = 0007h ( STACK_EMPTY NOP CALL_SITE )
*************** In fgFindBasicBlocks() for System.Console:WriteLine(System.String)
Jump targets:
  none
New Basic Block BB02 [0001] created.
BB02 [000..00C)
CLFLG_MINOPT set for method System.Console:WriteLine(System.String)
IL Code Size,Instr   12,   4, Basic Block count   2, Local Variable Num,Ref count   2,  1 for method System.Console:WriteLine(System.String)
OPTIONS: opts.MinOpts() == true
Basic block list for 'System.Console:WriteLine(System.String)'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal 
BB02 [0001]  1                             1       [000..00C)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Pre-import

*************** Finishing PHASE Pre-import

*************** Starting PHASE Profile incorporation
BBOPT not set

*************** Finishing PHASE Profile incorporation [no changes]

*************** Starting PHASE Importation
*************** In impImport() for System.Console:WriteLine(System.String)
Marking leading BBF_INTERNAL block BB01 as BBF_IMPORTED

impImportBlockPending for BB02

Importing BB02 (PC=000) of 'System.Console:WriteLine(System.String)'
    [ 0]   0 (0x000) call 06000050
In Compiler::impImportCall: opcode is call, kind=0, callRetType is ref, structSize is 0

lvaGrabTemp returning 2 (V02 tmp1) called for impSpillStackEnsure.


STMT00001 ( 0x000[E-] ... ??? )
               [000003] -AC-G------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V02 tmp1         
               [000001] --C-G------                         \--*  CALL      ref    System.Console.get_Out
Marked V02 as a single def temp

lvaSetClass: setting class for V02 to (4000000000421E80) System.IO.TextWriter 

    [ 1]   5 (0x005) ldarg.0
    [ 2]   6 (0x006) callvirt 0A000045
In Compiler::impImportCall: opcode is callvirt, kind=1, callRetType is void, structSize is 0

lvaGrabTemp returning 3 (V03 tmp2) called for Indirect call through function pointer.


STMT00002 ( 0x005[--] ... ??? )
               [000008] -A---------                         *  ASG       long  
               [000007] D------N---                         +--*  LCL_VAR   long   V03 tmp2         
               [000006] H----------                         \--*  CNS_INT(h) long   0x4000000000421e98 ftn


STMT00003 ( ??? ... ??? )
               [000010] --CXG------                         *  CALL ind nullcheck void  
               [000004] ----------- this                    +--*  LCL_VAR   ref    V02 tmp1         
               [000005] ----------- arg1                    +--*  LCL_VAR   ref    V00 arg0         
               [000009] ----------- calli tgt               \--*  LCL_VAR   long   V03 tmp2         

    [ 0]  11 (0x00b) ret

STMT00004 ( 0x00B[E-] ... ??? )
               [000011] -----------                         *  RETURN    void  

*************** Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal 
BB02 [0001]  1                             1       [000..00C)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
               [000000] -----------                         *  NOP       void  

------------ BB02 [000..00C) (return), preds={} succs={}

***** BB02
STMT00001 ( 0x000[E-] ... 0x00B )
               [000003] -AC-G------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V02 tmp1         
               [000001] --C-G------                         \--*  CALL      ref    System.Console.get_Out

***** BB02
STMT00002 ( 0x005[--] ... ??? )
               [000008] -A---------                         *  ASG       long  
               [000007] D------N---                         +--*  LCL_VAR   long   V03 tmp2         
               [000006] H----------                         \--*  CNS_INT(h) long   0x4000000000421e98 ftn

***** BB02
STMT00003 ( ??? ... ??? )
               [000010] --CXG------                         *  CALL ind nullcheck void  
               [000004] ----------- this                    +--*  LCL_VAR   ref    V02 tmp1         
               [000005] ----------- arg1                    +--*  LCL_VAR   ref    V00 arg0         
               [000009] ----------- calli tgt               \--*  LCL_VAR   long   V03 tmp2         

***** BB02
STMT00004 ( 0x00B[E-] ... ??? )
               [000011] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Finishing PHASE Expand patchpoints [no changes]

*************** Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Finishing PHASE Indirect call transform [no changes]

*************** Starting PHASE Post-import

*************** Finishing PHASE Post-import

*************** Starting PHASE Morph - Init

New BlockSet epoch 1, # of blocks (including unused BB00): 3, bitset array size: 1 (short)

*************** In fgPostImportationCleanup

*************** Finishing PHASE Morph - Init
*************** In fgDebugCheckBBlist

*************** Starting PHASE Morph - Inlining

*************** Finishing PHASE Morph - Inlining [no changes]

*************** Starting PHASE Allocate Objects
no newobjs in this method; punting

*************** Finishing PHASE Allocate Objects [no changes]

*************** Starting PHASE Morph - Add internal blocks

*************** After fgAddInternal()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1                             1       [000..00C)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty

*************** Finishing PHASE Morph - Add internal blocks

*************** Starting PHASE Remove empty try

*************** In fgRemoveEmptyTry()
No EH in this method, nothing to remove.

*************** Finishing PHASE Remove empty try [no changes]

*************** Starting PHASE Remove empty finally
No EH in this method, nothing to remove.

*************** Finishing PHASE Remove empty finally [no changes]

*************** Starting PHASE Merge callfinally chains
No EH in this method, nothing to merge.

*************** Finishing PHASE Merge callfinally chains [no changes]

*************** Starting PHASE Clone finally
No EH in this method, no cloning.

*************** Finishing PHASE Clone finally [no changes]

*************** Starting PHASE Compute preds

Renumbering the basic blocks for fgComputePred

*************** Before renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1                             1       [000..00C)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty

*************** After renumbering the basic blocks
=============== No blocks renumbered!

*************** In fgComputePreds()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1                             1       [000..00C)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

Setting edge weights for BB01 -> BB02 to [0 .. 3.402823e+38]

*************** After fgComputePreds()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------


*************** Finishing PHASE Compute preds

*************** Starting PHASE Morph - Promote Structs

*************** In fgResetImplicitByRefRefCount()
*************** In fgPromoteStructs()
  promotion opt flag not enabled

*************** Finishing PHASE Morph - Promote Structs

*************** Starting PHASE Morph - Structs/AddrExp

*************** In fgMarkAddressExposedLocals()
LocalAddressVisitor visiting statement:
STMT00000 ( ??? ... ??? )
               [000000] -----------                         *  NOP       void  

LocalAddressVisitor visiting statement:
STMT00001 ( 0x000[E-] ... 0x00B )
               [000003] -AC-G------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V02 tmp1         
               [000001] --C-G------                         \--*  CALL      ref    System.Console.get_Out

LocalAddressVisitor visiting statement:
STMT00002 ( 0x005[--] ... ??? )
               [000008] -A---------                         *  ASG       long  
               [000007] D------N---                         +--*  LCL_VAR   long   V03 tmp2         
               [000006] H----------                         \--*  CNS_INT(h) long   0x4000000000421e98 ftn

LocalAddressVisitor visiting statement:
STMT00003 ( ??? ... ??? )
               [000010] --CXG------                         *  CALL ind nullcheck void  
               [000004] ----------- this                    +--*  LCL_VAR   ref    V02 tmp1         
               [000005] ----------- arg1                    +--*  LCL_VAR   ref    V00 arg0         
               [000009] ----------- calli tgt               \--*  LCL_VAR   long   V03 tmp2         

LocalAddressVisitor visiting statement:
STMT00004 ( 0x00B[E-] ... ??? )
               [000011] -----------                         *  RETURN    void  


*************** Finishing PHASE Morph - Structs/AddrExp

*************** Starting PHASE Forward Substitution

*************** Finishing PHASE Forward Substitution [no changes]

*************** Starting PHASE Morph - ByRefs

*************** In fgRetypeImplicitByRefArgs()

*************** Finishing PHASE Morph - ByRefs

*************** Starting PHASE Morph - Global

*************** In fgMorphBlocks()
compEnregLocals() is false, setting doNotEnreg flag for all locals.
Local V00 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V01 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V02 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V03 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Morphing BB01 of 'System.Console:WriteLine(System.String)'

fgMorphTree BB01, STMT00000 (before)
               [000000] -----------                         *  NOP       void  

Morphing BB02 of 'System.Console:WriteLine(System.String)'

fgMorphTree BB02, STMT00001 (before)
               [000003] -AC-G------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V02 tmp1         
               [000001] --C-G------                         \--*  CALL      ref    System.Console.get_Out
Notify VM instruction set (SSE2) must be supported.
Initializing arg info for 1.CALL:
Args for call [000001] CALL after AddFinalArgsAndDetermineABIInfo:

Morphing args for 1.CALL:
Args for [000001].CALL after fgMorphArgs:
OutgoingArgsStackSize is 32


fgMorphTree BB02, STMT00002 (before)
               [000008] -A---------                         *  ASG       long  
               [000007] D------N---                         +--*  LCL_VAR   long   V03 tmp2         
               [000006] H----------                         \--*  CNS_INT(h) long   0x4000000000421e98 ftn

fgMorphTree BB02, STMT00003 (before)
               [000010] --CXG------                         *  CALL ind nullcheck void  
               [000004] ----------- this                    +--*  LCL_VAR   ref    V02 tmp1         
               [000005] ----------- arg1                    +--*  LCL_VAR   ref    V00 arg0         
               [000009] ----------- calli tgt               \--*  LCL_VAR   long   V03 tmp2         
Initializing arg info for 10.CALL:
Args for call [000010] CALL after AddFinalArgsAndDetermineABIInfo:
CallArg[[000004].LCL_VAR ref (By value), 1 reg: rcx, byteAlignment=8, wellKnown[ThisPointer]]
CallArg[[000005].LCL_VAR ref (By value), 1 reg: rdx, byteAlignment=8]

Morphing args for 10.CALL:

Sorting the arguments:
Deferred argument ('rcx'):
               [000004] -----+-----                         *  LCL_VAR   ref    V02 tmp1         
Moved to late list
Deferred argument ('rdx'):
               [000005] -----+-----                         *  LCL_VAR   ref    V00 arg0         
Moved to late list

Shuffled argument table:    rcx rdx 
Args for [000010].CALL after fgMorphArgs:
CallArg[[000004].LCL_VAR ref (By value), 1 reg: rcx, byteAlignment=8, isLate, processed, wellKnown[ThisPointer]]
CallArg[[000005].LCL_VAR ref (By value), 1 reg: rdx, byteAlignment=8, isLate, processed]
OutgoingArgsStackSize is 32


fgMorphTree BB02, STMT00004 (before)
               [000011] -----------                         *  RETURN    void  

*************** In fgMarkDemotedImplicitByRefArgs()

*************** Finishing PHASE Morph - Global
Trees after Morph - Global

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
               [000000] -----+-----                         *  NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}

***** BB02
STMT00001 ( 0x000[E-] ... 0x00B )
               [000003] -ACXG+-----                         *  ASG       ref   
               [000002] D----+-N---                         +--*  LCL_VAR   ref    V02 tmp1         
               [000001] --CXG+-----                         \--*  CALL      ref    System.Console.get_Out

***** BB02
STMT00002 ( 0x005[--] ... ??? )
               [000008] -A---+-----                         *  ASG       long  
               [000007] D----+-N---                         +--*  LCL_VAR   long   V03 tmp2         
               [000006] H----+-----                         \--*  CNS_INT(h) long   0x4000000000421e98 ftn

***** BB02
STMT00003 ( ??? ... ??? )
               [000010] --CXG+-----                         *  CALL ind nullcheck void  
               [000009] -----+----- calli tgt               \--*  LCL_VAR   long   V03 tmp2         
               [000004] -----+----- this in rcx             +--*  LCL_VAR   ref    V02 tmp1         
               [000005] -----+----- arg1 in rdx             \--*  LCL_VAR   ref    V00 arg0         

***** BB02
STMT00004 ( 0x00B[E-] ... ??? )
               [000011] -----+-----                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE GS Cookie
No GS security needed

*************** Finishing PHASE GS Cookie

*************** Starting PHASE Compute edge weights (1, false)
*************** In fgComputeBlockAndEdgeWeights()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

 -- no profile data, so using default called count
 -- not optimizing or no profile data, so not computing edge weights

*************** Finishing PHASE Compute edge weights (1, false)

*************** Starting PHASE Create EH funclets
*************** In fgCreateFunclets()

After fgCreateFunclets()
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Create EH funclets

*************** Starting PHASE Mark local vars

*************** In lvaMarkLocalVars()
*** lvaComputeRefCounts ***

*************** Finishing PHASE Mark local vars

*************** Starting PHASE Find oper order
*************** In fgFindOperOrder()

*************** Finishing PHASE Find oper order

*************** Starting PHASE Set block order
*************** In fgSetBlockOrder()
The biggest BB has    4 tree nodes

*************** Finishing PHASE Set block order

*************** Starting PHASE Insert GC Polls

*************** Finishing PHASE Insert GC Polls [no changes]

*************** Starting PHASE Determine first cold block

*************** In fgDetermineFirstColdBlock()
No procedure splitting will be done for this method

*************** Finishing PHASE Determine first cold block [no changes]
Trees before Rationalize IR

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
N001 (  0,  0) [000000] -----------                         *  NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}

***** BB02
STMT00001 ( 0x000[E-] ... 0x00B )
N003 ( 18,  8) [000003] -ACXG---R--                         *  ASG       ref   
N002 (  3,  2) [000002] D------N---                         +--*  LCL_VAR   ref    V02 tmp1         
N001 ( 14,  5) [000001] --CXG------                         \--*  CALL      ref    System.Console.get_Out

***** BB02
STMT00002 ( 0x005[--] ... ??? )
N003 (  5,  7) [000008] -A------R--                         *  ASG       long  
N002 (  3,  2) [000007] D------N---                         +--*  LCL_VAR   long   V03 tmp2         
N001 (  1,  4) [000006] H----------                         \--*  CNS_INT(h) long   0x4000000000421e98 ftn

***** BB02
STMT00003 ( ??? ... ??? )
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  
N003 (  3,  2) [000009] ----------- calli tgt               \--*  LCL_VAR   long   V03 tmp2         
N001 (  3,  2) [000004] ----------- this in rcx             +--*  LCL_VAR   ref    V02 tmp1         
N002 (  3,  2) [000005] ----------- arg1 in rdx             \--*  LCL_VAR   ref    V00 arg0         

***** BB02
STMT00004 ( 0x00B[E-] ... ??? )
N001 (  0,  0) [000011] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Rationalize IR
rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 ( 18,  8) [000003] DACXG------                         *  STORE_LCL_VAR ref    V02 tmp1         

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         


*************** Finishing PHASE Rationalize IR
Trees after Rationalize IR

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}
               [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         
               [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--]
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421e98 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t4     ref    this in rcx
                                                            +--*  t5     ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  
               [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-]
N001 (  0,  0) [000011] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE Do 'simple' lowering
Bumping outgoingArgSpaceSize from 0 to 32 for call [000001]
outgoingArgSpaceSize 32 sufficient for call [000010], which needs 32
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Do 'simple' lowering
Trees before Lowering nodeinfo

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}
               [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         
               [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--]
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421e98 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t4     ref    this in rcx
                                                            +--*  t5     ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  
               [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-]
N001 (  0,  0) [000011] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Lowering nodeinfo
compEnregLocals() is false, setting doNotEnreg flag for all locals.
Local V00 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V01 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V02 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V03 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set
lowering call (before):
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out

args:
======

late:
======
lowering call (after):
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out

lowering store lcl var/field (before):
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         

lowering store lcl var/field (after):
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         

lowering store lcl var/field (before):
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421e98 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         

lowering store lcl var/field (after):
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421e98 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         

lowering call (before):
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t4     ref    this in rcx
                                                            +--*  t5     ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  

args:
======

late:
======
lowering arg : N001 (  3,  2) [000004] -----------                         *  LCL_VAR   ref    V02 tmp1         
new node is :                [000015] -----------                         *  PUTARG_REG ref    REG rcx

lowering arg : N002 (  3,  2) [000005] -----------                         *  LCL_VAR   ref    V00 arg0         
new node is :                [000016] -----------                         *  PUTARG_REG ref    REG rdx

lowering call (after):
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
                                                            /--*  t4     ref    
               [000015] -----------                   t15 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
                                                            /--*  t5     ref    
               [000016] -----------                   t16 = *  PUTARG_REG ref    REG rdx
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t15    ref    this in rcx
                                                            +--*  t16    ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  

lowering GT_RETURN
N001 (  0,  0) [000011] -----------                         *  RETURN    void  
============Lower has completed modifying nodes.

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}
               [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         
               [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--]
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421e98 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
                                                            /--*  t4     ref    
               [000015] -----------                   t15 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
                                                            /--*  t5     ref    
               [000016] -----------                   t16 = *  PUTARG_REG ref    REG rdx
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t15    ref    this in rcx
                                                            +--*  t16    ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  
               [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-]
N001 (  0,  0) [000011] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*** lvaComputeRefCounts ***
*************** In fgLocalVarLiveness()
; Initial local variable assignments
;
;  V00 arg0              ref  do-not-enreg[] class-hnd
;  V01 OutArgs        lclBlk <32>  do-not-enreg[] "OutgoingArgSpace"
;  V02 tmp1              ref  do-not-enreg[] class-hnd "impSpillStackEnsure"
;  V03 tmp2             long  do-not-enreg[] "Indirect call through function pointer"
In fgLocalVarLivenessInit
*************** In fgPerBlockLocalVarLiveness()
*************** In fgInterBlockLocalVarLiveness()
*************** In fgExtendDbgLifetimes()

Marking vars alive over their entire scope :

Local variable scopes = 1
    	VarNum 	LVNum 	      Name 	Beg 	End
Sorted by enter scope:
 0: 	00h 	00h 	  V00 arg0 	000h   	00Ch <-- next enter scope
Sorted by exit scope:
 0: 	00h 	00h 	  V00 arg0 	000h   	00Ch <-- next exit scope
Scope info: block BB01 marking in scope: {}
Scope info: block BB02 marking in scope: {}

Debug scopes:
BB01: {}
BB02: {}
Scope info: block BB01 UNmarking in scope: {}

BB liveness after fgExtendDbgLifetimes():

BB01 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

BB02 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap



*************** In fgRemoveDeadBlocks()*************** In fgDebugCheckBBlist

*** lvaComputeRefCounts ***

*************** Finishing PHASE Lowering nodeinfo
Trees after Lowering nodeinfo

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}
               [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         
               [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--]
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421e98 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
                                                            /--*  t4     ref    
               [000015] -----------                   t15 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
                                                            /--*  t5     ref    
               [000016] -----------                   t16 = *  PUTARG_REG ref    REG rdx
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t15    ref    this in rcx
                                                            +--*  t16    ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  
               [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-]
N001 (  0,  0) [000011] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist
Trees before Calculate stack level slots

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}
               [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         
               [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--]
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421e98 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
                                                            /--*  t4     ref    
               [000015] -----------                   t15 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
                                                            /--*  t5     ref    
               [000016] -----------                   t16 = *  PUTARG_REG ref    REG rdx
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t15    ref    this in rcx
                                                            +--*  t16    ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  
               [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-]
N001 (  0,  0) [000011] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Calculate stack level slots

*************** Finishing PHASE Calculate stack level slots [no changes]

*************** Starting PHASE Linear scan register alloc
Clearing modified regs.

buildIntervals ========

-----------------
LIVENESS:
-----------------
BB01 use def in out
{}
{}
{}
{}
BB02 use def in out
{}
{}
{}
{}

FP callee save candidate vars: None

floatVarCount = 0; hasLoops = false, singleExit = true
TUPLE STYLE DUMP BEFORE LSRA
Start LSRA Block Sequence: 
Current block: BB01
	Succ block: BB02, Criteria: weight, Worklist: [BB02 ]
Current block: BB02
Final LSRA Block Sequence: 
BB01(  1   ) 
BB02(  1   ) 

BB01 [???..???), preds={} succs={BB02}
=====
  N001.                    NOP      

BB02 [000..00C) (return), preds={BB01} succs={}
=====
  N000.                    IL_OFFSET INLRT @ 0x000[E-]
  N001. t1              =  CALL     
  N003.                    V02 MEM; t1
  N000.                    IL_OFFSET INLRT @ 0x005[--]
  N001. t6              =  CNS_INT(h) 0x4000000000421e98 ftn
  N003.                    V03 MEM; t6
  N001. t4              =  V02 MEM
  N000. t15             =  PUTARG_REG; t4
  N002. t5              =  V00 MEM
  N000. t16             =  PUTARG_REG; t5
  N003. t9              =  V03 MEM
  N004.                    CALL ind nullcheck; t15,t16,t9
  N000.                    IL_OFFSET INLRT @ 0x00B[E-]
  N001.                    RETURN   




buildIntervals second part ========
Int arg V00 in reg rcx

NEW BLOCK BB01
<RefPosition #0   @0   RefTypeBB  BB01 regmask=[] minReg=1 wt=100.00>

<RefPosition #1   @3   RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #2   @3   RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #3   @3   RefTypeKill <Reg:rdi>  BB01 regmask=[rdi] minReg=1 wt=100.00>
DefList: {  }
N004 (  0,  0) [000000] -----------                         *  NOP       void   REG NA


NEW BLOCK BB02


Setting BB01 as the predecessor for determining incoming variable registers of BB02
<RefPosition #4   @6   RefTypeBB  BB02 regmask=[] minReg=1 wt=100.00>

DefList: {  }
N008 (???,???) [000012] -----------                         *  IL_OFFSET void   INLRT @ 0x000[E-] REG NA

DefList: {  }
N010 ( 14,  5) [000001] --CXG------                         *  CALL      ref    System.Console.get_Out REG NA
<RefPosition #5   @11  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #6   @11  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #7   @11  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #8   @11  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #9   @11  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 wt=100.00>
<RefPosition #10  @11  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 wt=100.00>
<RefPosition #11  @11  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 wt=100.00>
Interval  0: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #12  @11  RefTypeFixedReg <Reg:rax>  BB02 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #13  @11  RefTypeDef <Ivl:0> CALL BB02 regmask=[rax] minReg=1 fixed wt=400.00>

DefList: { N010.t1. CALL }
N012 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1          NA REG NA
<RefPosition #14  @12  RefTypeUse <Ivl:0>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>

DefList: {  }
N014 (???,???) [000013] -----------                         *  IL_OFFSET void   INLRT @ 0x005[--] REG NA

DefList: {  }
N016 (  1,  4) [000006] H----------                         *  CNS_INT(h) long   0x4000000000421e98 ftn REG NA
Interval  1: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #15  @17  RefTypeDef <Ivl:1> CNS_INT BB02 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N016.t6. CNS_INT }
N018 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2          NA REG NA
<RefPosition #16  @18  RefTypeUse <Ivl:1>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>

DefList: {  }
N020 (  3,  2) [000004] -----------                         *  LCL_VAR   ref    V02 tmp1          NA REG NA
Interval  2: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #17  @21  RefTypeDef <Ivl:2> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N020.t4. LCL_VAR }
N022 (???,???) [000015] -----------                         *  PUTARG_REG ref    REG rcx
<RefPosition #18  @22  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #19  @22  RefTypeUse <Ivl:2>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
Interval  3: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #20  @23  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #21  @23  RefTypeDef <Ivl:3> PUTARG_REG BB02 regmask=[rcx] minReg=1 fixed wt=400.00>

DefList: { N022.t15. PUTARG_REG }
N024 (  3,  2) [000005] -----------                         *  LCL_VAR   ref    V00 arg0          NA REG NA
Interval  4: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #22  @25  RefTypeDef <Ivl:4> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N022.t15. PUTARG_REG; N024.t5. LCL_VAR }
N026 (???,???) [000016] -----------                         *  PUTARG_REG ref    REG rdx
<RefPosition #23  @26  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #24  @26  RefTypeUse <Ivl:4>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
Interval  5: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #25  @27  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #26  @27  RefTypeDef <Ivl:5> PUTARG_REG BB02 regmask=[rdx] minReg=1 fixed wt=400.00>

DefList: { N022.t15. PUTARG_REG; N026.t16. PUTARG_REG }
N028 (  3,  2) [000009] -----------                         *  LCL_VAR   long   V03 tmp2          NA REG NA
Interval  6: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #27  @29  RefTypeDef <Ivl:6> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N022.t15. PUTARG_REG; N026.t16. PUTARG_REG; N028.t9. LCL_VAR }
N030 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void   REG NA
<RefPosition #28  @30  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #29  @30  RefTypeUse <Ivl:3>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #30  @30  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #31  @30  RefTypeUse <Ivl:5>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #32  @30  RefTypeUse <Ivl:6>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #33  @31  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #34  @31  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #35  @31  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #36  @31  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #37  @31  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 wt=100.00>
<RefPosition #38  @31  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 wt=100.00>
<RefPosition #39  @31  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 wt=100.00>

DefList: {  }
N032 (???,???) [000014] -----------                         *  IL_OFFSET void   INLRT @ 0x00B[E-] REG NA

DefList: {  }
N034 (  0,  0) [000011] -----------                         *  RETURN    void   REG NA


Linear scan intervals BEFORE VALIDATING INTERVALS:
Interval  0: ref RefPositions {#13@11 #14@12} physReg:NA Preferences=[rax]
Interval  1: long (constant) RefPositions {#15@17 #16@18} physReg:NA Preferences=[allIntButFP]
Interval  2: ref RefPositions {#17@21 #19@22} physReg:NA Preferences=[rcx]
Interval  3: ref RefPositions {#21@23 #29@30} physReg:NA Preferences=[rcx]
Interval  4: ref RefPositions {#22@25 #24@26} physReg:NA Preferences=[rdx]
Interval  5: ref RefPositions {#26@27 #31@30} physReg:NA Preferences=[rdx]
Interval  6: long RefPositions {#27@29 #32@30} physReg:NA Preferences=[allIntButFP]

------------
REFPOSITIONS BEFORE VALIDATING INTERVALS: 
------------
<RefPosition #0   @0   RefTypeBB  BB01 regmask=[] minReg=1 wt=100.00>
<RefPosition #1   @3   RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #2   @3   RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #3   @3   RefTypeKill <Reg:rdi>  BB01 regmask=[rdi] minReg=1 last wt=100.00>
<RefPosition #4   @6   RefTypeBB  BB02 regmask=[] minReg=1 wt=100.00>
<RefPosition #5   @11  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #6   @11  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #7   @11  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #8   @11  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #9   @11  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #10  @11  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #11  @11  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #12  @11  RefTypeFixedReg <Reg:rax>  BB02 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #13  @11  RefTypeDef <Ivl:0> CALL BB02 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #14  @12  RefTypeUse <Ivl:0>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #15  @17  RefTypeDef <Ivl:1> CNS_INT BB02 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #16  @18  RefTypeUse <Ivl:1>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #17  @21  RefTypeDef <Ivl:2> LCL_VAR BB02 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #18  @22  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #19  @22  RefTypeUse <Ivl:2>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #20  @23  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #21  @23  RefTypeDef <Ivl:3> PUTARG_REG BB02 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #22  @25  RefTypeDef <Ivl:4> LCL_VAR BB02 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #23  @26  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #24  @26  RefTypeUse <Ivl:4>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #25  @27  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #26  @27  RefTypeDef <Ivl:5> PUTARG_REG BB02 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #27  @29  RefTypeDef <Ivl:6> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #28  @30  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #29  @30  RefTypeUse <Ivl:3>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #30  @30  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #31  @30  RefTypeUse <Ivl:5>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #32  @30  RefTypeUse <Ivl:6>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #33  @31  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #34  @31  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #35  @31  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #36  @31  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #37  @31  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #38  @31  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #39  @31  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 last wt=100.00>
TUPLE STYLE DUMP WITH REF POSITIONS
Incoming Parameters: 
BB01 [???..???), preds={} succs={BB02}
=====
  N004.                    NOP      

  N008.                    IL_OFFSET INLRT @ 0x000[E-]
  N010.                    CALL     
  N012.                    V02 MEM
  N014.                    IL_OFFSET INLRT @ 0x005[--]
  N016.                    CNS_INT(h) 0x4000000000421e98 ftn
  N018.                    V03 MEM
  N020.                    V02 MEM
  N022.                    PUTARG_REG
  N024.                    V00 MEM
  N026.                    PUTARG_REG
  N028.                    V03 MEM
  N030.                    CALL ind nullcheck
  N032.                    IL_OFFSET INLRT @ 0x00B[E-]
  N034.                    RETURN   




Linear scan intervals after buildIntervals:
Interval  0: ref RefPositions {#13@11 #14@12} physReg:NA Preferences=[rax]
Interval  1: long (constant) RefPositions {#15@17 #16@18} physReg:NA Preferences=[allIntButFP]
Interval  2: ref RefPositions {#17@21 #19@22} physReg:NA Preferences=[rcx]
Interval  3: ref RefPositions {#21@23 #29@30} physReg:NA Preferences=[rcx]
Interval  4: ref RefPositions {#22@25 #24@26} physReg:NA Preferences=[rdx]
Interval  5: ref RefPositions {#26@27 #31@30} physReg:NA Preferences=[rdx]
Interval  6: long RefPositions {#27@29 #32@30} physReg:NA Preferences=[allIntButFP]

*************** In LinearScan::allocateRegisters()

Linear scan intervals before allocateRegisters:
Interval  0: ref RefPositions {#13@11 #14@12} physReg:NA Preferences=[rax]
Interval  1: long (constant) RefPositions {#15@17 #16@18} physReg:NA Preferences=[allIntButFP]
Interval  2: ref RefPositions {#17@21 #19@22} physReg:NA Preferences=[rcx]
Interval  3: ref RefPositions {#21@23 #29@30} physReg:NA Preferences=[rcx]
Interval  4: ref RefPositions {#22@25 #24@26} physReg:NA Preferences=[rdx]
Interval  5: ref RefPositions {#26@27 #31@30} physReg:NA Preferences=[rdx]
Interval  6: long RefPositions {#27@29 #32@30} physReg:NA Preferences=[allIntButFP]

------------
REFPOSITIONS BEFORE ALLOCATION: 
------------
<RefPosition #0   @0   RefTypeBB  BB01 regmask=[] minReg=1 wt=100.00>
<RefPosition #1   @3   RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #2   @3   RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #3   @3   RefTypeKill <Reg:rdi>  BB01 regmask=[rdi] minReg=1 last wt=100.00>
<RefPosition #4   @6   RefTypeBB  BB02 regmask=[] minReg=1 wt=100.00>
<RefPosition #5   @11  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #6   @11  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #7   @11  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #8   @11  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #9   @11  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #10  @11  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #11  @11  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #12  @11  RefTypeFixedReg <Reg:rax>  BB02 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #13  @11  RefTypeDef <Ivl:0> CALL BB02 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #14  @12  RefTypeUse <Ivl:0>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #15  @17  RefTypeDef <Ivl:1> CNS_INT BB02 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #16  @18  RefTypeUse <Ivl:1>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #17  @21  RefTypeDef <Ivl:2> LCL_VAR BB02 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #18  @22  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #19  @22  RefTypeUse <Ivl:2>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #20  @23  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #21  @23  RefTypeDef <Ivl:3> PUTARG_REG BB02 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #22  @25  RefTypeDef <Ivl:4> LCL_VAR BB02 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #23  @26  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #24  @26  RefTypeUse <Ivl:4>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #25  @27  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #26  @27  RefTypeDef <Ivl:5> PUTARG_REG BB02 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #27  @29  RefTypeDef <Ivl:6> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #28  @30  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #29  @30  RefTypeUse <Ivl:3>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #30  @30  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #31  @30  RefTypeUse <Ivl:5>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #32  @30  RefTypeUse <Ivl:6>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #33  @31  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #34  @31  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #35  @31  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #36  @31  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #37  @31  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #38  @31  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #39  @31  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 last wt=100.00>


Allocating Registers
--------------------
The following table has one or more rows for each RefPosition that is handled during allocation.
The first column provides the basic information about the RefPosition, with its type (e.g. Def,
Use, Fixd) followed by a '*' if it is a last use, and a 'D' if it is delayRegFree, and then the
action taken during allocation (e.g. Alloc a new register, or Keep an existing one).
The subsequent columns show the Interval occupying each register, if any, followed by 'a' if it is
active, a 'p' if it is a large vector that has been partially spilled, and 'i'if it is inactive.
Columns are only printed up to the last modifed register, which may increase during allocation,
in which case additional columns will appear.  
Registers which are not marked modified have ---- in their column.

---------------------------------+----+----+----+----+----+----+----+----+----+
LocRP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
---------------------------------+----+----+----+----+----+----+----+----+----+
                                 |    |    |    |    |    |    |    |    |    |
 0.#0  BB1 PredBB0               |    |    |    |    |    |    |    |    |    |
 3.#1  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
 3.#2  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
 3.#3  rdi  Kill   Keep     rdi  |    |    |    |    |    |    |    |    |    |
---------------------------------+----+----+----+----+----+----+----+----+----+
LocRP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
---------------------------------+----+----+----+----+----+----+----+----+----+
 6.#4  BB2 PredBB1               |    |    |    |    |    |    |    |    |    |
11.#5  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
11.#6  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
11.#7  rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
11.#8  r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
11.#9  r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
11.#10 r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
11.#11 r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
11.#12 rax  Fixd   Keep     rax  |    |    |    |    |    |    |    |    |    |
11.#13 I0   Def    Alloc    rax  |I0 a|    |    |    |    |    |    |    |    |
12.#14 I0   Use *  Keep     rax  |I0 a|    |    |    |    |    |    |    |    |
17.#15 C1   Def    BSFIT(A) rcx  |    |C1 a|    |    |    |    |    |    |    |
18.#16 C1   Use *  Keep     rcx  |    |C1 a|    |    |    |    |    |    |    |
21.#17 I2   Def    Alloc    rcx  |    |I2 a|    |    |    |    |    |    |    |
22.#18 rcx  Fixd   Keep     rcx  |    |I2 a|    |    |    |    |    |    |    |
22.#19 I2   Use *  Keep     rcx  |    |I2 a|    |    |    |    |    |    |    |
23.#20 rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |
23.#21 I3   Def    Alloc    rcx  |    |I3 a|    |    |    |    |    |    |    |
25.#22 I4   Def    Alloc    rdx  |    |I3 a|I4 a|    |    |    |    |    |    |
26.#23 rdx  Fixd   Keep     rdx  |    |I3 a|I4 a|    |    |    |    |    |    |
26.#24 I4   Use *  Keep     rdx  |    |I3 a|I4 a|    |    |    |    |    |    |
27.#25 rdx  Fixd   Keep     rdx  |    |I3 a|    |    |    |    |    |    |    |
27.#26 I5   Def    Alloc    rdx  |    |I3 a|I5 a|    |    |    |    |    |    |
29.#27 I6   Def    ORDER(A) rax  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#28 rcx  Fixd   Keep     rcx  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#29 I3   Use *  Keep     rcx  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#30 rdx  Fixd   Keep     rdx  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#31 I5   Use *  Keep     rdx  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#32 I6   Use *  Keep     rax  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
31.#33 rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
31.#34 rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
31.#35 rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
31.#36 r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
31.#37 r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
31.#38 r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
31.#39 r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |

------------
REFPOSITIONS AFTER ALLOCATION: 
------------
<RefPosition #0   @0   RefTypeBB  BB01 regmask=[] minReg=1 wt=100.00>
<RefPosition #1   @3   RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #2   @3   RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #3   @3   RefTypeKill <Reg:rdi>  BB01 regmask=[rdi] minReg=1 last wt=100.00>
<RefPosition #4   @6   RefTypeBB  BB02 regmask=[] minReg=1 wt=100.00>
<RefPosition #5   @11  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #6   @11  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #7   @11  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #8   @11  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #9   @11  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #10  @11  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #11  @11  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #12  @11  RefTypeFixedReg <Reg:rax>  BB02 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #13  @11  RefTypeDef <Ivl:0> CALL BB02 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #14  @12  RefTypeUse <Ivl:0>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #15  @17  RefTypeDef <Ivl:1> CNS_INT BB02 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #16  @18  RefTypeUse <Ivl:1>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #17  @21  RefTypeDef <Ivl:2> LCL_VAR BB02 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #18  @22  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #19  @22  RefTypeUse <Ivl:2>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #20  @23  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #21  @23  RefTypeDef <Ivl:3> PUTARG_REG BB02 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #22  @25  RefTypeDef <Ivl:4> LCL_VAR BB02 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #23  @26  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #24  @26  RefTypeUse <Ivl:4>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #25  @27  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #26  @27  RefTypeDef <Ivl:5> PUTARG_REG BB02 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #27  @29  RefTypeDef <Ivl:6> LCL_VAR BB02 regmask=[rax] minReg=1 wt=400.00>
<RefPosition #28  @30  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #29  @30  RefTypeUse <Ivl:3>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #30  @30  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #31  @30  RefTypeUse <Ivl:5>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #32  @30  RefTypeUse <Ivl:6>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #33  @31  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #34  @31  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #35  @31  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #36  @31  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #37  @31  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #38  @31  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #39  @31  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 last wt=100.00>
Active intervals at end of allocation:

Trees after linear scan register allocator (LSRA)

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N004 (  0,  0) [000000] -----------                            NOP       void   REG NA

------------ BB02 [000..00C) (return), preds={BB01} succs={}
N008 (???,???) [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-] REG NA
N010 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out REG rax
                                                            /--*  t1     ref    
N012 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1          NA REG NA
N014 (???,???) [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--] REG NA
N016 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421e98 ftn REG rcx
                                                            /--*  t6     long   
N018 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2          NA REG NA
N020 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1          rcx REG rcx
                                                            /--*  t4     ref    
N022 (???,???) [000015] -----------                   t15 = *  PUTARG_REG ref    REG rcx
N024 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0          rdx REG rdx
                                                            /--*  t5     ref    
N026 (???,???) [000016] -----------                   t16 = *  PUTARG_REG ref    REG rdx
N028 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2          rax REG rax
                                                            /--*  t15    ref    this in rcx
                                                            +--*  t16    ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N030 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void   REG NA
N032 (???,???) [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-] REG NA
N034 (  0,  0) [000011] -----------                            RETURN    void   REG NA

-------------------------------------------------------------------------------------------------------------------

Final allocation
---------------------------------+----+----+----+----+----+----+----+----+----+
LocRP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
---------------------------------+----+----+----+----+----+----+----+----+----+
 0.#0  BB1 PredBB0               |    |    |    |    |    |    |    |    |    |
 3.#1  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
 3.#2  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
 3.#3  rdi  Kill   Keep     rdi  |    |    |    |    |    |    |    |    |    |
---------------------------------+----+----+----+----+----+----+----+----+----+
LocRP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
---------------------------------+----+----+----+----+----+----+----+----+----+
 6.#4  BB2 PredBB1               |    |    |    |    |    |    |    |    |    |
11.#5  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
11.#6  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
11.#7  rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
11.#8  r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
11.#9  r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
11.#10 r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
11.#11 r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
11.#12 rax  Fixd   Keep     rax  |    |    |    |    |    |    |    |    |    |
11.#13 I0   Def    Alloc    rax  |I0 a|    |    |    |    |    |    |    |    |
12.#14 I0   Use *  Keep     rax  |I0 i|    |    |    |    |    |    |    |    |
17.#15 C1   Def    Alloc    rcx  |    |C1 a|    |    |    |    |    |    |    |
18.#16 C1   Use *  Keep     rcx  |    |C1 i|    |    |    |    |    |    |    |
21.#17 I2   Def    Alloc    rcx  |    |I2 a|    |    |    |    |    |    |    |
22.#18 rcx  Fixd   Keep     rcx  |    |I2 a|    |    |    |    |    |    |    |
22.#19 I2   Use *  Keep     rcx  |    |I2 i|    |    |    |    |    |    |    |
23.#20 rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |
23.#21 I3   Def    Alloc    rcx  |    |I3 a|    |    |    |    |    |    |    |
25.#22 I4   Def    Alloc    rdx  |    |I3 a|I4 a|    |    |    |    |    |    |
26.#23 rdx  Fixd   Keep     rdx  |    |I3 a|I4 a|    |    |    |    |    |    |
26.#24 I4   Use *  Keep     rdx  |    |I3 a|I4 i|    |    |    |    |    |    |
27.#25 rdx  Fixd   Keep     rdx  |    |I3 a|    |    |    |    |    |    |    |
27.#26 I5   Def    Alloc    rdx  |    |I3 a|I5 a|    |    |    |    |    |    |
29.#27 I6   Def    Alloc    rax  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#28 rcx  Fixd   Keep     rcx  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#29 I3   Use *  Keep     rcx  |I6 a|I3 i|I5 a|    |    |    |    |    |    |
30.#30 rdx  Fixd   Keep     rdx  |I6 a|    |I5 a|    |    |    |    |    |    |
30.#31 I5   Use *  Keep     rdx  |I6 a|    |I5 i|    |    |    |    |    |    |
30.#32 I6   Use *  Keep     rax  |I6 i|    |    |    |    |    |    |    |    |
31.#33 rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
31.#34 rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
31.#35 rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
31.#36 r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
31.#37 r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
31.#38 r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
31.#39 r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |

Recording the maximum number of concurrent spills:

----------
LSRA Stats
----------
Register selection order: ABCDEFGHIJKLMNOPQ
Total Tracked Vars:  0
Total Reg Cand Vars: 0
Total number of Intervals: 6
Total number of RefPositions: 39
Total Number of spill temps created: 0
..........
BB02 [  100.00]: BEST_FIT = 1, REG_ORDER = 1
..........
Total SpillCount : 0   Weighted: 0.000000
Total CopyReg : 0   Weighted: 0.000000
Total ResolutionMovs : 0   Weighted: 0.000000
Total SplitEdges : 0   Weighted: 0.000000
..........
Total BEST_FIT [#11] : 1   Weighted: 100.000000
Total REG_ORDER [#13] : 1   Weighted: 100.000000

TUPLE STYLE DUMP WITH REGISTER ASSIGNMENTS
Incoming Parameters: 
BB01 [???..???), preds={} succs={BB02}
=====
  N004.                    NOP      

BB02 [000..00C) (return), preds={BB01} succs={}
=====
  N008.                    IL_OFFSET INLRT @ 0x000[E-]
  N010. rax             =  CALL     
  N012.                    V02 MEM; rax
  N014.                    IL_OFFSET INLRT @ 0x005[--]
  N016. rcx             =  CNS_INT(h) 0x4000000000421e98 ftn
  N018.                    V03 MEM; rcx
  N020. rcx             =  V02 MEM
  N022. rcx             =  PUTARG_REG; rcx
  N024. rdx             =  V00 MEM
  N026. rdx             =  PUTARG_REG; rdx
  N028. rax             =  V03 MEM
  N030.                    CALL ind nullcheck; rcx,rdx,rax
  N032.                    IL_OFFSET INLRT @ 0x00B[E-]
  N034.                    RETURN   




*************** Finishing PHASE Linear scan register alloc

*************** Starting PHASE Place 'align' instructions

*************** Finishing PHASE Place 'align' instructions
*************** In genGenerateCode()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Generate code
*************** In fgDebugCheckBBlist
Finalizing stack frame
must init V02 because it has a GC ref
Modified regs: [rax rcx rdx rdi r8-r11]
Callee-saved registers pushed: 1 [rdi]
*************** In lvaAssignFrameOffsets(FINAL_FRAME_LAYOUT)
Assign V02 tmp1, size=8, stkOffs=-0x20
Assign V03 tmp2, size=8, stkOffs=-0x28
Assign V01 OutArgs, size=32, stkOffs=-0x48
--- delta bump 8 for RA
--- delta bump 8 for FP
--- delta bump 0 for FP frame
--- virtual stack offset to actual stack offset delta is 16
-- V00 was 0, now 16
-- V01 was -72, now -56
-- V02 was -32, now -16
-- V03 was -40, now -24
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  1,  1   )     ref  ->  [rbp+10H]   do-not-enreg[] class-hnd
;  V01 OutArgs      [V01    ] (  1,  1   )  lclBlk (32) [rsp+00H]   do-not-enreg[] "OutgoingArgSpace"
;  V02 tmp1         [V02    ] (  1,  1   )     ref  ->  [rbp-10H]   do-not-enreg[] must-init class-hnd "impSpillStackEnsure"
;  V03 tmp2         [V03    ] (  1,  1   )    long  ->  [rbp-18H]   do-not-enreg[] "Indirect call through function pointer"
;
; Lcl frame size = 56
Mark labels for codegen
  BB01 : first block
*************** After genMarkLabelsForCodegen()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal label LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------
Setting stack level from -572662307 to 0

=============== Generating BB01 [???..???), preds={} succs={BB02} flags=0x00000000.20010070: keep i internal label LIR 
BB01 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

Liveness not changing: 0000000000000000 {}
							Live regs: (unchanged) 00000000 {}
							GC regs: (unchanged) 00000000 {}
							Byref regs: (unchanged) 00000000 {}

      L_M1744_BB01:
Mapped BB01 to G_M1744_IG02
Label: IG02, GCvars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}

Scope info: begin block BB01, IL range [???..???)
Scope info: ignoring block beginning
Generating: N004 (  0,  0) [000000] -----------                            NOP       void   REG NA
Scope info: ignoring block end

Variable Live Range History Dump for BB01
..None..

=============== Generating BB02 [000..00C) (return), preds={BB01} succs={} flags=0x00000002.20080020: i hascall gcsafe LIR 
BB02 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

Liveness not changing: 0000000000000000 {}
							Live regs: (unchanged) 00000000 {}
							GC regs: (unchanged) 00000000 {}
							Byref regs: (unchanged) 00000000 {}

      L_M1744_BB02:

Scope info: begin block BB02, IL range [000..00C)
Scope info: opening scope, LVnum=0 [000..00C)
New debug range: first
Added IP mapping: 0x0000 STACK_EMPTY (G_M1744_IG02,ins#0,ofs#0) label
Generating: N008 (???,???) [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-] REG NA
Generating: N010 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out REG rax
							Call: GCvars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}
Added IP mapping: 0x0000 STACK_EMPTY CALL_INSTRUCTION (G_M1744_IG02,ins#0,ofs#0)
IN0001:        call     System.Console:get_Out():System.IO.TextWriter
							GC regs: 00000000 {} => 00000001 {rax}
                                                                        /--*  t1     ref    
Generating: N012 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1          NA REG NA
							GC regs: 00000001 {rax} => 00000000 {}
IN0002:        mov      gword ptr [V02 rbp-10H], rax
Added IP mapping: 0x0005 (G_M1744_IG02,ins#2,ofs#9)
Generating: N014 (???,???) [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--] REG NA
Generating: N016 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421e98 ftn REG rcx
IN0003:        lea      rcx, [(reloc 0x4000000000421e98)]
                                                                        /--*  t6     long   
Generating: N018 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2          NA REG NA
IN0004:        mov      qword ptr [V03 rbp-18H], rcx
Generating: N020 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1          rcx REG rcx
IN0005:        mov      rcx, gword ptr [V02 rbp-10H]
							GC regs: 00000000 {} => 00000002 {rcx}
                                                                        /--*  t4     ref    
Generating: N022 (???,???) [000015] -----------                   t15 = *  PUTARG_REG ref    REG rcx
							GC regs: 00000002 {rcx} => 00000000 {}
							GC regs: 00000000 {} => 00000002 {rcx}
Generating: N024 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0          rdx REG rdx
IN0006:        mov      rdx, gword ptr [V00 rbp+10H]
							GC regs: 00000002 {rcx} => 00000006 {rcx rdx}
                                                                        /--*  t5     ref    
Generating: N026 (???,???) [000016] -----------                   t16 = *  PUTARG_REG ref    REG rdx
							GC regs: 00000006 {rcx rdx} => 00000002 {rcx}
							GC regs: 00000002 {rcx} => 00000006 {rcx rdx}
Generating: N028 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2          rax REG rax
IN0007:        mov      rax, qword ptr [V03 rbp-18H]
                                                                        /--*  t15    ref    this in rcx
                                                                        +--*  t16    ref    arg1 in rdx
                                                                        +--*  t9     long   calli tgt
Generating: N030 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void   REG NA
							GC regs: 00000006 {rcx rdx} => 00000004 {rdx}
							GC regs: 00000004 {rdx} => 00000000 {}
IN0008:        cmp      dword ptr [rcx], ecx
							Call: GCvars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}
Added IP mapping: 0x0006 CALL_INSTRUCTION (G_M1744_IG02,ins#8,ofs#34)
IN0009:        call     rax
Added IP mapping: 0x000B STACK_EMPTY (G_M1744_IG02,ins#9,ofs#36)
Generating: N032 (???,???) [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-] REG NA
Generating: N034 (  0,  0) [000011] -----------                            RETURN    void   REG NA
IN000a:        nop      
Added IP mapping: EPILOG (G_M1744_IG02,ins#10,ofs#37) label
Reserving epilog IG for block BB02

      G_M1744_IG02:        ; offs=000000H, funclet=00, bbWeight=1   , byref
*************** After placeholder IG creation
G_M1744_IG01:        ; func=00, offs=000000H, size=0000H, gcrefRegs=00000000 {} <-- Prolog IG
G_M1744_IG02:        ; offs=000000H, size=0025H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB02 [0001], byref
G_M1744_IG03:        ; epilog placeholder, next placeholder=<END>, BB02 [0001], epilog, extend <-- First placeholder <-- Last placeholder
                     ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000000 {}, PrevByrefRegs=00000000 {}
                     ;   InitGCVars=0000000000000000 {}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}

Variable Live Range History Dump for BB02
V00 arg0: rbp[16] (1 slot) [(G_M1744_IG02,ins#0,ofs#0), (G_M1744_IG02,ins#10,ofs#37)]
Liveness not changing: 0000000000000000 {}

# compCycleEstimate =     49, compSizeEstimate =    25 System.Console:WriteLine(System.String)
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  1,  1   )     ref  ->  [rbp+10H]   do-not-enreg[] class-hnd
;  V01 OutArgs      [V01    ] (  1,  1   )  lclBlk (32) [rsp+00H]   do-not-enreg[] "OutgoingArgSpace"
;  V02 tmp1         [V02    ] (  1,  1   )     ref  ->  [rbp-10H]   do-not-enreg[] must-init class-hnd "impSpillStackEnsure"
;  V03 tmp2         [V03    ] (  1,  1   )    long  ->  [rbp-18H]   do-not-enreg[] "Indirect call through function pointer"
;
; Lcl frame size = 56
*************** Before prolog / epilog generation
G_M1744_IG01:        ; func=00, offs=000000H, size=0000H, gcrefRegs=00000000 {} <-- Prolog IG
G_M1744_IG02:        ; offs=000000H, size=0025H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB02 [0001], byref
G_M1744_IG03:        ; epilog placeholder, next placeholder=<END>, BB02 [0001], epilog, extend <-- First placeholder <-- Last placeholder
                     ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000000 {}, PrevByrefRegs=00000000 {}
                     ;   InitGCVars=0000000000000000 {}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}
*************** In genFnProlog()
Added IP mapping to front: PROLOG (G_M1744_IG01,ins#0,ofs#0) label

__prolog:
New debug range: first
Found 2 lvMustInit int-sized stack slots, frame offsets 16 through 8
IN000b:        push     rbp
IN000c:        push     rdi
IN000d:        sub      rsp, 56
IN000e:        lea      rbp, [rsp+40H]
IN000f:        xor      rax, rax
IN0010:        mov      qword ptr [V02 rbp-10H], rax
*************** In genFnPrologCalleeRegArgs() for int regs
IN0011:        mov      gword ptr [V00 rbp+10H], rcx
*************** In genEnregisterIncomingStackArgs()


      G_M1744_IG01:        ; offs=000000H, funclet=00, bbWeight=1   , byref, nogc
*************** In genFnEpilog()

__epilog:
gcVarPtrSetCur=0000000000000000 {}, gcRegGCrefSetCur=00000000 {}, gcRegByrefSetCur=00000000 {}
IN0012:        add      rsp, 56
IN0013:        pop      rdi
IN0014:        pop      rbp
IN0015:        ret      

      G_M1744_IG03:        ; offs=000025H, funclet=00, bbWeight=1   , epilog, nogc, extend
0 prologs, 1 epilogs, 0 funclet prologs, 0 funclet epilogs
*************** After prolog / epilog generation
G_M1744_IG01:        ; func=00, offs=000000H, size=0015H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, nogc <-- Prolog IG
G_M1744_IG02:        ; offs=000015H, size=0025H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB02 [0001], byref
G_M1744_IG03:        ; offs=00003AH, size=0007H, epilog, nogc, extend
*************** In emitJumpDistBind()

*************** Finishing PHASE Generate code

*************** Starting PHASE Emit code

Hot  code size = 0x41 bytes
Cold code size = 0x0 bytes
reserveUnwindInfo(isFunclet=false, isColdCode=false, unwindSize=0xa)
*************** In emitEndCodeGen()
Converting emitMaxStackDepth from bytes (0) to elements (0)

***************************************************************************
Instructions as they come out of the scheduler


G_M1744_IG01:        ; func=00, offs=000000H, size=0015H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, nogc <-- Prolog IG
IN000b: 000000 55                   push     rbp
IN000c: 000001 57                   push     rdi
IN000d: 000002 4883EC38             sub      rsp, 56
IN000e: 000006 488D6C2440           lea      rbp, [rsp+40H]
IN000f: 00000B 33C0                 xor      eax, eax
IN0010: 00000D 488945F0             mov      qword ptr [rbp-10H], rax
IN0011: 000011 48894D10             mov      gword ptr [rbp+10H], rcx
						;; size=21 bbWeight=1    PerfScore 5.00
G_M1744_IG02:        ; func=00, offs=000015H, size=0025H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB02 [0001], byref
recordRelocation: 000002190539902E (rw: 000002190539902E) => 4000000000421E88, type 16 (IMAGE_REL_BASED_REL32), delta 0
IN0001: 000015 E800000000           call     System.Console:get_Out():System.IO.TextWriter
                            ; gcrRegs +[rax]
                            ; gcr arg pop 0
IN0002: 00001A 488945F0             mov      gword ptr [rbp-10H], rax
recordRelocation: 0000021905399039 (rw: 0000021905399039) => 4000000000421E98, type 16 (IMAGE_REL_BASED_DISP32), delta 0
IN0003: 00001E 488D0D00000000       lea      rcx, [(reloc 0x4000000000421e98)]
IN0004: 000025 48894DE8             mov      qword ptr [rbp-18H], rcx
IN0005: 000029 488B4DF0             mov      rcx, gword ptr [rbp-10H]
                            ; gcrRegs +[rcx]
IN0006: 00002D 488B5510             mov      rdx, gword ptr [rbp+10H]
                            ; gcrRegs +[rdx]
IN0007: 000031 488B45E8             mov      rax, qword ptr [rbp-18H]
                            ; gcrRegs -[rax]
IN0008: 000035 3909                 cmp      dword ptr [rcx], ecx
IN0009: 000037 FFD0                 call     rax
                            ; gcrRegs -[rcx rdx]
                            ; gcr arg pop 0
IN000a: 000039 90                   nop      
						;; size=37 bbWeight=1    PerfScore 12.75
G_M1744_IG03:        ; func=00, offs=00003AH, size=0007H, epilog, nogc, extend
IN0012: 00003A 4883C438             add      rsp, 56
IN0013: 00003E 5F                   pop      rdi
IN0014: 00003F 5D                   pop      rbp
IN0015: 000040 C3                   ret      
						;; size=7 bbWeight=1    PerfScore 2.25Allocated method code size =   65 , actual size =   65, unused size =    0

; Total bytes of code 65, prolog size 21, PerfScore 26.50, instruction count 21, allocated bytes for code 65 (MethodHash=450bf92f) for method System.Console:WriteLine(System.String)
; ============================================================

*************** After end code gen, before unwindEmit()
G_M1744_IG01:        ; func=00, offs=000000H, size=0015H, bbWeight=1    PerfScore 5.00, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, nogc <-- Prolog IG

IN000b: 000000 push     rbp
IN000c: 000001 push     rdi
IN000d: 000002 sub      rsp, 56
IN000e: 000006 lea      rbp, [rsp+40H]
IN000f: 00000B xor      eax, eax
IN0010: 00000D mov      qword ptr [V02 rbp-10H], rax
IN0011: 000011 mov      gword ptr [V00 rbp+10H], rcx

G_M1744_IG02:        ; offs=000015H, size=0025H, bbWeight=1    PerfScore 12.75, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB02 [0001], byref

IN0001: 000015 call     System.Console:get_Out():System.IO.TextWriter
IN0002: 00001A mov      gword ptr [V02 rbp-10H], rax
IN0003: 00001E lea      rcx, [(reloc 0x4000000000421e98)]
IN0004: 000025 mov      qword ptr [V03 rbp-18H], rcx
IN0005: 000029 mov      rcx, gword ptr [V02 rbp-10H]
IN0006: 00002D mov      rdx, gword ptr [V00 rbp+10H]
IN0007: 000031 mov      rax, qword ptr [V03 rbp-18H]
IN0008: 000035 cmp      dword ptr [rcx], ecx
IN0009: 000037 call     rax
IN000a: 000039 nop      

G_M1744_IG03:        ; offs=00003AH, size=0007H, bbWeight=1    PerfScore 2.25, epilog, nogc, extend

IN0012: 00003A add      rsp, 56
IN0013: 00003E pop      rdi
IN0014: 00003F pop      rbp
IN0015: 000040 ret      


*************** Finishing PHASE Emit code

*************** Starting PHASE Emit GC+EH tables
Unwind Info:
  >> Start offset   : 0x000000 (not in unwind data)
  >>   End offset   : 0x000041 (not in unwind data)
  Version           : 1
  Flags             : 0x00
  SizeOfProlog      : 0x06
  CountOfUnwindCodes: 3
  FrameRegister     : none (0)
  FrameOffset       : N/A (no FrameRegister) (Value=0)
  UnwindCodes       :
    CodeOffset: 0x06 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 6 * 8 + 8 = 56 = 0x38
    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)
    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)
allocUnwindInfo(pHotCode=0x0000021905399018, pColdCode=0x0000000000000000, startOffset=0x0, endOffset=0x41, unwindSize=0xa, pUnwindBlock=0x00000259754A258E, funKind=0 (main function))
*************** In genIPmappingGen()
IP mapping count : 7
IL offs PROLOG : 0x00000000 ( STACK_EMPTY )
IL offs 0x0000 : 0x00000015 ( STACK_EMPTY )
IL offs 0x0000 : 0x00000015 ( STACK_EMPTY CALL_INSTRUCTION )
IL offs 0x0005 : 0x0000001E
IL offs 0x0006 : 0x00000037 ( CALL_INSTRUCTION )
IL offs 0x000B : 0x00000039 ( STACK_EMPTY )
IL offs EPILOG : 0x0000003A ( STACK_EMPTY )

*************** In genSetScopeInfo()
VarLocInfo count is 2
; Variable debug info: 2 live ranges, 1 vars for method System.Console:WriteLine(System.String)
  0(   UNKNOWN) : From 00000000h to 00000015h, in rcx
  0(   UNKNOWN) : From 00000015h to 0000003Ah, in rbp[16] (1 slot)
VARIABLE LIVE RANGES:
V00 arg0: rbp[16] (1 slot) [15, 3A)
*************** In gcInfoBlockHdrSave()
Set code length to 65.
Set ReturnKind to Scalar.
Set stack base register to rbp.
Set Outgoing stack arg area size to 32.
Stack slot id for offset 16 (0x10) (frame) (untracked) = 0.
Stack slot id for offset -16 (-0x10) (frame) (untracked) = 1.
Register slot id for reg rax = 2.
Register slot id for reg rcx = 3.
Register slot id for reg rdx = 4.
Set state of slot 2 at instr offset 0x1a to Live.
Set state of slot 3 at instr offset 0x2d to Live.
Set state of slot 4 at instr offset 0x31 to Live.
Set state of slot 2 at instr offset 0x35 to Dead.
Set state of slot 3 at instr offset 0x39 to Dead.
Set state of slot 4 at instr offset 0x39 to Dead.
Defining interruptible range: [0x15, 0x3a).

*************** Finishing PHASE Emit GC+EH tables
Method code size: 65

Allocations for System.Console:WriteLine(System.String) (MethodHash=450bf92f)
count:        326, size:      29016, max =       2960
allocateMemory:      65536, nraUsed:      31576

Alloc'd bytes by kind:
                  kind |       size |     pct
  ---------------------+------------+--------
         AssertionProp |          0 |   0.00%
               ASTNode |       2360 |   8.13%
              InstDesc |       3336 |  11.50%
              ImpStack |        384 |   1.32%
            BasicBlock |       1144 |   3.94%
              CallArgs |        160 |   0.55%
              FlowList |         40 |   0.14%
     TreeStatementList |          0 |   0.00%
               SiScope |          0 |   0.00%
       DominatorMemory |          0 |   0.00%
                  LSRA |       4504 |  15.52%
         LSRA_Interval |        560 |   1.93%
      LSRA_RefPosition |       2560 |   8.82%
          Reachability |         48 |   0.17%
                   SSA |          0 |   0.00%
           ValueNumber |          0 |   0.00%
              LvaTable |       2176 |   7.50%
            UnwindInfo |          0 |   0.00%
                hashBv |         80 |   0.28%
                bitset |         56 |   0.19%
          FixedBitVect |         16 |   0.06%
               Generic |       1532 |   5.28%
   LocalAddressVisitor |          0 |   0.00%
         FieldSeqStore |          0 |   0.00%
    ZeroOffsetFieldMap |         40 |   0.14%
          MemorySsaMap |          0 |   0.00%
          MemoryPhiArg |          0 |   0.00%
                   CSE |          0 |   0.00%
                    GC |       2684 |   9.25%
       CorTailCallInfo |          0 |   0.00%
              Inlining |        416 |   1.43%
            ArrayStack |          0 |   0.00%
             DebugInfo |        376 |   1.30%
             DebugOnly |       5295 |  18.25%
               Codegen |        848 |   2.92%
               LoopOpt |         24 |   0.08%
             LoopClone |          0 |   0.00%
             LoopHoist |          0 |   0.00%
               Unknown |         49 |   0.17%
            RangeCheck |          0 |   0.00%
              CopyProp |          0 |   0.00%
           SideEffects |          0 |   0.00%
       ObjectAllocator |          0 |   0.00%
    VariableLiveRanges |        328 |   1.13%
           ClassLayout |          0 |   0.00%
       TailMergeThrows |          0 |   0.00%
             EarlyProp |          0 |   0.00%
              ZeroInit |          0 |   0.00%
                   Pgo |          0 |   0.00%

****** DONE compiling System.Console:WriteLine(System.String)
****** START compiling System.Console:WriteLine(System.Object) (MethodHash=8fbe370f)
Generating code for Windows x64
OPTIONS: compCodeOpt = BLENDED_CODE
OPTIONS: compDbgCode = true
OPTIONS: compDbgInfo = true
OPTIONS: compDbgEnC  = false
OPTIONS: compProcedureSplitting   = false
OPTIONS: compProcedureSplittingEH = false
OPTIONS: Jit invoked for ngen
IL to import:
IL_0000  28 50 00 00 06    call         0x6000050
IL_0005  02                ldarg.0     
IL_0006  6f 44 00 00 0a    callvirt     0xA000044
IL_000b  2a                ret         

lvaSetClass: setting class for V00 to (4000000000420010) System.Object 
Arg #0    passed in register(s) rcx

lvaGrabTemp returning 1 (V01 tmp0) (a long lifetime temp) called for OutgoingArgSpace.
; Initial local variable assignments
;
;  V00 arg0              ref  class-hnd
;  V01 OutArgs        lclBlk <na>  "OutgoingArgSpace"
*************** In compInitDebuggingInfo() for System.Console:WriteLine(System.Object)
getVars() returned cVars = 0, extendOthers = true
info.compVarScopesCount = 1
    	VarNum 	LVNum 	      Name 	Beg 	End
 0: 	00h 	00h 	  V00 arg0 	000h   	00Ch
New Basic Block BB01 [0000] created.
New scratch BB01
Debuggable code - Add new BB01 [0000] to perform initialization of variables
info.compStmtOffsetsCount    = 0
info.compStmtOffsetsImplicit = 0007h ( STACK_EMPTY NOP CALL_SITE )
*************** In fgFindBasicBlocks() for System.Console:WriteLine(System.Object)
Jump targets:
  none
New Basic Block BB02 [0001] created.
BB02 [000..00C)
CLFLG_MINOPT set for method System.Console:WriteLine(System.Object)
IL Code Size,Instr   12,   4, Basic Block count   2, Local Variable Num,Ref count   2,  1 for method System.Console:WriteLine(System.Object)
OPTIONS: opts.MinOpts() == true
Basic block list for 'System.Console:WriteLine(System.Object)'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal 
BB02 [0001]  1                             1       [000..00C)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Pre-import

*************** Finishing PHASE Pre-import

*************** Starting PHASE Profile incorporation
BBOPT not set

*************** Finishing PHASE Profile incorporation [no changes]

*************** Starting PHASE Importation
*************** In impImport() for System.Console:WriteLine(System.Object)
Marking leading BBF_INTERNAL block BB01 as BBF_IMPORTED

impImportBlockPending for BB02

Importing BB02 (PC=000) of 'System.Console:WriteLine(System.Object)'
    [ 0]   0 (0x000) call 06000050
In Compiler::impImportCall: opcode is call, kind=0, callRetType is ref, structSize is 0

lvaGrabTemp returning 2 (V02 tmp1) called for impSpillStackEnsure.


STMT00001 ( 0x000[E-] ... ??? )
               [000003] -AC-G------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V02 tmp1         
               [000001] --C-G------                         \--*  CALL      ref    System.Console.get_Out
Marked V02 as a single def temp

lvaSetClass: setting class for V02 to (4000000000421778) System.IO.TextWriter 

    [ 1]   5 (0x005) ldarg.0
    [ 2]   6 (0x006) callvirt 0A000044
In Compiler::impImportCall: opcode is callvirt, kind=1, callRetType is void, structSize is 0

lvaGrabTemp returning 3 (V03 tmp2) called for Indirect call through function pointer.


STMT00002 ( 0x005[--] ... ??? )
               [000008] -A---------                         *  ASG       long  
               [000007] D------N---                         +--*  LCL_VAR   long   V03 tmp2         
               [000006] H----------                         \--*  CNS_INT(h) long   0x4000000000421790 ftn


STMT00003 ( ??? ... ??? )
               [000010] --CXG------                         *  CALL ind nullcheck void  
               [000004] ----------- this                    +--*  LCL_VAR   ref    V02 tmp1         
               [000005] ----------- arg1                    +--*  LCL_VAR   ref    V00 arg0         
               [000009] ----------- calli tgt               \--*  LCL_VAR   long   V03 tmp2         

    [ 0]  11 (0x00b) ret

STMT00004 ( 0x00B[E-] ... ??? )
               [000011] -----------                         *  RETURN    void  

*************** Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal 
BB02 [0001]  1                             1       [000..00C)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
               [000000] -----------                         *  NOP       void  

------------ BB02 [000..00C) (return), preds={} succs={}

***** BB02
STMT00001 ( 0x000[E-] ... 0x00B )
               [000003] -AC-G------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V02 tmp1         
               [000001] --C-G------                         \--*  CALL      ref    System.Console.get_Out

***** BB02
STMT00002 ( 0x005[--] ... ??? )
               [000008] -A---------                         *  ASG       long  
               [000007] D------N---                         +--*  LCL_VAR   long   V03 tmp2         
               [000006] H----------                         \--*  CNS_INT(h) long   0x4000000000421790 ftn

***** BB02
STMT00003 ( ??? ... ??? )
               [000010] --CXG------                         *  CALL ind nullcheck void  
               [000004] ----------- this                    +--*  LCL_VAR   ref    V02 tmp1         
               [000005] ----------- arg1                    +--*  LCL_VAR   ref    V00 arg0         
               [000009] ----------- calli tgt               \--*  LCL_VAR   long   V03 tmp2         

***** BB02
STMT00004 ( 0x00B[E-] ... ??? )
               [000011] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Finishing PHASE Expand patchpoints [no changes]

*************** Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Finishing PHASE Indirect call transform [no changes]

*************** Starting PHASE Post-import

*************** Finishing PHASE Post-import

*************** Starting PHASE Morph - Init

New BlockSet epoch 1, # of blocks (including unused BB00): 3, bitset array size: 1 (short)

*************** In fgPostImportationCleanup

*************** Finishing PHASE Morph - Init
*************** In fgDebugCheckBBlist

*************** Starting PHASE Morph - Inlining

*************** Finishing PHASE Morph - Inlining [no changes]

*************** Starting PHASE Allocate Objects
no newobjs in this method; punting

*************** Finishing PHASE Allocate Objects [no changes]

*************** Starting PHASE Morph - Add internal blocks

*************** After fgAddInternal()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1                             1       [000..00C)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty

*************** Finishing PHASE Morph - Add internal blocks

*************** Starting PHASE Remove empty try

*************** In fgRemoveEmptyTry()
No EH in this method, nothing to remove.

*************** Finishing PHASE Remove empty try [no changes]

*************** Starting PHASE Remove empty finally
No EH in this method, nothing to remove.

*************** Finishing PHASE Remove empty finally [no changes]

*************** Starting PHASE Merge callfinally chains
No EH in this method, nothing to merge.

*************** Finishing PHASE Merge callfinally chains [no changes]

*************** Starting PHASE Clone finally
No EH in this method, no cloning.

*************** Finishing PHASE Clone finally [no changes]

*************** Starting PHASE Compute preds

Renumbering the basic blocks for fgComputePred

*************** Before renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1                             1       [000..00C)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty

*************** After renumbering the basic blocks
=============== No blocks renumbered!

*************** In fgComputePreds()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1                             1       [000..00C)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

Setting edge weights for BB01 -> BB02 to [0 .. 3.402823e+38]

*************** After fgComputePreds()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------


*************** Finishing PHASE Compute preds

*************** Starting PHASE Morph - Promote Structs

*************** In fgResetImplicitByRefRefCount()
*************** In fgPromoteStructs()
  promotion opt flag not enabled

*************** Finishing PHASE Morph - Promote Structs

*************** Starting PHASE Morph - Structs/AddrExp

*************** In fgMarkAddressExposedLocals()
LocalAddressVisitor visiting statement:
STMT00000 ( ??? ... ??? )
               [000000] -----------                         *  NOP       void  

LocalAddressVisitor visiting statement:
STMT00001 ( 0x000[E-] ... 0x00B )
               [000003] -AC-G------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V02 tmp1         
               [000001] --C-G------                         \--*  CALL      ref    System.Console.get_Out

LocalAddressVisitor visiting statement:
STMT00002 ( 0x005[--] ... ??? )
               [000008] -A---------                         *  ASG       long  
               [000007] D------N---                         +--*  LCL_VAR   long   V03 tmp2         
               [000006] H----------                         \--*  CNS_INT(h) long   0x4000000000421790 ftn

LocalAddressVisitor visiting statement:
STMT00003 ( ??? ... ??? )
               [000010] --CXG------                         *  CALL ind nullcheck void  
               [000004] ----------- this                    +--*  LCL_VAR   ref    V02 tmp1         
               [000005] ----------- arg1                    +--*  LCL_VAR   ref    V00 arg0         
               [000009] ----------- calli tgt               \--*  LCL_VAR   long   V03 tmp2         

LocalAddressVisitor visiting statement:
STMT00004 ( 0x00B[E-] ... ??? )
               [000011] -----------                         *  RETURN    void  


*************** Finishing PHASE Morph - Structs/AddrExp

*************** Starting PHASE Forward Substitution

*************** Finishing PHASE Forward Substitution [no changes]

*************** Starting PHASE Morph - ByRefs

*************** In fgRetypeImplicitByRefArgs()

*************** Finishing PHASE Morph - ByRefs

*************** Starting PHASE Morph - Global

*************** In fgMorphBlocks()
compEnregLocals() is false, setting doNotEnreg flag for all locals.
Local V00 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V01 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V02 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V03 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Morphing BB01 of 'System.Console:WriteLine(System.Object)'

fgMorphTree BB01, STMT00000 (before)
               [000000] -----------                         *  NOP       void  

Morphing BB02 of 'System.Console:WriteLine(System.Object)'

fgMorphTree BB02, STMT00001 (before)
               [000003] -AC-G------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V02 tmp1         
               [000001] --C-G------                         \--*  CALL      ref    System.Console.get_Out
Notify VM instruction set (SSE2) must be supported.
Initializing arg info for 1.CALL:
Args for call [000001] CALL after AddFinalArgsAndDetermineABIInfo:

Morphing args for 1.CALL:
Args for [000001].CALL after fgMorphArgs:
OutgoingArgsStackSize is 32


fgMorphTree BB02, STMT00002 (before)
               [000008] -A---------                         *  ASG       long  
               [000007] D------N---                         +--*  LCL_VAR   long   V03 tmp2         
               [000006] H----------                         \--*  CNS_INT(h) long   0x4000000000421790 ftn

fgMorphTree BB02, STMT00003 (before)
               [000010] --CXG------                         *  CALL ind nullcheck void  
               [000004] ----------- this                    +--*  LCL_VAR   ref    V02 tmp1         
               [000005] ----------- arg1                    +--*  LCL_VAR   ref    V00 arg0         
               [000009] ----------- calli tgt               \--*  LCL_VAR   long   V03 tmp2         
Initializing arg info for 10.CALL:
Args for call [000010] CALL after AddFinalArgsAndDetermineABIInfo:
CallArg[[000004].LCL_VAR ref (By value), 1 reg: rcx, byteAlignment=8, wellKnown[ThisPointer]]
CallArg[[000005].LCL_VAR ref (By value), 1 reg: rdx, byteAlignment=8]

Morphing args for 10.CALL:

Sorting the arguments:
Deferred argument ('rcx'):
               [000004] -----+-----                         *  LCL_VAR   ref    V02 tmp1         
Moved to late list
Deferred argument ('rdx'):
               [000005] -----+-----                         *  LCL_VAR   ref    V00 arg0         
Moved to late list

Shuffled argument table:    rcx rdx 
Args for [000010].CALL after fgMorphArgs:
CallArg[[000004].LCL_VAR ref (By value), 1 reg: rcx, byteAlignment=8, isLate, processed, wellKnown[ThisPointer]]
CallArg[[000005].LCL_VAR ref (By value), 1 reg: rdx, byteAlignment=8, isLate, processed]
OutgoingArgsStackSize is 32


fgMorphTree BB02, STMT00004 (before)
               [000011] -----------                         *  RETURN    void  

*************** In fgMarkDemotedImplicitByRefArgs()

*************** Finishing PHASE Morph - Global
Trees after Morph - Global

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
               [000000] -----+-----                         *  NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}

***** BB02
STMT00001 ( 0x000[E-] ... 0x00B )
               [000003] -ACXG+-----                         *  ASG       ref   
               [000002] D----+-N---                         +--*  LCL_VAR   ref    V02 tmp1         
               [000001] --CXG+-----                         \--*  CALL      ref    System.Console.get_Out

***** BB02
STMT00002 ( 0x005[--] ... ??? )
               [000008] -A---+-----                         *  ASG       long  
               [000007] D----+-N---                         +--*  LCL_VAR   long   V03 tmp2         
               [000006] H----+-----                         \--*  CNS_INT(h) long   0x4000000000421790 ftn

***** BB02
STMT00003 ( ??? ... ??? )
               [000010] --CXG+-----                         *  CALL ind nullcheck void  
               [000009] -----+----- calli tgt               \--*  LCL_VAR   long   V03 tmp2         
               [000004] -----+----- this in rcx             +--*  LCL_VAR   ref    V02 tmp1         
               [000005] -----+----- arg1 in rdx             \--*  LCL_VAR   ref    V00 arg0         

***** BB02
STMT00004 ( 0x00B[E-] ... ??? )
               [000011] -----+-----                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE GS Cookie
No GS security needed

*************** Finishing PHASE GS Cookie

*************** Starting PHASE Compute edge weights (1, false)
*************** In fgComputeBlockAndEdgeWeights()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

 -- no profile data, so using default called count
 -- not optimizing or no profile data, so not computing edge weights

*************** Finishing PHASE Compute edge weights (1, false)

*************** Starting PHASE Create EH funclets
*************** In fgCreateFunclets()

After fgCreateFunclets()
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Create EH funclets

*************** Starting PHASE Mark local vars

*************** In lvaMarkLocalVars()
*** lvaComputeRefCounts ***

*************** Finishing PHASE Mark local vars

*************** Starting PHASE Find oper order
*************** In fgFindOperOrder()

*************** Finishing PHASE Find oper order

*************** Starting PHASE Set block order
*************** In fgSetBlockOrder()
The biggest BB has    4 tree nodes

*************** Finishing PHASE Set block order

*************** Starting PHASE Insert GC Polls

*************** Finishing PHASE Insert GC Polls [no changes]

*************** Starting PHASE Determine first cold block

*************** In fgDetermineFirstColdBlock()
No procedure splitting will be done for this method

*************** Finishing PHASE Determine first cold block [no changes]
Trees before Rationalize IR

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
N001 (  0,  0) [000000] -----------                         *  NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}

***** BB02
STMT00001 ( 0x000[E-] ... 0x00B )
N003 ( 18,  8) [000003] -ACXG---R--                         *  ASG       ref   
N002 (  3,  2) [000002] D------N---                         +--*  LCL_VAR   ref    V02 tmp1         
N001 ( 14,  5) [000001] --CXG------                         \--*  CALL      ref    System.Console.get_Out

***** BB02
STMT00002 ( 0x005[--] ... ??? )
N003 (  5,  7) [000008] -A------R--                         *  ASG       long  
N002 (  3,  2) [000007] D------N---                         +--*  LCL_VAR   long   V03 tmp2         
N001 (  1,  4) [000006] H----------                         \--*  CNS_INT(h) long   0x4000000000421790 ftn

***** BB02
STMT00003 ( ??? ... ??? )
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  
N003 (  3,  2) [000009] ----------- calli tgt               \--*  LCL_VAR   long   V03 tmp2         
N001 (  3,  2) [000004] ----------- this in rcx             +--*  LCL_VAR   ref    V02 tmp1         
N002 (  3,  2) [000005] ----------- arg1 in rdx             \--*  LCL_VAR   ref    V00 arg0         

***** BB02
STMT00004 ( 0x00B[E-] ... ??? )
N001 (  0,  0) [000011] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Rationalize IR
rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 ( 18,  8) [000003] DACXG------                         *  STORE_LCL_VAR ref    V02 tmp1         

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         


*************** Finishing PHASE Rationalize IR
Trees after Rationalize IR

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}
               [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         
               [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--]
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421790 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t4     ref    this in rcx
                                                            +--*  t5     ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  
               [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-]
N001 (  0,  0) [000011] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE Do 'simple' lowering
Bumping outgoingArgSpaceSize from 0 to 32 for call [000001]
outgoingArgSpaceSize 32 sufficient for call [000010], which needs 32
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Do 'simple' lowering
Trees before Lowering nodeinfo

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}
               [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         
               [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--]
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421790 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t4     ref    this in rcx
                                                            +--*  t5     ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  
               [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-]
N001 (  0,  0) [000011] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Lowering nodeinfo
compEnregLocals() is false, setting doNotEnreg flag for all locals.
Local V00 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V01 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V02 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V03 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set
lowering call (before):
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out

args:
======

late:
======
lowering call (after):
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out

lowering store lcl var/field (before):
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         

lowering store lcl var/field (after):
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         

lowering store lcl var/field (before):
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421790 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         

lowering store lcl var/field (after):
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421790 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         

lowering call (before):
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t4     ref    this in rcx
                                                            +--*  t5     ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  

args:
======

late:
======
lowering arg : N001 (  3,  2) [000004] -----------                         *  LCL_VAR   ref    V02 tmp1         
new node is :                [000015] -----------                         *  PUTARG_REG ref    REG rcx

lowering arg : N002 (  3,  2) [000005] -----------                         *  LCL_VAR   ref    V00 arg0         
new node is :                [000016] -----------                         *  PUTARG_REG ref    REG rdx

lowering call (after):
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
                                                            /--*  t4     ref    
               [000015] -----------                   t15 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
                                                            /--*  t5     ref    
               [000016] -----------                   t16 = *  PUTARG_REG ref    REG rdx
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t15    ref    this in rcx
                                                            +--*  t16    ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  

lowering GT_RETURN
N001 (  0,  0) [000011] -----------                         *  RETURN    void  
============Lower has completed modifying nodes.

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}
               [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         
               [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--]
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421790 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
                                                            /--*  t4     ref    
               [000015] -----------                   t15 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
                                                            /--*  t5     ref    
               [000016] -----------                   t16 = *  PUTARG_REG ref    REG rdx
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t15    ref    this in rcx
                                                            +--*  t16    ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  
               [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-]
N001 (  0,  0) [000011] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*** lvaComputeRefCounts ***
*************** In fgLocalVarLiveness()
; Initial local variable assignments
;
;  V00 arg0              ref  do-not-enreg[] class-hnd
;  V01 OutArgs        lclBlk <32>  do-not-enreg[] "OutgoingArgSpace"
;  V02 tmp1              ref  do-not-enreg[] class-hnd "impSpillStackEnsure"
;  V03 tmp2             long  do-not-enreg[] "Indirect call through function pointer"
In fgLocalVarLivenessInit
*************** In fgPerBlockLocalVarLiveness()
*************** In fgInterBlockLocalVarLiveness()
*************** In fgExtendDbgLifetimes()

Marking vars alive over their entire scope :

Local variable scopes = 1
    	VarNum 	LVNum 	      Name 	Beg 	End
Sorted by enter scope:
 0: 	00h 	00h 	  V00 arg0 	000h   	00Ch <-- next enter scope
Sorted by exit scope:
 0: 	00h 	00h 	  V00 arg0 	000h   	00Ch <-- next exit scope
Scope info: block BB01 marking in scope: {}
Scope info: block BB02 marking in scope: {}

Debug scopes:
BB01: {}
BB02: {}
Scope info: block BB01 UNmarking in scope: {}

BB liveness after fgExtendDbgLifetimes():

BB01 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

BB02 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap



*************** In fgRemoveDeadBlocks()*************** In fgDebugCheckBBlist

*** lvaComputeRefCounts ***

*************** Finishing PHASE Lowering nodeinfo
Trees after Lowering nodeinfo

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}
               [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         
               [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--]
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421790 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
                                                            /--*  t4     ref    
               [000015] -----------                   t15 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
                                                            /--*  t5     ref    
               [000016] -----------                   t16 = *  PUTARG_REG ref    REG rdx
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t15    ref    this in rcx
                                                            +--*  t16    ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  
               [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-]
N001 (  0,  0) [000011] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist
Trees before Calculate stack level slots

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [000..00C) (return), preds={BB01} succs={}
               [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out
                                                            /--*  t1     ref    
N003 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1         
               [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--]
N001 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421790 ftn
                                                            /--*  t6     long   
N003 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2         
N001 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1         
                                                            /--*  t4     ref    
               [000015] -----------                   t15 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0         
                                                            /--*  t5     ref    
               [000016] -----------                   t16 = *  PUTARG_REG ref    REG rdx
N003 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2         
                                                            /--*  t15    ref    this in rcx
                                                            +--*  t16    ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N004 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void  
               [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-]
N001 (  0,  0) [000011] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Calculate stack level slots

*************** Finishing PHASE Calculate stack level slots [no changes]

*************** Starting PHASE Linear scan register alloc
Clearing modified regs.

buildIntervals ========

-----------------
LIVENESS:
-----------------
BB01 use def in out
{}
{}
{}
{}
BB02 use def in out
{}
{}
{}
{}

FP callee save candidate vars: None

floatVarCount = 0; hasLoops = false, singleExit = true
TUPLE STYLE DUMP BEFORE LSRA
Start LSRA Block Sequence: 
Current block: BB01
	Succ block: BB02, Criteria: weight, Worklist: [BB02 ]
Current block: BB02
Final LSRA Block Sequence: 
BB01(  1   ) 
BB02(  1   ) 

BB01 [???..???), preds={} succs={BB02}
=====
  N001.                    NOP      

BB02 [000..00C) (return), preds={BB01} succs={}
=====
  N000.                    IL_OFFSET INLRT @ 0x000[E-]
  N001. t1              =  CALL     
  N003.                    V02 MEM; t1
  N000.                    IL_OFFSET INLRT @ 0x005[--]
  N001. t6              =  CNS_INT(h) 0x4000000000421790 ftn
  N003.                    V03 MEM; t6
  N001. t4              =  V02 MEM
  N000. t15             =  PUTARG_REG; t4
  N002. t5              =  V00 MEM
  N000. t16             =  PUTARG_REG; t5
  N003. t9              =  V03 MEM
  N004.                    CALL ind nullcheck; t15,t16,t9
  N000.                    IL_OFFSET INLRT @ 0x00B[E-]
  N001.                    RETURN   




buildIntervals second part ========
Int arg V00 in reg rcx

NEW BLOCK BB01
<RefPosition #0   @0   RefTypeBB  BB01 regmask=[] minReg=1 wt=100.00>

<RefPosition #1   @3   RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #2   @3   RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #3   @3   RefTypeKill <Reg:rdi>  BB01 regmask=[rdi] minReg=1 wt=100.00>
DefList: {  }
N004 (  0,  0) [000000] -----------                         *  NOP       void   REG NA


NEW BLOCK BB02


Setting BB01 as the predecessor for determining incoming variable registers of BB02
<RefPosition #4   @6   RefTypeBB  BB02 regmask=[] minReg=1 wt=100.00>

DefList: {  }
N008 (???,???) [000012] -----------                         *  IL_OFFSET void   INLRT @ 0x000[E-] REG NA

DefList: {  }
N010 ( 14,  5) [000001] --CXG------                         *  CALL      ref    System.Console.get_Out REG NA
<RefPosition #5   @11  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #6   @11  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #7   @11  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #8   @11  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #9   @11  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 wt=100.00>
<RefPosition #10  @11  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 wt=100.00>
<RefPosition #11  @11  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 wt=100.00>
Interval  0: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #12  @11  RefTypeFixedReg <Reg:rax>  BB02 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #13  @11  RefTypeDef <Ivl:0> CALL BB02 regmask=[rax] minReg=1 fixed wt=400.00>

DefList: { N010.t1. CALL }
N012 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1          NA REG NA
<RefPosition #14  @12  RefTypeUse <Ivl:0>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>

DefList: {  }
N014 (???,???) [000013] -----------                         *  IL_OFFSET void   INLRT @ 0x005[--] REG NA

DefList: {  }
N016 (  1,  4) [000006] H----------                         *  CNS_INT(h) long   0x4000000000421790 ftn REG NA
Interval  1: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #15  @17  RefTypeDef <Ivl:1> CNS_INT BB02 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N016.t6. CNS_INT }
N018 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2          NA REG NA
<RefPosition #16  @18  RefTypeUse <Ivl:1>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>

DefList: {  }
N020 (  3,  2) [000004] -----------                         *  LCL_VAR   ref    V02 tmp1          NA REG NA
Interval  2: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #17  @21  RefTypeDef <Ivl:2> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N020.t4. LCL_VAR }
N022 (???,???) [000015] -----------                         *  PUTARG_REG ref    REG rcx
<RefPosition #18  @22  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #19  @22  RefTypeUse <Ivl:2>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
Interval  3: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #20  @23  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #21  @23  RefTypeDef <Ivl:3> PUTARG_REG BB02 regmask=[rcx] minReg=1 fixed wt=400.00>

DefList: { N022.t15. PUTARG_REG }
N024 (  3,  2) [000005] -----------                         *  LCL_VAR   ref    V00 arg0          NA REG NA
Interval  4: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #22  @25  RefTypeDef <Ivl:4> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N022.t15. PUTARG_REG; N024.t5. LCL_VAR }
N026 (???,???) [000016] -----------                         *  PUTARG_REG ref    REG rdx
<RefPosition #23  @26  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #24  @26  RefTypeUse <Ivl:4>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
Interval  5: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #25  @27  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #26  @27  RefTypeDef <Ivl:5> PUTARG_REG BB02 regmask=[rdx] minReg=1 fixed wt=400.00>

DefList: { N022.t15. PUTARG_REG; N026.t16. PUTARG_REG }
N028 (  3,  2) [000009] -----------                         *  LCL_VAR   long   V03 tmp2          NA REG NA
Interval  6: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #27  @29  RefTypeDef <Ivl:6> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N022.t15. PUTARG_REG; N026.t16. PUTARG_REG; N028.t9. LCL_VAR }
N030 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void   REG NA
<RefPosition #28  @30  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #29  @30  RefTypeUse <Ivl:3>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #30  @30  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #31  @30  RefTypeUse <Ivl:5>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #32  @30  RefTypeUse <Ivl:6>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #33  @31  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #34  @31  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #35  @31  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #36  @31  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #37  @31  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 wt=100.00>
<RefPosition #38  @31  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 wt=100.00>
<RefPosition #39  @31  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 wt=100.00>

DefList: {  }
N032 (???,???) [000014] -----------                         *  IL_OFFSET void   INLRT @ 0x00B[E-] REG NA

DefList: {  }
N034 (  0,  0) [000011] -----------                         *  RETURN    void   REG NA


Linear scan intervals BEFORE VALIDATING INTERVALS:
Interval  0: ref RefPositions {#13@11 #14@12} physReg:NA Preferences=[rax]
Interval  1: long (constant) RefPositions {#15@17 #16@18} physReg:NA Preferences=[allIntButFP]
Interval  2: ref RefPositions {#17@21 #19@22} physReg:NA Preferences=[rcx]
Interval  3: ref RefPositions {#21@23 #29@30} physReg:NA Preferences=[rcx]
Interval  4: ref RefPositions {#22@25 #24@26} physReg:NA Preferences=[rdx]
Interval  5: ref RefPositions {#26@27 #31@30} physReg:NA Preferences=[rdx]
Interval  6: long RefPositions {#27@29 #32@30} physReg:NA Preferences=[allIntButFP]

------------
REFPOSITIONS BEFORE VALIDATING INTERVALS: 
------------
<RefPosition #0   @0   RefTypeBB  BB01 regmask=[] minReg=1 wt=100.00>
<RefPosition #1   @3   RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #2   @3   RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #3   @3   RefTypeKill <Reg:rdi>  BB01 regmask=[rdi] minReg=1 last wt=100.00>
<RefPosition #4   @6   RefTypeBB  BB02 regmask=[] minReg=1 wt=100.00>
<RefPosition #5   @11  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #6   @11  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #7   @11  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #8   @11  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #9   @11  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #10  @11  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #11  @11  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #12  @11  RefTypeFixedReg <Reg:rax>  BB02 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #13  @11  RefTypeDef <Ivl:0> CALL BB02 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #14  @12  RefTypeUse <Ivl:0>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #15  @17  RefTypeDef <Ivl:1> CNS_INT BB02 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #16  @18  RefTypeUse <Ivl:1>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #17  @21  RefTypeDef <Ivl:2> LCL_VAR BB02 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #18  @22  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #19  @22  RefTypeUse <Ivl:2>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #20  @23  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #21  @23  RefTypeDef <Ivl:3> PUTARG_REG BB02 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #22  @25  RefTypeDef <Ivl:4> LCL_VAR BB02 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #23  @26  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #24  @26  RefTypeUse <Ivl:4>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #25  @27  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #26  @27  RefTypeDef <Ivl:5> PUTARG_REG BB02 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #27  @29  RefTypeDef <Ivl:6> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #28  @30  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #29  @30  RefTypeUse <Ivl:3>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #30  @30  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #31  @30  RefTypeUse <Ivl:5>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #32  @30  RefTypeUse <Ivl:6>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #33  @31  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #34  @31  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #35  @31  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #36  @31  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #37  @31  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #38  @31  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #39  @31  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 last wt=100.00>
TUPLE STYLE DUMP WITH REF POSITIONS
Incoming Parameters: 
BB01 [???..???), preds={} succs={BB02}
=====
  N004.                    NOP      

  N008.                    IL_OFFSET INLRT @ 0x000[E-]
  N010.                    CALL     
  N012.                    V02 MEM
  N014.                    IL_OFFSET INLRT @ 0x005[--]
  N016.                    CNS_INT(h) 0x4000000000421790 ftn
  N018.                    V03 MEM
  N020.                    V02 MEM
  N022.                    PUTARG_REG
  N024.                    V00 MEM
  N026.                    PUTARG_REG
  N028.                    V03 MEM
  N030.                    CALL ind nullcheck
  N032.                    IL_OFFSET INLRT @ 0x00B[E-]
  N034.                    RETURN   




Linear scan intervals after buildIntervals:
Interval  0: ref RefPositions {#13@11 #14@12} physReg:NA Preferences=[rax]
Interval  1: long (constant) RefPositions {#15@17 #16@18} physReg:NA Preferences=[allIntButFP]
Interval  2: ref RefPositions {#17@21 #19@22} physReg:NA Preferences=[rcx]
Interval  3: ref RefPositions {#21@23 #29@30} physReg:NA Preferences=[rcx]
Interval  4: ref RefPositions {#22@25 #24@26} physReg:NA Preferences=[rdx]
Interval  5: ref RefPositions {#26@27 #31@30} physReg:NA Preferences=[rdx]
Interval  6: long RefPositions {#27@29 #32@30} physReg:NA Preferences=[allIntButFP]

*************** In LinearScan::allocateRegisters()

Linear scan intervals before allocateRegisters:
Interval  0: ref RefPositions {#13@11 #14@12} physReg:NA Preferences=[rax]
Interval  1: long (constant) RefPositions {#15@17 #16@18} physReg:NA Preferences=[allIntButFP]
Interval  2: ref RefPositions {#17@21 #19@22} physReg:NA Preferences=[rcx]
Interval  3: ref RefPositions {#21@23 #29@30} physReg:NA Preferences=[rcx]
Interval  4: ref RefPositions {#22@25 #24@26} physReg:NA Preferences=[rdx]
Interval  5: ref RefPositions {#26@27 #31@30} physReg:NA Preferences=[rdx]
Interval  6: long RefPositions {#27@29 #32@30} physReg:NA Preferences=[allIntButFP]

------------
REFPOSITIONS BEFORE ALLOCATION: 
------------
<RefPosition #0   @0   RefTypeBB  BB01 regmask=[] minReg=1 wt=100.00>
<RefPosition #1   @3   RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #2   @3   RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #3   @3   RefTypeKill <Reg:rdi>  BB01 regmask=[rdi] minReg=1 last wt=100.00>
<RefPosition #4   @6   RefTypeBB  BB02 regmask=[] minReg=1 wt=100.00>
<RefPosition #5   @11  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #6   @11  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #7   @11  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #8   @11  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #9   @11  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #10  @11  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #11  @11  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #12  @11  RefTypeFixedReg <Reg:rax>  BB02 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #13  @11  RefTypeDef <Ivl:0> CALL BB02 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #14  @12  RefTypeUse <Ivl:0>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #15  @17  RefTypeDef <Ivl:1> CNS_INT BB02 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #16  @18  RefTypeUse <Ivl:1>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #17  @21  RefTypeDef <Ivl:2> LCL_VAR BB02 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #18  @22  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #19  @22  RefTypeUse <Ivl:2>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #20  @23  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #21  @23  RefTypeDef <Ivl:3> PUTARG_REG BB02 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #22  @25  RefTypeDef <Ivl:4> LCL_VAR BB02 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #23  @26  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #24  @26  RefTypeUse <Ivl:4>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #25  @27  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #26  @27  RefTypeDef <Ivl:5> PUTARG_REG BB02 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #27  @29  RefTypeDef <Ivl:6> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #28  @30  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #29  @30  RefTypeUse <Ivl:3>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #30  @30  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #31  @30  RefTypeUse <Ivl:5>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #32  @30  RefTypeUse <Ivl:6>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #33  @31  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #34  @31  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #35  @31  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #36  @31  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #37  @31  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #38  @31  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #39  @31  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 last wt=100.00>


Allocating Registers
--------------------
The following table has one or more rows for each RefPosition that is handled during allocation.
The first column provides the basic information about the RefPosition, with its type (e.g. Def,
Use, Fixd) followed by a '*' if it is a last use, and a 'D' if it is delayRegFree, and then the
action taken during allocation (e.g. Alloc a new register, or Keep an existing one).
The subsequent columns show the Interval occupying each register, if any, followed by 'a' if it is
active, a 'p' if it is a large vector that has been partially spilled, and 'i'if it is inactive.
Columns are only printed up to the last modifed register, which may increase during allocation,
in which case additional columns will appear.  
Registers which are not marked modified have ---- in their column.

---------------------------------+----+----+----+----+----+----+----+----+----+
LocRP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
---------------------------------+----+----+----+----+----+----+----+----+----+
                                 |    |    |    |    |    |    |    |    |    |
 0.#0  BB1 PredBB0               |    |    |    |    |    |    |    |    |    |
 3.#1  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
 3.#2  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
 3.#3  rdi  Kill   Keep     rdi  |    |    |    |    |    |    |    |    |    |
---------------------------------+----+----+----+----+----+----+----+----+----+
LocRP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
---------------------------------+----+----+----+----+----+----+----+----+----+
 6.#4  BB2 PredBB1               |    |    |    |    |    |    |    |    |    |
11.#5  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
11.#6  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
11.#7  rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
11.#8  r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
11.#9  r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
11.#10 r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
11.#11 r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
11.#12 rax  Fixd   Keep     rax  |    |    |    |    |    |    |    |    |    |
11.#13 I0   Def    Alloc    rax  |I0 a|    |    |    |    |    |    |    |    |
12.#14 I0   Use *  Keep     rax  |I0 a|    |    |    |    |    |    |    |    |
17.#15 C1   Def    BSFIT(A) rcx  |    |C1 a|    |    |    |    |    |    |    |
18.#16 C1   Use *  Keep     rcx  |    |C1 a|    |    |    |    |    |    |    |
21.#17 I2   Def    Alloc    rcx  |    |I2 a|    |    |    |    |    |    |    |
22.#18 rcx  Fixd   Keep     rcx  |    |I2 a|    |    |    |    |    |    |    |
22.#19 I2   Use *  Keep     rcx  |    |I2 a|    |    |    |    |    |    |    |
23.#20 rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |
23.#21 I3   Def    Alloc    rcx  |    |I3 a|    |    |    |    |    |    |    |
25.#22 I4   Def    Alloc    rdx  |    |I3 a|I4 a|    |    |    |    |    |    |
26.#23 rdx  Fixd   Keep     rdx  |    |I3 a|I4 a|    |    |    |    |    |    |
26.#24 I4   Use *  Keep     rdx  |    |I3 a|I4 a|    |    |    |    |    |    |
27.#25 rdx  Fixd   Keep     rdx  |    |I3 a|    |    |    |    |    |    |    |
27.#26 I5   Def    Alloc    rdx  |    |I3 a|I5 a|    |    |    |    |    |    |
29.#27 I6   Def    ORDER(A) rax  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#28 rcx  Fixd   Keep     rcx  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#29 I3   Use *  Keep     rcx  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#30 rdx  Fixd   Keep     rdx  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#31 I5   Use *  Keep     rdx  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#32 I6   Use *  Keep     rax  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
31.#33 rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
31.#34 rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
31.#35 rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
31.#36 r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
31.#37 r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
31.#38 r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
31.#39 r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |

------------
REFPOSITIONS AFTER ALLOCATION: 
------------
<RefPosition #0   @0   RefTypeBB  BB01 regmask=[] minReg=1 wt=100.00>
<RefPosition #1   @3   RefTypeKill <Reg:rax>  BB01 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #2   @3   RefTypeKill <Reg:rcx>  BB01 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #3   @3   RefTypeKill <Reg:rdi>  BB01 regmask=[rdi] minReg=1 last wt=100.00>
<RefPosition #4   @6   RefTypeBB  BB02 regmask=[] minReg=1 wt=100.00>
<RefPosition #5   @11  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #6   @11  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #7   @11  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #8   @11  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #9   @11  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #10  @11  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #11  @11  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #12  @11  RefTypeFixedReg <Reg:rax>  BB02 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #13  @11  RefTypeDef <Ivl:0> CALL BB02 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #14  @12  RefTypeUse <Ivl:0>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #15  @17  RefTypeDef <Ivl:1> CNS_INT BB02 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #16  @18  RefTypeUse <Ivl:1>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #17  @21  RefTypeDef <Ivl:2> LCL_VAR BB02 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #18  @22  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #19  @22  RefTypeUse <Ivl:2>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #20  @23  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #21  @23  RefTypeDef <Ivl:3> PUTARG_REG BB02 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #22  @25  RefTypeDef <Ivl:4> LCL_VAR BB02 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #23  @26  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #24  @26  RefTypeUse <Ivl:4>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #25  @27  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #26  @27  RefTypeDef <Ivl:5> PUTARG_REG BB02 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #27  @29  RefTypeDef <Ivl:6> LCL_VAR BB02 regmask=[rax] minReg=1 wt=400.00>
<RefPosition #28  @30  RefTypeFixedReg <Reg:rcx>  BB02 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #29  @30  RefTypeUse <Ivl:3>  BB02 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #30  @30  RefTypeFixedReg <Reg:rdx>  BB02 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #31  @30  RefTypeUse <Ivl:5>  BB02 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #32  @30  RefTypeUse <Ivl:6>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #33  @31  RefTypeKill <Reg:rax>  BB02 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #34  @31  RefTypeKill <Reg:rcx>  BB02 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #35  @31  RefTypeKill <Reg:rdx>  BB02 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #36  @31  RefTypeKill <Reg:r8 >  BB02 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #37  @31  RefTypeKill <Reg:r9 >  BB02 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #38  @31  RefTypeKill <Reg:r10>  BB02 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #39  @31  RefTypeKill <Reg:r11>  BB02 regmask=[r11] minReg=1 last wt=100.00>
Active intervals at end of allocation:

Trees after linear scan register allocator (LSRA)

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N004 (  0,  0) [000000] -----------                            NOP       void   REG NA

------------ BB02 [000..00C) (return), preds={BB01} succs={}
N008 (???,???) [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-] REG NA
N010 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out REG rax
                                                            /--*  t1     ref    
N012 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1          NA REG NA
N014 (???,???) [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--] REG NA
N016 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421790 ftn REG rcx
                                                            /--*  t6     long   
N018 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2          NA REG NA
N020 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1          rcx REG rcx
                                                            /--*  t4     ref    
N022 (???,???) [000015] -----------                   t15 = *  PUTARG_REG ref    REG rcx
N024 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0          rdx REG rdx
                                                            /--*  t5     ref    
N026 (???,???) [000016] -----------                   t16 = *  PUTARG_REG ref    REG rdx
N028 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2          rax REG rax
                                                            /--*  t15    ref    this in rcx
                                                            +--*  t16    ref    arg1 in rdx
                                                            +--*  t9     long   calli tgt
N030 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void   REG NA
N032 (???,???) [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-] REG NA
N034 (  0,  0) [000011] -----------                            RETURN    void   REG NA

-------------------------------------------------------------------------------------------------------------------

Final allocation
---------------------------------+----+----+----+----+----+----+----+----+----+
LocRP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
---------------------------------+----+----+----+----+----+----+----+----+----+
 0.#0  BB1 PredBB0               |    |    |    |    |    |    |    |    |    |
 3.#1  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
 3.#2  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
 3.#3  rdi  Kill   Keep     rdi  |    |    |    |    |    |    |    |    |    |
---------------------------------+----+----+----+----+----+----+----+----+----+
LocRP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
---------------------------------+----+----+----+----+----+----+----+----+----+
 6.#4  BB2 PredBB1               |    |    |    |    |    |    |    |    |    |
11.#5  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
11.#6  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
11.#7  rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
11.#8  r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
11.#9  r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
11.#10 r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
11.#11 r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
11.#12 rax  Fixd   Keep     rax  |    |    |    |    |    |    |    |    |    |
11.#13 I0   Def    Alloc    rax  |I0 a|    |    |    |    |    |    |    |    |
12.#14 I0   Use *  Keep     rax  |I0 i|    |    |    |    |    |    |    |    |
17.#15 C1   Def    Alloc    rcx  |    |C1 a|    |    |    |    |    |    |    |
18.#16 C1   Use *  Keep     rcx  |    |C1 i|    |    |    |    |    |    |    |
21.#17 I2   Def    Alloc    rcx  |    |I2 a|    |    |    |    |    |    |    |
22.#18 rcx  Fixd   Keep     rcx  |    |I2 a|    |    |    |    |    |    |    |
22.#19 I2   Use *  Keep     rcx  |    |I2 i|    |    |    |    |    |    |    |
23.#20 rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |
23.#21 I3   Def    Alloc    rcx  |    |I3 a|    |    |    |    |    |    |    |
25.#22 I4   Def    Alloc    rdx  |    |I3 a|I4 a|    |    |    |    |    |    |
26.#23 rdx  Fixd   Keep     rdx  |    |I3 a|I4 a|    |    |    |    |    |    |
26.#24 I4   Use *  Keep     rdx  |    |I3 a|I4 i|    |    |    |    |    |    |
27.#25 rdx  Fixd   Keep     rdx  |    |I3 a|    |    |    |    |    |    |    |
27.#26 I5   Def    Alloc    rdx  |    |I3 a|I5 a|    |    |    |    |    |    |
29.#27 I6   Def    Alloc    rax  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#28 rcx  Fixd   Keep     rcx  |I6 a|I3 a|I5 a|    |    |    |    |    |    |
30.#29 I3   Use *  Keep     rcx  |I6 a|I3 i|I5 a|    |    |    |    |    |    |
30.#30 rdx  Fixd   Keep     rdx  |I6 a|    |I5 a|    |    |    |    |    |    |
30.#31 I5   Use *  Keep     rdx  |I6 a|    |I5 i|    |    |    |    |    |    |
30.#32 I6   Use *  Keep     rax  |I6 i|    |    |    |    |    |    |    |    |
31.#33 rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
31.#34 rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
31.#35 rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
31.#36 r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
31.#37 r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
31.#38 r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
31.#39 r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |

Recording the maximum number of concurrent spills:

----------
LSRA Stats
----------
Register selection order: ABCDEFGHIJKLMNOPQ
Total Tracked Vars:  0
Total Reg Cand Vars: 0
Total number of Intervals: 6
Total number of RefPositions: 39
Total Number of spill temps created: 0
..........
BB02 [  100.00]: BEST_FIT = 1, REG_ORDER = 1
..........
Total SpillCount : 0   Weighted: 0.000000
Total CopyReg : 0   Weighted: 0.000000
Total ResolutionMovs : 0   Weighted: 0.000000
Total SplitEdges : 0   Weighted: 0.000000
..........
Total BEST_FIT [#11] : 1   Weighted: 100.000000
Total REG_ORDER [#13] : 1   Weighted: 100.000000

TUPLE STYLE DUMP WITH REGISTER ASSIGNMENTS
Incoming Parameters: 
BB01 [???..???), preds={} succs={BB02}
=====
  N004.                    NOP      

BB02 [000..00C) (return), preds={BB01} succs={}
=====
  N008.                    IL_OFFSET INLRT @ 0x000[E-]
  N010. rax             =  CALL     
  N012.                    V02 MEM; rax
  N014.                    IL_OFFSET INLRT @ 0x005[--]
  N016. rcx             =  CNS_INT(h) 0x4000000000421790 ftn
  N018.                    V03 MEM; rcx
  N020. rcx             =  V02 MEM
  N022. rcx             =  PUTARG_REG; rcx
  N024. rdx             =  V00 MEM
  N026. rdx             =  PUTARG_REG; rdx
  N028. rax             =  V03 MEM
  N030.                    CALL ind nullcheck; rcx,rdx,rax
  N032.                    IL_OFFSET INLRT @ 0x00B[E-]
  N034.                    RETURN   




*************** Finishing PHASE Linear scan register alloc

*************** Starting PHASE Place 'align' instructions

*************** Finishing PHASE Place 'align' instructions
*************** In genGenerateCode()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Generate code
*************** In fgDebugCheckBBlist
Finalizing stack frame
must init V02 because it has a GC ref
Modified regs: [rax rcx rdx rdi r8-r11]
Callee-saved registers pushed: 1 [rdi]
*************** In lvaAssignFrameOffsets(FINAL_FRAME_LAYOUT)
Assign V02 tmp1, size=8, stkOffs=-0x20
Assign V03 tmp2, size=8, stkOffs=-0x28
Assign V01 OutArgs, size=32, stkOffs=-0x48
--- delta bump 8 for RA
--- delta bump 8 for FP
--- delta bump 0 for FP frame
--- virtual stack offset to actual stack offset delta is 16
-- V00 was 0, now 16
-- V01 was -72, now -56
-- V02 was -32, now -16
-- V03 was -40, now -24
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  1,  1   )     ref  ->  [rbp+10H]   do-not-enreg[] class-hnd
;  V01 OutArgs      [V01    ] (  1,  1   )  lclBlk (32) [rsp+00H]   do-not-enreg[] "OutgoingArgSpace"
;  V02 tmp1         [V02    ] (  1,  1   )     ref  ->  [rbp-10H]   do-not-enreg[] must-init class-hnd "impSpillStackEnsure"
;  V03 tmp2         [V03    ] (  1,  1   )    long  ->  [rbp-18H]   do-not-enreg[] "Indirect call through function pointer"
;
; Lcl frame size = 56
Mark labels for codegen
  BB01 : first block
*************** After genMarkLabelsForCodegen()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     keep i internal label LIR 
BB02 [0001]  1       BB01                  1       [000..00C)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------
Setting stack level from -572662307 to 0

=============== Generating BB01 [???..???), preds={} succs={BB02} flags=0x00000000.20010070: keep i internal label LIR 
BB01 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

Liveness not changing: 0000000000000000 {}
							Live regs: (unchanged) 00000000 {}
							GC regs: (unchanged) 00000000 {}
							Byref regs: (unchanged) 00000000 {}

      L_M51440_BB01:
Mapped BB01 to G_M51440_IG02
Label: IG02, GCvars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}

Scope info: begin block BB01, IL range [???..???)
Scope info: ignoring block beginning
Generating: N004 (  0,  0) [000000] -----------                            NOP       void   REG NA
Scope info: ignoring block end

Variable Live Range History Dump for BB01
..None..

=============== Generating BB02 [000..00C) (return), preds={BB01} succs={} flags=0x00000002.20080020: i hascall gcsafe LIR 
BB02 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

Liveness not changing: 0000000000000000 {}
							Live regs: (unchanged) 00000000 {}
							GC regs: (unchanged) 00000000 {}
							Byref regs: (unchanged) 00000000 {}

      L_M51440_BB02:

Scope info: begin block BB02, IL range [000..00C)
Scope info: opening scope, LVnum=0 [000..00C)
New debug range: first
Added IP mapping: 0x0000 STACK_EMPTY (G_M51440_IG02,ins#0,ofs#0) label
Generating: N008 (???,???) [000012] -----------                            IL_OFFSET void   INLRT @ 0x000[E-] REG NA
Generating: N010 ( 14,  5) [000001] --CXG------                    t1 =    CALL      ref    System.Console.get_Out REG rax
							Call: GCvars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}
Added IP mapping: 0x0000 STACK_EMPTY CALL_INSTRUCTION (G_M51440_IG02,ins#0,ofs#0)
IN0001:        call     System.Console:get_Out():System.IO.TextWriter
							GC regs: 00000000 {} => 00000001 {rax}
                                                                        /--*  t1     ref    
Generating: N012 ( 18,  8) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V02 tmp1          NA REG NA
							GC regs: 00000001 {rax} => 00000000 {}
IN0002:        mov      gword ptr [V02 rbp-10H], rax
Added IP mapping: 0x0005 (G_M51440_IG02,ins#2,ofs#9)
Generating: N014 (???,???) [000013] -----------                            IL_OFFSET void   INLRT @ 0x005[--] REG NA
Generating: N016 (  1,  4) [000006] H----------                    t6 =    CNS_INT(h) long   0x4000000000421790 ftn REG rcx
IN0003:        lea      rcx, [(reloc 0x4000000000421790)]
                                                                        /--*  t6     long   
Generating: N018 (  5,  7) [000008] DA---------                         *  STORE_LCL_VAR long   V03 tmp2          NA REG NA
IN0004:        mov      qword ptr [V03 rbp-18H], rcx
Generating: N020 (  3,  2) [000004] -----------                    t4 =    LCL_VAR   ref    V02 tmp1          rcx REG rcx
IN0005:        mov      rcx, gword ptr [V02 rbp-10H]
							GC regs: 00000000 {} => 00000002 {rcx}
                                                                        /--*  t4     ref    
Generating: N022 (???,???) [000015] -----------                   t15 = *  PUTARG_REG ref    REG rcx
							GC regs: 00000002 {rcx} => 00000000 {}
							GC regs: 00000000 {} => 00000002 {rcx}
Generating: N024 (  3,  2) [000005] -----------                    t5 =    LCL_VAR   ref    V00 arg0          rdx REG rdx
IN0006:        mov      rdx, gword ptr [V00 rbp+10H]
							GC regs: 00000002 {rcx} => 00000006 {rcx rdx}
                                                                        /--*  t5     ref    
Generating: N026 (???,???) [000016] -----------                   t16 = *  PUTARG_REG ref    REG rdx
							GC regs: 00000006 {rcx rdx} => 00000002 {rcx}
							GC regs: 00000002 {rcx} => 00000006 {rcx rdx}
Generating: N028 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   long   V03 tmp2          rax REG rax
IN0007:        mov      rax, qword ptr [V03 rbp-18H]
                                                                        /--*  t15    ref    this in rcx
                                                                        +--*  t16    ref    arg1 in rdx
                                                                        +--*  t9     long   calli tgt
Generating: N030 ( 26, 10) [000010] --CXG------                         *  CALL ind nullcheck void   REG NA
							GC regs: 00000006 {rcx rdx} => 00000004 {rdx}
							GC regs: 00000004 {rdx} => 00000000 {}
IN0008:        cmp      dword ptr [rcx], ecx
							Call: GCvars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}
Added IP mapping: 0x0006 CALL_INSTRUCTION (G_M51440_IG02,ins#8,ofs#34)
IN0009:        call     rax
Added IP mapping: 0x000B STACK_EMPTY (G_M51440_IG02,ins#9,ofs#36)
Generating: N032 (???,???) [000014] -----------                            IL_OFFSET void   INLRT @ 0x00B[E-] REG NA
Generating: N034 (  0,  0) [000011] -----------                            RETURN    void   REG NA
IN000a:        nop      
Added IP mapping: EPILOG (G_M51440_IG02,ins#10,ofs#37) label
Reserving epilog IG for block BB02

      G_M51440_IG02:        ; offs=000000H, funclet=00, bbWeight=1   , byref
*************** After placeholder IG creation
G_M51440_IG01:        ; func=00, offs=000000H, size=0000H, gcrefRegs=00000000 {} <-- Prolog IG
G_M51440_IG02:        ; offs=000000H, size=0025H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB02 [0001], byref
G_M51440_IG03:        ; epilog placeholder, next placeholder=<END>, BB02 [0001], epilog, extend <-- First placeholder <-- Last placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000000 {}, PrevByrefRegs=00000000 {}
                      ;   InitGCVars=0000000000000000 {}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}

Variable Live Range History Dump for BB02
V00 arg0: rbp[16] (1 slot) [(G_M51440_IG02,ins#0,ofs#0), (G_M51440_IG02,ins#10,ofs#37)]
Liveness not changing: 0000000000000000 {}

# compCycleEstimate =     49, compSizeEstimate =    25 System.Console:WriteLine(System.Object)
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  1,  1   )     ref  ->  [rbp+10H]   do-not-enreg[] class-hnd
;  V01 OutArgs      [V01    ] (  1,  1   )  lclBlk (32) [rsp+00H]   do-not-enreg[] "OutgoingArgSpace"
;  V02 tmp1         [V02    ] (  1,  1   )     ref  ->  [rbp-10H]   do-not-enreg[] must-init class-hnd "impSpillStackEnsure"
;  V03 tmp2         [V03    ] (  1,  1   )    long  ->  [rbp-18H]   do-not-enreg[] "Indirect call through function pointer"
;
; Lcl frame size = 56
*************** Before prolog / epilog generation
G_M51440_IG01:        ; func=00, offs=000000H, size=0000H, gcrefRegs=00000000 {} <-- Prolog IG
G_M51440_IG02:        ; offs=000000H, size=0025H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB02 [0001], byref
G_M51440_IG03:        ; epilog placeholder, next placeholder=<END>, BB02 [0001], epilog, extend <-- First placeholder <-- Last placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000000 {}, PrevByrefRegs=00000000 {}
                      ;   InitGCVars=0000000000000000 {}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}
*************** In genFnProlog()
Added IP mapping to front: PROLOG (G_M51440_IG01,ins#0,ofs#0) label

__prolog:
New debug range: first
Found 2 lvMustInit int-sized stack slots, frame offsets 16 through 8
IN000b:        push     rbp
IN000c:        push     rdi
IN000d:        sub      rsp, 56
IN000e:        lea      rbp, [rsp+40H]
IN000f:        xor      rax, rax
IN0010:        mov      qword ptr [V02 rbp-10H], rax
*************** In genFnPrologCalleeRegArgs() for int regs
IN0011:        mov      gword ptr [V00 rbp+10H], rcx
*************** In genEnregisterIncomingStackArgs()


      G_M51440_IG01:        ; offs=000000H, funclet=00, bbWeight=1   , byref, nogc
*************** In genFnEpilog()

__epilog:
gcVarPtrSetCur=0000000000000000 {}, gcRegGCrefSetCur=00000000 {}, gcRegByrefSetCur=00000000 {}
IN0012:        add      rsp, 56
IN0013:        pop      rdi
IN0014:        pop      rbp
IN0015:        ret      

      G_M51440_IG03:        ; offs=000025H, funclet=00, bbWeight=1   , epilog, nogc, extend
0 prologs, 1 epilogs, 0 funclet prologs, 0 funclet epilogs
*************** After prolog / epilog generation
G_M51440_IG01:        ; func=00, offs=000000H, size=0015H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, nogc <-- Prolog IG
G_M51440_IG02:        ; offs=000015H, size=0025H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB02 [0001], byref
G_M51440_IG03:        ; offs=00003AH, size=0007H, epilog, nogc, extend
*************** In emitJumpDistBind()

*************** Finishing PHASE Generate code

*************** Starting PHASE Emit code

Hot  code size = 0x41 bytes
Cold code size = 0x0 bytes
reserveUnwindInfo(isFunclet=false, isColdCode=false, unwindSize=0xa)
*************** In emitEndCodeGen()
Converting emitMaxStackDepth from bytes (0) to elements (0)

***************************************************************************
Instructions as they come out of the scheduler


G_M51440_IG01:        ; func=00, offs=000000H, size=0015H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, nogc <-- Prolog IG
IN000b: 000000 55                   push     rbp
IN000c: 000001 57                   push     rdi
IN000d: 000002 4883EC38             sub      rsp, 56
IN000e: 000006 488D6C2440           lea      rbp, [rsp+40H]
IN000f: 00000B 33C0                 xor      eax, eax
IN0010: 00000D 488945F0             mov      qword ptr [rbp-10H], rax
IN0011: 000011 48894D10             mov      gword ptr [rbp+10H], rcx
						;; size=21 bbWeight=1    PerfScore 5.00
G_M51440_IG02:        ; func=00, offs=000015H, size=0025H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB02 [0001], byref
recordRelocation: 0000021903A63E9E (rw: 0000021903A63E9E) => 4000000000421780, type 16 (IMAGE_REL_BASED_REL32), delta 0
IN0001: 000015 E800000000           call     System.Console:get_Out():System.IO.TextWriter
                            ; gcrRegs +[rax]
                            ; gcr arg pop 0
IN0002: 00001A 488945F0             mov      gword ptr [rbp-10H], rax
recordRelocation: 0000021903A63EA9 (rw: 0000021903A63EA9) => 4000000000421790, type 16 (IMAGE_REL_BASED_DISP32), delta 0
IN0003: 00001E 488D0D00000000       lea      rcx, [(reloc 0x4000000000421790)]
IN0004: 000025 48894DE8             mov      qword ptr [rbp-18H], rcx
IN0005: 000029 488B4DF0             mov      rcx, gword ptr [rbp-10H]
                            ; gcrRegs +[rcx]
IN0006: 00002D 488B5510             mov      rdx, gword ptr [rbp+10H]
                            ; gcrRegs +[rdx]
IN0007: 000031 488B45E8             mov      rax, qword ptr [rbp-18H]
                            ; gcrRegs -[rax]
IN0008: 000035 3909                 cmp      dword ptr [rcx], ecx
IN0009: 000037 FFD0                 call     rax
                            ; gcrRegs -[rcx rdx]
                            ; gcr arg pop 0
IN000a: 000039 90                   nop      
						;; size=37 bbWeight=1    PerfScore 12.75
G_M51440_IG03:        ; func=00, offs=00003AH, size=0007H, epilog, nogc, extend
IN0012: 00003A 4883C438             add      rsp, 56
IN0013: 00003E 5F                   pop      rdi
IN0014: 00003F 5D                   pop      rbp
IN0015: 000040 C3                   ret      
						;; size=7 bbWeight=1    PerfScore 2.25Allocated method code size =   65 , actual size =   65, unused size =    0

; Total bytes of code 65, prolog size 21, PerfScore 26.50, instruction count 21, allocated bytes for code 65 (MethodHash=8fbe370f) for method System.Console:WriteLine(System.Object)
; ============================================================

*************** After end code gen, before unwindEmit()
G_M51440_IG01:        ; func=00, offs=000000H, size=0015H, bbWeight=1    PerfScore 5.00, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, nogc <-- Prolog IG

IN000b: 000000 push     rbp
IN000c: 000001 push     rdi
IN000d: 000002 sub      rsp, 56
IN000e: 000006 lea      rbp, [rsp+40H]
IN000f: 00000B xor      eax, eax
IN0010: 00000D mov      qword ptr [V02 rbp-10H], rax
IN0011: 000011 mov      gword ptr [V00 rbp+10H], rcx

G_M51440_IG02:        ; offs=000015H, size=0025H, bbWeight=1    PerfScore 12.75, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB02 [0001], byref

IN0001: 000015 call     System.Console:get_Out():System.IO.TextWriter
IN0002: 00001A mov      gword ptr [V02 rbp-10H], rax
IN0003: 00001E lea      rcx, [(reloc 0x4000000000421790)]
IN0004: 000025 mov      qword ptr [V03 rbp-18H], rcx
IN0005: 000029 mov      rcx, gword ptr [V02 rbp-10H]
IN0006: 00002D mov      rdx, gword ptr [V00 rbp+10H]
IN0007: 000031 mov      rax, qword ptr [V03 rbp-18H]
IN0008: 000035 cmp      dword ptr [rcx], ecx
IN0009: 000037 call     rax
IN000a: 000039 nop      

G_M51440_IG03:        ; offs=00003AH, size=0007H, bbWeight=1    PerfScore 2.25, epilog, nogc, extend

IN0012: 00003A add      rsp, 56
IN0013: 00003E pop      rdi
IN0014: 00003F pop      rbp
IN0015: 000040 ret      


*************** Finishing PHASE Emit code

*************** Starting PHASE Emit GC+EH tables
Unwind Info:
  >> Start offset   : 0x000000 (not in unwind data)
  >>   End offset   : 0x000041 (not in unwind data)
  Version           : 1
  Flags             : 0x00
  SizeOfProlog      : 0x06
  CountOfUnwindCodes: 3
  FrameRegister     : none (0)
  FrameOffset       : N/A (no FrameRegister) (Value=0)
  UnwindCodes       :
    CodeOffset: 0x06 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 6 * 8 + 8 = 56 = 0x38
    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)
    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)
allocUnwindInfo(pHotCode=0x0000021903A63E88, pColdCode=0x0000000000000000, startOffset=0x0, endOffset=0x41, unwindSize=0xa, pUnwindBlock=0x00000259753700CE, funKind=0 (main function))
*************** In genIPmappingGen()
IP mapping count : 7
IL offs PROLOG : 0x00000000 ( STACK_EMPTY )
IL offs 0x0000 : 0x00000015 ( STACK_EMPTY )
IL offs 0x0000 : 0x00000015 ( STACK_EMPTY CALL_INSTRUCTION )
IL offs 0x0005 : 0x0000001E
IL offs 0x0006 : 0x00000037 ( CALL_INSTRUCTION )
IL offs 0x000B : 0x00000039 ( STACK_EMPTY )
IL offs EPILOG : 0x0000003A ( STACK_EMPTY )

*************** In genSetScopeInfo()
VarLocInfo count is 2
; Variable debug info: 2 live ranges, 1 vars for method System.Console:WriteLine(System.Object)
  0(   UNKNOWN) : From 00000000h to 00000015h, in rcx
  0(   UNKNOWN) : From 00000015h to 0000003Ah, in rbp[16] (1 slot)
VARIABLE LIVE RANGES:
V00 arg0: rbp[16] (1 slot) [15, 3A)
*************** In gcInfoBlockHdrSave()
Set code length to 65.
Set ReturnKind to Scalar.
Set stack base register to rbp.
Set Outgoing stack arg area size to 32.
Stack slot id for offset 16 (0x10) (frame) (untracked) = 0.
Stack slot id for offset -16 (-0x10) (frame) (untracked) = 1.
Register slot id for reg rax = 2.
Register slot id for reg rcx = 3.
Register slot id for reg rdx = 4.
Set state of slot 2 at instr offset 0x1a to Live.
Set state of slot 3 at instr offset 0x2d to Live.
Set state of slot 4 at instr offset 0x31 to Live.
Set state of slot 2 at instr offset 0x35 to Dead.
Set state of slot 3 at instr offset 0x39 to Dead.
Set state of slot 4 at instr offset 0x39 to Dead.
Defining interruptible range: [0x15, 0x3a).

*************** Finishing PHASE Emit GC+EH tables
Method code size: 65

Allocations for System.Console:WriteLine(System.Object) (MethodHash=8fbe370f)
count:        326, size:      29016, max =       2960
allocateMemory:      65536, nraUsed:      31576

Alloc'd bytes by kind:
                  kind |       size |     pct
  ---------------------+------------+--------
         AssertionProp |          0 |   0.00%
               ASTNode |       2360 |   8.13%
              InstDesc |       3336 |  11.50%
              ImpStack |        384 |   1.32%
            BasicBlock |       1144 |   3.94%
              CallArgs |        160 |   0.55%
              FlowList |         40 |   0.14%
     TreeStatementList |          0 |   0.00%
               SiScope |          0 |   0.00%
       DominatorMemory |          0 |   0.00%
                  LSRA |       4504 |  15.52%
         LSRA_Interval |        560 |   1.93%
      LSRA_RefPosition |       2560 |   8.82%
          Reachability |         48 |   0.17%
                   SSA |          0 |   0.00%
           ValueNumber |          0 |   0.00%
              LvaTable |       2176 |   7.50%
            UnwindInfo |          0 |   0.00%
                hashBv |         80 |   0.28%
                bitset |         56 |   0.19%
          FixedBitVect |         16 |   0.06%
               Generic |       1532 |   5.28%
   LocalAddressVisitor |          0 |   0.00%
         FieldSeqStore |          0 |   0.00%
    ZeroOffsetFieldMap |         40 |   0.14%
          MemorySsaMap |          0 |   0.00%
          MemoryPhiArg |          0 |   0.00%
                   CSE |          0 |   0.00%
                    GC |       2684 |   9.25%
       CorTailCallInfo |          0 |   0.00%
              Inlining |        416 |   1.43%
            ArrayStack |          0 |   0.00%
             DebugInfo |        376 |   1.30%
             DebugOnly |       5295 |  18.25%
               Codegen |        848 |   2.92%
               LoopOpt |         24 |   0.08%
             LoopClone |          0 |   0.00%
             LoopHoist |          0 |   0.00%
               Unknown |         49 |   0.17%
            RangeCheck |          0 |   0.00%
              CopyProp |          0 |   0.00%
           SideEffects |          0 |   0.00%
       ObjectAllocator |          0 |   0.00%
    VariableLiveRanges |        328 |   1.13%
           ClassLayout |          0 |   0.00%
       TailMergeThrows |          0 |   0.00%
             EarlyProp |          0 |   0.00%
              ZeroInit |          0 |   0.00%
                   Pgo |          0 |   0.00%

****** DONE compiling System.Console:WriteLine(System.Object)
