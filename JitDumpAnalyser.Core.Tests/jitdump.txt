****** START compiling System.Reflection.Emit.DynamicResolver:Finalize():this (MethodHash=00d7d3b2)
Generating code for Windows x64
OPTIONS: compCodeOpt = BLENDED_CODE
OPTIONS: compDbgCode = false
OPTIONS: compDbgInfo = true
OPTIONS: compDbgEnC  = false
OPTIONS: compProcedureSplitting   = false
OPTIONS: compProcedureSplittingEH = false
OPTIONS: optimized using static profile data
OPTIONS: Jit invoked for ngen
IL to import:
IL_0000  02                ldarg.0     
IL_0001  7b 16 17 00 04    ldfld        0x4001716
IL_0006  0a                stloc.0     
IL_0007  06                ldloc.0     
IL_0008  14                ldnull      
IL_0009  28 6d 5e 00 06    call         0x6005E6D
IL_000e  2c 02             brfalse.s    2 (IL_0012)
IL_0010  de 36             leave.s      54 (IL_0048)
IL_0012  06                ldloc.0     
IL_0013  7b 32 17 00 04    ldfld        0x4001732
IL_0018  2d 02             brtrue.s     2 (IL_001c)
IL_001a  de 2c             leave.s      44 (IL_0048)
IL_001c  00                nop         
IL_001d  73 21 61 00 06    newobj       0x6006121
IL_0022  0b                stloc.1     
IL_0023  de 09             leave.s      9 (IL_002e)
IL_0025  26                pop         
IL_0026  02                ldarg.0     
IL_0027  28 14 05 00 06    call         0x6000514
IL_002c  de 1a             leave.s      26 (IL_0048)
IL_002e  07                ldloc.1     
IL_002f  06                ldloc.0     
IL_0030  7b 32 17 00 04    ldfld        0x4001732
IL_0035  6f 82 06 00 06    callvirt     0x6000682
IL_003a  7d 1b 17 00 04    stfld        0x400171B
IL_003f  de 07             leave.s      7 (IL_0048)
IL_0041  02                ldarg.0     
IL_0042  28 ff 05 00 06    call         0x60005FF
IL_0047  dc                endfinally  
IL_0048  2a                ret         

lvaSetClass: setting class for V00 to (40000000004267A0) System.Reflection.Emit.DynamicResolver 
'this'    passed in register rcx

lvaSetClass: setting class for V01 to (4000000000422778) System.Reflection.Emit.DynamicMethod 

lvaSetClass: setting class for V02 to (40000000004267F8) System.Reflection.Emit.DynamicResolver+DestroyScout 

lvaGrabTemp returning 3 (V03 tmp0) (a long lifetime temp) called for OutgoingArgSpace.
; Initial local variable assignments
;
;  V00 this              ref  this class-hnd
;  V01 loc0              ref  class-hnd
;  V02 loc1              ref  class-hnd
;  V03 OutArgs        lclBlk <na>  "OutgoingArgSpace"
*************** In compInitDebuggingInfo() for System.Reflection.Emit.DynamicResolver:Finalize():this
getVars() returned cVars = 0, extendOthers = true
info.compVarScopesCount = 3
    	VarNum 	LVNum 	      Name 	Beg 	End
 0: 	00h 	00h 	  V00 this 	000h   	049h
 1: 	01h 	01h 	  V01 loc0 	000h   	049h
 2: 	02h 	02h 	  V02 loc1 	000h   	049h
info.compStmtOffsetsCount    = 0
info.compStmtOffsetsImplicit = 0007h ( STACK_EMPTY NOP CALL_SITE )
*************** In fgFindBasicBlocks() for System.Reflection.Emit.DynamicResolver:Finalize():this
Marked V01 as a single def local
Marked V02 as a single def local
Jump targets:
  IL_0000
  IL_0012
  IL_001c
  IL_001d
  IL_0025
  IL_002e
  IL_0041
  IL_0048
New Basic Block BB01 [0000] created.
BB01 [000..010)
New Basic Block BB02 [0001] created.
BB02 [010..012)
New Basic Block BB03 [0002] created.
BB03 [012..01A)
New Basic Block BB04 [0003] created.
BB04 [01A..01C)
New Basic Block BB05 [0004] created.
BB05 [01C..01D)
New Basic Block BB06 [0005] created.
BB06 [01D..025)
New Basic Block BB07 [0006] created.
BB07 [025..02E)
New Basic Block BB08 [0007] created.
BB08 [02E..041)
New Basic Block BB09 [0008] created.
BB09 [041..048)
New Basic Block BB10 [0009] created.
BB10 [048..049)
EH clause #0:
  Flags:         0x0 (catch)
  TryOffset:     0x1d
  TryLength:     0x8
  HandlerOffset: 0x25
  HandlerLength: 0x9
  ClassToken:    0x2000090
EH clause #1:
  Flags:         0x2 (finally)
  TryOffset:     0x0
  TryLength:     0x41
  HandlerOffset: 0x41
  HandlerLength: 0x7
  ClassToken:    0x0
*************** After fgFindBasicBlocks() has created the EH table

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB08 [000..041), Finally at BB09..BB09 [041..048)
*************** In fgNormalizeEH()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                        100       [000..010)-> BB03 ( cond ) T1      try {       keep try 
BB02 [0001]  1  1                        100       [010..012)-> BB10 (leave ) T1                  
BB03 [0002]  1  1                        100       [012..01A)-> BB05 ( cond ) T1                  
BB04 [0003]  1  1                        100       [01A..01C)-> BB10 (leave ) T1                  
BB05 [0004]  1  1                        100       [01C..01D)                 T1                  
BB06 [0005]  1  0                        100       [01D..025)-> BB08 (leave ) T0      try { }     keep try 
BB07 [0006]  1  1  0                     100       [025..02E)-> BB10 (leave ) T1 H0   catch { }   keep 
BB08 [0007]  1  1                        100       [02E..041)-> BB10 (leave ) T1      }           
BB09 [0008]  1     1                     100       [041..048)        (finret)    H1   finally { } keep 
BB10 [0009]  4                           100       [048..049)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB08 [000..041), Finally at BB09..BB09 [041..048)
No EH normalization performed.
INLINER: during 'prejit' result 'failed this callee' reason 'has exception handling' for 'n/a' calling 'System.Reflection.Emit.DynamicResolver:Finalize():this'

INLINER: Marking System.Reflection.Emit.DynamicResolver:Finalize():this as NOINLINE because of has exception handling
INLINER: during 'prejit' result 'failed this callee' reason 'has exception handling'
IL Code Size,Instr   73,  30, Basic Block count  10, Local Variable Num,Ref count   4,  9 for method System.Reflection.Emit.DynamicResolver:Finalize():this
OPTIONS: opts.MinOpts() == false
Basic block list for 'System.Reflection.Emit.DynamicResolver:Finalize():this'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                        100       [000..010)-> BB03 ( cond ) T1      try {       keep try 
BB02 [0001]  1  1                        100       [010..012)-> BB10 (leave ) T1                  
BB03 [0002]  1  1                        100       [012..01A)-> BB05 ( cond ) T1                  
BB04 [0003]  1  1                        100       [01A..01C)-> BB10 (leave ) T1                  
BB05 [0004]  1  1                        100       [01C..01D)                 T1                  
BB06 [0005]  1  0                        100       [01D..025)-> BB08 (leave ) T0      try { }     keep try 
BB07 [0006]  1  1  0                     100       [025..02E)-> BB10 (leave ) T1 H0   catch { }   keep 
BB08 [0007]  1  1                        100       [02E..041)-> BB10 (leave ) T1      }           
BB09 [0008]  1     1                     100       [041..048)        (finret)    H1   finally { } keep 
BB10 [0009]  4                           100       [048..049)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Pre-import

*************** Finishing PHASE Pre-import

*************** Starting PHASE Profile incorporation
Have static profile data: 7 schema records (schema at 000001D693B43018, data at 000001D693B43258)
Profile summary: 1 runs, 0 block probes, 5 edge probes, 1 class profiles, 0 method profiles, 0 other records

Reconstructing block counts from sparse edge instrumentation
... adding known edge BB04 -> BB10: weight 0
... adding known edge BB07 -> BB07: weight 0
... adding known edge BB08 -> BB10: weight 85
... adding known edge BB09 -> BB09: weight 85
... adding known edge BB10 -> BB01: weight 85

New BlockSet epoch 1, # of blocks (including unused BB00): 11, bitset array size: 1 (short)
 ... unknown edge BB01 -> BB03
 ... unknown edge BB01 -> BB02
 ... unknown edge BB02 -> BB10
 ... unknown edge BB03 -> BB05
 ... unknown edge BB03 -> BB04
 ... unknown edge BB05 -> BB06
 ... unknown edge BB06 -> BB08

Solver: 10 blocks, 10 unknown; 12 edges, 7 unknown, 0 zero (and so ignored)

Pass [1]: 10 unknown blocks, 7 unknown edges
BB10: 1 incoming unknown, 0 outgoing unknown
BB10: all outgoing edge weights known, summming...
  BB10 -> BB01 has weight 85
BB10: all outgoing edge weights known, sum is 85
BB02 -> BB10: target block weight and all other incoming edge weights known, so weight is 0
BB09: 0 incoming unknown, 0 outgoing unknown
BB09: all incoming edge weights known, summming...
  BB09 -> BB09 has weight 85
BB09: all incoming edge weights known, sum is 85
BB08: 1 incoming unknown, 0 outgoing unknown
BB08: all outgoing edge weights known, summming...
  BB08 -> BB10 has weight 85
BB08: all outgoing edge weights known, sum is 85
BB06 -> BB08: target block weight and all other incoming edge weights known, so weight is 85
BB07: 0 incoming unknown, 0 outgoing unknown
BB07: all incoming edge weights known, summming...
  BB07 -> BB07 has weight 0
BB07: all incoming edge weights known, sum is 0
BB06: 1 incoming unknown, 0 outgoing unknown
BB06: all outgoing edge weights known, summming...
  BB06 -> BB08 has weight 85
BB06: all outgoing edge weights known, sum is 85
BB05 -> BB06: target block weight and all other incoming edge weights known, so weight is 85
BB05: 1 incoming unknown, 0 outgoing unknown
BB05: all outgoing edge weights known, summming...
  BB05 -> BB06 has weight 85
BB05: all outgoing edge weights known, sum is 85
BB03 -> BB05: target block weight and all other incoming edge weights known, so weight is 85
BB04: 1 incoming unknown, 0 outgoing unknown
BB04: all outgoing edge weights known, summming...
  BB04 -> BB10 has weight 0
BB04: all outgoing edge weights known, sum is 0
BB03 -> BB04: target block weight and all other incoming edge weights known, so weight is 0
BB03: 1 incoming unknown, 0 outgoing unknown
BB03: all outgoing edge weights known, summming...
  BB03 -> BB04 has weight 0
  BB03 -> BB05 has weight 85
BB03: all outgoing edge weights known, sum is 85
BB01 -> BB03: target block weight and all other incoming edge weights known, so weight is 85
BB02: 1 incoming unknown, 0 outgoing unknown
BB02: all outgoing edge weights known, summming...
  BB02 -> BB10 has weight 0
BB02: all outgoing edge weights known, sum is 0
BB01 -> BB02: target block weight and all other incoming edge weights known, so weight is 0
BB01: 0 incoming unknown, 0 outgoing unknown
BB01: all incoming edge weights known, summming...
  BB10 -> BB01 has weight 85
BB01: all incoming edge weights known, sum is 85

Solver: converged in 1 passes
Suppressing zero count for BB07 as it is a handler entry

*************** Finishing PHASE Profile incorporation
Trees after Profile incorporation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB10 (leave ) T1                  rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB10 (leave ) T1                  rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (leave ) T0      try { }     keep try IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB10 (leave ) T1 H0   catch { }   keep 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB10 (leave ) T1      }           IBC 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB03 (cond), preds={} succs={BB02,BB03}

------------ BB02 [010..012) -> BB10 (leave), preds={} succs={BB10}

------------ BB03 [012..01A) -> BB05 (cond), preds={} succs={BB04,BB05}

------------ BB04 [01A..01C) -> BB10 (leave), preds={} succs={BB10}

------------ BB05 [01C..01D), preds={} succs={BB06}

------------ BB06 [01D..025) -> BB08 (leave), preds={} succs={BB08}

------------ BB07 [025..02E) -> BB10 (leave), preds={} succs={BB10}

------------ BB08 [02E..041) -> BB10 (leave), preds={} succs={BB10}

------------ BB09 [041..048) (finret), preds={} succs={}

------------ BB10 [048..049) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Importation
*************** In impImport() for System.Reflection.Emit.DynamicResolver:Finalize():this

impImportBlockPending for BB01

impImportBlockPending for BB09

Importing BB01 (PC=000) of 'System.Reflection.Emit.DynamicResolver:Finalize():this'
    [ 0]   0 (0x000) ldarg.0
    [ 1]   1 (0x001) ldfld 04001716
    [ 1]   6 (0x006) stloc.0Querying runtime about current class of field System.Reflection.Emit.DynamicResolver.m_method (declared as System.Reflection.Emit.DynamicMethod)
Field's current class not available


STMT00000 ( 0x000[E-] ... ??? )
               [000003] -A-XG------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         
               [000001] ---XG------                         \--*  FIELD     ref    m_method
               [000000] -----------                            \--*  LCL_VAR   ref    V00 this         

    [ 0]   7 (0x007) ldloc.0
    [ 1]   8 (0x008) ldnull
    [ 2]   9 (0x009) call 06005E6D
In Compiler::impImportCall: opcode is call, kind=0, callRetType is bool, structSize is 0


STMT00001 ( 0x007[E-] ... ??? )
               [000006] I-C-G------                         *  CALL r2r_ind int    System.Reflection.MethodInfo.op_Equality (exactContextHnd=0x40000000004205B9)
               [000004] ----------- arg0                    +--*  LCL_VAR   ref    V01 loc0         
               [000005] ----------- arg1                    \--*  CNS_INT   ref    null

    [ 1]  14 (0x00e) brfalse.s

STMT00002 ( 0x007[E-] ... ??? )
               [000011] --C--------                         *  JTRUE     void  
               [000010] --C--------                         \--*  EQ        int   
               [000008] --C--------                            +--*  CAST      int <- bool <- int
               [000007] --C--------                            |  \--*  RET_EXPR  int   (inl return expr [000006])
               [000009] -----------                            \--*  CNS_INT   int    0

impImportBlockPending for BB02

impImportBlockPending for BB03

Importing BB03 (PC=018) of 'System.Reflection.Emit.DynamicResolver:Finalize():this'
    [ 0]  18 (0x012) ldloc.0
    [ 1]  19 (0x013) ldfld 04001732
    [ 1]  24 (0x018) brtrue.s

STMT00003 ( 0x012[E-] ... ??? )
               [000016] ---XG------                         *  JTRUE     void  
               [000015] ---XG------                         \--*  NE        int   
               [000013] ---XG------                            +--*  FIELD     ref    m_methodHandle
               [000012] -----------                            |  \--*  LCL_VAR   ref    V01 loc0         
               [000014] -----------                            \--*  CNS_INT   ref    null

impImportBlockPending for BB04

impImportBlockPending for BB05

Importing BB05 (PC=028) of 'System.Reflection.Emit.DynamicResolver:Finalize():this'
    [ 0]  28 (0x01c) nop
impImportBlockPending for BB06

impImportBlockPending for BB07

Importing BB06 (PC=029) of 'System.Reflection.Emit.DynamicResolver:Finalize():this'
    [ 0]  29 (0x01d) newobj
lvaGrabTemp returning 4 (V04 tmp1) called for NewObj constructor temp.

Spilling stack for finalizable newobj


STMT00004 ( 0x01D[E-] ... ??? )
               [000023] -A---------                         *  ASG       ref   
               [000022] D------N---                         +--*  LCL_VAR   ref    V04 tmp1         
               [000021] -----------                         \--*  ALLOCOBJ  ref   
               [000020] #----------                            \--*  IND       long  
               [000019] H----------                               \--*  CNS_INT(h) long   0x4000000000426c70 method
Marked V04 as a single def local

lvaSetClass: setting class for V04 to (40000000004267F8) System.Reflection.Emit.DynamicResolver+DestroyScout  [exact]
 06006121
In Compiler::impImportCall: opcode is newobj, kind=0, callRetType is void, structSize is 0


STMT00005 ( ??? ... ??? )
               [000025] I-C-G------                         *  CALL r2r_ind void   DestroyScout..ctor (exactContextHnd=0x40000000004267F9)
               [000024] ----------- this                    \--*  LCL_VAR   ref    V04 tmp1         

    [ 1]  34 (0x022) stloc.1
lvaUpdateClass: Updating class for V02 from (40000000004267F8) System.Reflection.Emit.DynamicResolver+DestroyScout to (40000000004267F8) System.Reflection.Emit.DynamicResolver+DestroyScout [exact]


STMT00006 ( 0x022[--] ... ??? )
               [000028] -A---------                         *  ASG       ref   
               [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         
               [000026] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

    [ 0]  35 (0x023) leave.s 002E
Before import CEE_LEAVE in BB06 (targetting BB08):

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB10 (leave ) T1                  rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB10 (leave ) T1                  rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (leave ) T0      try { }     keep try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB10 (leave ) T1 H0   catch { }   keep 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB10 (leave ) T1      }           IBC 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB08 [000..041), Finally at BB09..BB09 [041..048)
impImportLeave - no enclosing finally-protected try blocks or catch handlers; convert CEE_LEAVE block BB06 to BBJ_ALWAYS

After import CEE_LEAVE:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB10 (leave ) T1                  rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB10 (leave ) T1                  rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB10 (leave ) T1 H0   catch { }   keep 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB10 (leave ) T1      }           IBC 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB08 [000..041), Finally at BB09..BB09 [041..048)

impImportBlockPending for BB08

Importing BB08 (PC=046) of 'System.Reflection.Emit.DynamicResolver:Finalize():this'
    [ 0]  46 (0x02e) ldloc.1
    [ 1]  47 (0x02f) ldloc.0
    [ 2]  48 (0x030) ldfld 04001732
    [ 2]  53 (0x035) callvirt 06000682
In Compiler::impImportCall: opcode is callvirt, kind=2, callRetType is struct, structSize is 8
Querying runtime about current class of field System.Reflection.Emit.DynamicMethod.m_methodHandle (declared as System.IRuntimeMethodInfo)
Field's current class not available

impDevirtualizeCall: Trying to devirtualize interface call:
    class for 'this' is System.IRuntimeMethodInfo (attrib 00200400)
    base method is System.IRuntimeMethodInfo::get_Value
Considering guarded devirtualization at IL offset 53 (0x35)
Likely classes for 40000000004249D8 (System.IRuntimeMethodInfo):
  1) 40000000004257D8 (System.RuntimeMethodInfoStub) [likelihood:100%]
interface call would invoke method System.IRuntimeMethodInfo.get_Value
Marking call [000032] as guarded devirtualization candidate; will guess for class System.RuntimeMethodInfoStub


STMT00007 ( 0x02E[E-] ... ??? )
               [000032] &-CXG------                         *  CALLV stub struct System.IRuntimeMethodInfo.get_Value (exactContextHnd=0x40000000004249D9)
               [000031] ---XG------ this                    \--*  FIELD     ref    m_methodHandle
               [000030] -----------                            \--*  LCL_VAR   ref    V01 loc0         

    [ 2]  58 (0x03a) stfld 0400171B

STMT00008 ( 0x02E[E-] ... ??? )
               [000037] -ACXG------                         *  ASG       struct (copy)
               [000036] ---XG------                         +--*  BLK       struct<System.RuntimeMethodHandleInternal, 8>
               [000035] ---XG------                         |  \--*  ADDR      byref 
               [000034] ---XG--N---                         |     \--*  FIELD     struct m_methodHandle
               [000029] -----------                         |        \--*  LCL_VAR   ref    V02 loc1         
               [000033] --C--------                         \--*  RET_EXPR  struct(inl return expr [000032])

    [ 0]  63 (0x03f) leave.s 0048
Before import CEE_LEAVE in BB08 (targetting BB10):

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB10 (leave ) T1                  rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB10 (leave ) T1                  rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB10 (leave ) T1 H0   catch { }   keep 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB10 (leave ) T1      }           IBC 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB08 [000..041), Finally at BB09..BB09 [041..048)
fgFindInsertPoint(regionIndex=0, putInTryRegion=true, startBlk=BB01, endBlk=BB00, nearBlk=BB08, jumpBlk=BB00, runRarely=false)
fgNewBBinRegion(jumpKind=8, tryIndex=0, hndIndex=0, putInFilter=false, runRarely=false, insertAtEnd=false): inserting after BB08
New Basic Block BB11 [0010] created.
impImportLeave - jumping out of a finally-protected try (EH#1), convert block BB08 to BBJ_ALWAYS, add BBJ_CALLFINALLY block BB11
New Basic Block BB12 [0011] created.
impImportLeave - jumping out of a finally-protected try (EH#1), created step (BBJ_ALWAYS) block BB12
impImportLeave - final destination of step blocks set to BB10

impImportBlockPending for BB10

After import CEE_LEAVE:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB10 (leave ) T1                  rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB10 (leave ) T1                  rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB10 (leave ) T1 H0   catch { }   keep 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           IBC 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB08 [000..041), Finally at BB09..BB09 [041..048)

impImportBlockPending for BB11

Importing BB10 (PC=072) of 'System.Reflection.Emit.DynamicResolver:Finalize():this'
    [ 0]  72 (0x048) ret

STMT00009 ( 0x048[E-] ... ??? )
               [000038] -----------                         *  RETURN    void  

Importing BB07 (PC=037) of 'System.Reflection.Emit.DynamicResolver:Finalize():this'
lvaGrabTemp returning 5 (V05 tmp2) called for impSpillSpecialSideEff.


STMT00010 ( 0x025[--] ... ??? )
               [000040] -A---O-----                         *  ASG       ref   
               [000039] D------N---                         +--*  LCL_VAR   ref    V05 tmp2         
               [000018] -----O-----                         \--*  CATCH_ARG ref   
Marked V05 as a single def temp

lvaSetClass: setting class for V05 to (4000000000420038) System.Object 

    [ 1]  37 (0x025) pop
    [ 0]  38 (0x026) ldarg.0
    [ 1]  39 (0x027) call 06000514
In Compiler::impImportCall: opcode is call, kind=0, callRetType is void, structSize is 0

Will not inline blocks that are in the catch handler region
INLINER: during 'impMarkInlineCandidate' result 'failed this call site' reason 'within catch region' for 'System.Reflection.Emit.DynamicResolver:Finalize():this' calling 'System.GC:ReRegisterForFinalize(System.Object)'
INLINER: during 'impMarkInlineCandidate' result 'failed this call site' reason 'within catch region'


STMT00011 ( 0x026[E-] ... ??? )
               [000043] --C-G------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
               [000042] ----------- arg0                    \--*  LCL_VAR   ref    V00 this         

    [ 0]  44 (0x02c) leave.s 0048
Before import CEE_LEAVE in BB07 (targetting BB10):

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB10 (leave ) T1                  rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB10 (leave ) T1                  rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB10 (leave ) T1 H0   catch { }   keep 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i IBC 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB08 [000..041), Finally at BB09..BB09 [041..048)
impImportLeave - jumping out of a catch (EH#0), convert block BB07 to BBJ_EHCATCHRET block
fgFindInsertPoint(regionIndex=2, putInTryRegion=true, startBlk=BB01, endBlk=BB11, nearBlk=BB07, jumpBlk=BB00, runRarely=false)
fgNewBBinRegion(jumpKind=6, tryIndex=2, hndIndex=0, putInFilter=false, runRarely=false, insertAtEnd=false): inserting after BB07
New Basic Block BB13 [0012] created.
impImportLeave - jumping out of a finally-protected try (EH#1), step block is BBJ_EHCATCHRET (BB07), new BBJ_ALWAYS step-step block BB13
fgFindInsertPoint(regionIndex=0, putInTryRegion=true, startBlk=BB01, endBlk=BB00, nearBlk=BB13, jumpBlk=BB00, runRarely=false)
fgNewBBinRegion(jumpKind=8, tryIndex=0, hndIndex=0, putInFilter=false, runRarely=false, insertAtEnd=false): inserting after BB08
New Basic Block BB14 [0013] created.
impImportLeave - jumping out of a finally-protected try (EH#1), new BBJ_CALLFINALLY block BB14
New Basic Block BB15 [0014] created.
impImportLeave - jumping out of a finally-protected try (EH#1), created step (BBJ_ALWAYS) block BB15
impImportLeave - final destination of step blocks set to BB10

impImportBlockPending for BB10

After import CEE_LEAVE:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB10 (leave ) T1                  rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB10 (leave ) T1                  rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB13 ( cret ) T1 H0   catch { }   keep 
BB13 [0012]  1  1                          1           [???..???)-> BB14 (always) T1                  i internal 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i IBC 
BB14 [0013]  1                             1           [???..???)-> BB09 (callf )                     i internal 
BB15 [0014]  0                             1           [???..???)-> BB10 (ALWAYS)                     i internal KEEP 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB08 [000..041), Finally at BB09..BB09 [041..048)

impImportBlockPending for BB13

Importing BB04 (PC=026) of 'System.Reflection.Emit.DynamicResolver:Finalize():this'
    [ 0]  26 (0x01a) leave.s 0048
Before import CEE_LEAVE in BB04 (targetting BB10):

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB10 (leave ) T1                  rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB10 (leave ) T1                  rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB13 ( cret ) T1 H0   catch { }   keep i 
BB13 [0012]  1  1                          1           [???..???)-> BB14 (always) T1                  i internal 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i IBC 
BB14 [0013]  1                             1           [???..???)-> BB09 (callf )                     i internal 
BB15 [0014]  0                             1           [???..???)-> BB10 (ALWAYS)                     i internal KEEP 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB08 [000..041), Finally at BB09..BB09 [041..048)
fgFindInsertPoint(regionIndex=0, putInTryRegion=true, startBlk=BB01, endBlk=BB00, nearBlk=BB04, jumpBlk=BB00, runRarely=false)
fgNewBBinRegion(jumpKind=8, tryIndex=0, hndIndex=0, putInFilter=false, runRarely=false, insertAtEnd=false): inserting after BB08
New Basic Block BB16 [0015] created.
impImportLeave - jumping out of a finally-protected try (EH#1), convert block BB04 to BBJ_ALWAYS, add BBJ_CALLFINALLY block BB16
New Basic Block BB17 [0016] created.
impImportLeave - jumping out of a finally-protected try (EH#1), created step (BBJ_ALWAYS) block BB17
impImportLeave - final destination of step blocks set to BB10

impImportBlockPending for BB10

After import CEE_LEAVE:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB10 (leave ) T1                  rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB16 (always) T1                  rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB13 ( cret ) T1 H0   catch { }   keep i 
BB13 [0012]  1  1                          1           [???..???)-> BB14 (always) T1                  i internal 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i IBC 
BB16 [0015]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB17 [0016]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB14 [0013]  1                             1           [???..???)-> BB09 (callf )                     i internal 
BB15 [0014]  0                             1           [???..???)-> BB10 (ALWAYS)                     i internal KEEP 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB08 [000..041), Finally at BB09..BB09 [041..048)

impImportBlockPending for BB16

Importing BB02 (PC=016) of 'System.Reflection.Emit.DynamicResolver:Finalize():this'
    [ 0]  16 (0x010) leave.s 0048
Before import CEE_LEAVE in BB02 (targetting BB10):

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB10 (leave ) T1                  rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB16 (always) T1                  i rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB13 ( cret ) T1 H0   catch { }   keep i 
BB13 [0012]  1  1                          1           [???..???)-> BB14 (always) T1                  i internal 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i IBC 
BB16 [0015]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB17 [0016]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB14 [0013]  1                             1           [???..???)-> BB09 (callf )                     i internal 
BB15 [0014]  0                             1           [???..???)-> BB10 (ALWAYS)                     i internal KEEP 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB08 [000..041), Finally at BB09..BB09 [041..048)
fgFindInsertPoint(regionIndex=0, putInTryRegion=true, startBlk=BB01, endBlk=BB00, nearBlk=BB02, jumpBlk=BB00, runRarely=false)
fgNewBBinRegion(jumpKind=8, tryIndex=0, hndIndex=0, putInFilter=false, runRarely=false, insertAtEnd=false): inserting after BB08
New Basic Block BB18 [0017] created.
impImportLeave - jumping out of a finally-protected try (EH#1), convert block BB02 to BBJ_ALWAYS, add BBJ_CALLFINALLY block BB18
New Basic Block BB19 [0018] created.
impImportLeave - jumping out of a finally-protected try (EH#1), created step (BBJ_ALWAYS) block BB19
impImportLeave - final destination of step blocks set to BB10

impImportBlockPending for BB10

After import CEE_LEAVE:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB18 (always) T1                  rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB16 (always) T1                  i rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB13 ( cret ) T1 H0   catch { }   keep i 
BB13 [0012]  1  1                          1           [???..???)-> BB14 (always) T1                  i internal 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB19 [0018]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB16 [0015]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB17 [0016]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB14 [0013]  1                             1           [???..???)-> BB09 (callf )                     i internal 
BB15 [0014]  0                             1           [???..???)-> BB10 (ALWAYS)                     i internal KEEP 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB08 [000..041), Finally at BB09..BB09 [041..048)

impImportBlockPending for BB18

Importing BB09 (PC=065) of 'System.Reflection.Emit.DynamicResolver:Finalize():this'
    [ 0]  65 (0x041) ldarg.0
    [ 1]  66 (0x042) call 060005FF
In Compiler::impImportCall: opcode is call, kind=0, callRetType is void, structSize is 0


STMT00012 ( 0x041[E-] ... ??? )
               [000045] I-C-G------                         *  CALL r2r_ind void   System.Object.Finalize (exactContextHnd=0x4000000000420039)
               [000044] ----------- this                    \--*  LCL_VAR   ref    V00 this         

    [ 0]  71 (0x047) endfinally

STMT00013 ( 0x047[E-] ... ??? )
               [000046] -----------                         *  RETFILT   void  

After impImport() added block for try,catch,finally
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB18 (always) T1                  i rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB16 (always) T1                  i rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB13 ( cret ) T1 H0   catch { }   keep i 
BB13 [0012]  1  1                          1           [???..???)-> BB14 (always) T1                  i internal 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB19 [0018]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB16 [0015]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB17 [0016]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB14 [0013]  1                             1           [???..???)-> BB09 (callf )                     i internal 
BB15 [0014]  0                             1           [???..???)-> BB10 (ALWAYS)                     i internal KEEP 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep i IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------


** Note: root method IL was partially imported -- imported 68 of 73 bytes of method IL

*************** Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB18 (always) T1                  i rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB16 (always) T1                  i rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB13 ( cret ) T1 H0   catch { }   keep i 
BB13 [0012]  1  1                          1           [???..???)-> BB14 (always) T1                  i internal 
BB08 [0007]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB19 [0018]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB16 [0015]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB17 [0016]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB14 [0013]  1                             1           [???..???)-> BB09 (callf )                     i internal 
BB15 [0014]  0                             1           [???..???)-> BB10 (ALWAYS)                     i internal KEEP 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep i IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
               [000003] -A-XG------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         
               [000001] ---XG------                         \--*  FIELD     ref    m_method
               [000000] -----------                            \--*  LCL_VAR   ref    V00 this         

***** BB01
STMT00001 ( 0x007[E-] ... 0x00E )
               [000006] I-C-G------                         *  CALL r2r_ind int    System.Reflection.MethodInfo.op_Equality (exactContextHnd=0x40000000004205B9)
               [000004] ----------- arg0                    +--*  LCL_VAR   ref    V01 loc0         
               [000005] ----------- arg1                    \--*  CNS_INT   ref    null

***** BB01
STMT00002 ( 0x007[E-] ... ??? )
               [000011] --C--------                         *  JTRUE     void  
               [000010] --C--------                         \--*  EQ        int   
               [000008] --C--------                            +--*  CAST      int <- bool <- int
               [000007] --C--------                            |  \--*  RET_EXPR  int   (inl return expr [000006])
               [000009] -----------                            \--*  CNS_INT   int    0

------------ BB02 [010..012) -> BB18 (always), preds={} succs={BB18}

------------ BB03 [012..01A) -> BB05 (cond), preds={} succs={BB04,BB05}

***** BB03
STMT00003 ( 0x012[E-] ... 0x018 )
               [000016] ---XG------                         *  JTRUE     void  
               [000015] ---XG------                         \--*  NE        int   
               [000013] ---XG------                            +--*  FIELD     ref    m_methodHandle
               [000012] -----------                            |  \--*  LCL_VAR   ref    V01 loc0         
               [000014] -----------                            \--*  CNS_INT   ref    null

------------ BB04 [01A..01C) -> BB16 (always), preds={} succs={BB16}

------------ BB05 [01C..01D), preds={} succs={BB06}

------------ BB06 [01D..025) -> BB08 (always), preds={} succs={BB08}

***** BB06
STMT00004 ( 0x01D[E-] ... 0x022 )
               [000023] -A---------                         *  ASG       ref   
               [000022] D------N---                         +--*  LCL_VAR   ref    V04 tmp1         
               [000021] -----------                         \--*  ALLOCOBJ  ref   
               [000020] #----------                            \--*  IND       long  
               [000019] H----------                               \--*  CNS_INT(h) long   0x4000000000426c70 method

***** BB06
STMT00005 ( ??? ... ??? )
               [000025] I-C-G------                         *  CALL r2r_ind void   DestroyScout..ctor (exactContextHnd=0x40000000004267F9)
               [000024] ----------- this                    \--*  LCL_VAR   ref    V04 tmp1         

***** BB06
STMT00006 ( 0x022[--] ... ??? )
               [000028] -A---------                         *  ASG       ref   
               [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         
               [000026] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

------------ BB07 [025..02E) -> BB13 (cret), preds={} succs={BB13}

***** BB07
STMT00010 ( 0x025[--] ... 0x02C )
               [000040] -A---O-----                         *  ASG       ref   
               [000039] D------N---                         +--*  LCL_VAR   ref    V05 tmp2         
               [000018] -----O-----                         \--*  CATCH_ARG ref   

***** BB07
STMT00011 ( 0x026[E-] ... ??? )
               [000043] --C-G------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
               [000042] ----------- arg0                    \--*  LCL_VAR   ref    V00 this         

------------ BB13 [???..???) -> BB14 (always), preds={} succs={BB14}

------------ BB08 [02E..041) -> BB11 (always), preds={} succs={BB11}

***** BB08
STMT00007 ( 0x02E[E-] ... 0x03A )
               [000032] &-CXG------                         *  CALLV stub struct System.IRuntimeMethodInfo.get_Value (exactContextHnd=0x40000000004249D9)
               [000031] ---XG------ this                    \--*  FIELD     ref    m_methodHandle
               [000030] -----------                            \--*  LCL_VAR   ref    V01 loc0         

***** BB08
STMT00008 ( 0x02E[E-] ... ??? )
               [000037] -ACXG------                         *  ASG       struct (copy)
               [000036] ---XG------                         +--*  BLK       struct<System.RuntimeMethodHandleInternal, 8>
               [000035] ---XG------                         |  \--*  ADDR      byref 
               [000034] ---XG--N---                         |     \--*  FIELD     struct m_methodHandle
               [000029] -----------                         |        \--*  LCL_VAR   ref    V02 loc1         
               [000033] --C--------                         \--*  RET_EXPR  struct(inl return expr [000032])

------------ BB18 [???..???) -> BB09 (callf), preds={} succs={BB09}

------------ BB19 [???..???) -> BB10 (ALWAYS), preds={} succs={BB10}

------------ BB16 [???..???) -> BB09 (callf), preds={} succs={BB09}

------------ BB17 [???..???) -> BB10 (ALWAYS), preds={} succs={BB10}

------------ BB14 [???..???) -> BB09 (callf), preds={} succs={BB09}

------------ BB15 [???..???) -> BB10 (ALWAYS), preds={} succs={BB10}

------------ BB11 [???..???) -> BB09 (callf), preds={} succs={BB09}

------------ BB12 [???..???) -> BB10 (ALWAYS), preds={} succs={BB10}

------------ BB09 [041..048) (finret), preds={} succs={BB19,BB17,BB15,BB12}

***** BB09
STMT00012 ( 0x041[E-] ... 0x047 )
               [000045] I-C-G------                         *  CALL r2r_ind void   System.Object.Finalize (exactContextHnd=0x4000000000420039)
               [000044] ----------- this                    \--*  LCL_VAR   ref    V00 this         

***** BB09
STMT00013 ( 0x047[E-] ... ??? )
               [000046] -----------                         *  RETFILT   void  

------------ BB10 [048..049) (return), preds={} succs={}

***** BB10
STMT00009 ( 0x048[E-] ... 0x048 )
               [000038] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Finishing PHASE Expand patchpoints [no changes]

*************** Starting PHASE Indirect call transform

----------------

*** GuardedDevirtualization contemplating [000032] in BB08 
Likelihood of correct guess is 100
*** GuardedDevirtualization: transforming STMT00007

lvaGrabTemp returning 6 (V06 tmp3) (a long lifetime temp) called for guarded devirt return temp.
Reworking call(s) to return value via a new temp V06
Bashing GT_RET_EXPR [000033] to refer to temp V06
New Basic Block BB20 [0019] created.
BB11 previous predecessor was BB08, now is BB20
EH#1: New last block of try: BB20

lvaGrabTemp returning 7 (V07 tmp4) called for guarded devirt this temp.
New Basic Block BB21 [0020] created.

lvaGrabTemp returning 8 (V08 tmp5) (a long lifetime temp) called for guarded devirt this exact temp.

lvaSetClass: setting class for V08 to (40000000004257D8) System.RuntimeMethodInfoStub  [exact]
Direct call [000062] in block BB21

impDevirtualizeCall: Trying to devirtualize interface call:
    class for 'this' is System.RuntimeMethodInfoStub [exact] (attrib 21000010)
    base method is System.IRuntimeMethodInfo::get_Value
--- base class is interface
    devirt to System.RuntimeMethodInfoStub::System.IRuntimeMethodInfo.get_Value -- exact
               [000062] I-CXG------                         *  CALLV stub struct System.IRuntimeMethodInfo.get_Value (exactContextHnd=0x40000000004249D9)
               [000064] ----------- this                    \--*  LCL_VAR   ref    V08 tmp5         
    exact; can devirtualize
... after devirt...
               [000062] I-CXG------                         *  CALL nullcheck struct System.RuntimeMethodInfoStub.System.IRuntimeMethodInfo.get_Value
               [000064] ----------- this                    \--*  LCL_VAR   ref    V08 tmp5         
New Basic Block BB22 [0021] created.
Residual call [000032] moved to block BB22
Scouting for possible GDV chain as likelihood 100 >= 75
 Scouting STMT00008

 -- 1 calls transformed

*************** Finishing PHASE Indirect call transform
Trees after Indirect call transform

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)-> BB03 ( cond ) T1      try {       keep i try IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB18 (always) T1                  i rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB16 (always) T1                  i rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB13 ( cret ) T1 H0   catch { }   keep i 
BB13 [0012]  1  1                          1           [???..???)-> BB14 (always) T1                  i internal 
BB08 [0007]  1  1                         85     85    [02E..02E)-> BB22 ( cond ) T1                  i IBC 
BB21 [0020]  0  1                         85     85    [???..???)-> BB20 (always) T1                  i internal IBC 
BB22 [0021]  0  1                          0      0    [???..???)                 T1                  i internal rare IBC 
BB20 [0019]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i internal IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB19 [0018]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB16 [0015]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB17 [0016]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB14 [0013]  1                             1           [???..???)-> BB09 (callf )                     i internal 
BB15 [0014]  0                             1           [???..???)-> BB10 (ALWAYS)                     i internal KEEP 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep i IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
               [000003] -A-XG------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         
               [000001] ---XG------                         \--*  FIELD     ref    m_method
               [000000] -----------                            \--*  LCL_VAR   ref    V00 this         

***** BB01
STMT00001 ( 0x007[E-] ... 0x00E )
               [000006] I-C-G------                         *  CALL r2r_ind int    System.Reflection.MethodInfo.op_Equality (exactContextHnd=0x40000000004205B9)
               [000004] ----------- arg0                    +--*  LCL_VAR   ref    V01 loc0         
               [000005] ----------- arg1                    \--*  CNS_INT   ref    null

***** BB01
STMT00002 ( 0x007[E-] ... ??? )
               [000011] --C--------                         *  JTRUE     void  
               [000010] --C--------                         \--*  EQ        int   
               [000008] --C--------                            +--*  CAST      int <- bool <- int
               [000007] --C--------                            |  \--*  RET_EXPR  int   (inl return expr [000006])
               [000009] -----------                            \--*  CNS_INT   int    0

------------ BB02 [010..012) -> BB18 (always), preds={} succs={BB18}

------------ BB03 [012..01A) -> BB05 (cond), preds={} succs={BB04,BB05}

***** BB03
STMT00003 ( 0x012[E-] ... 0x018 )
               [000016] ---XG------                         *  JTRUE     void  
               [000015] ---XG------                         \--*  NE        int   
               [000013] ---XG------                            +--*  FIELD     ref    m_methodHandle
               [000012] -----------                            |  \--*  LCL_VAR   ref    V01 loc0         
               [000014] -----------                            \--*  CNS_INT   ref    null

------------ BB04 [01A..01C) -> BB16 (always), preds={} succs={BB16}

------------ BB05 [01C..01D), preds={} succs={BB06}

------------ BB06 [01D..025) -> BB08 (always), preds={} succs={BB08}

***** BB06
STMT00004 ( 0x01D[E-] ... 0x022 )
               [000023] -A---------                         *  ASG       ref   
               [000022] D------N---                         +--*  LCL_VAR   ref    V04 tmp1         
               [000021] -----------                         \--*  ALLOCOBJ  ref   
               [000020] #----------                            \--*  IND       long  
               [000019] H----------                               \--*  CNS_INT(h) long   0x4000000000426c70 method

***** BB06
STMT00005 ( ??? ... ??? )
               [000025] I-C-G------                         *  CALL r2r_ind void   DestroyScout..ctor (exactContextHnd=0x40000000004267F9)
               [000024] ----------- this                    \--*  LCL_VAR   ref    V04 tmp1         

***** BB06
STMT00006 ( 0x022[--] ... ??? )
               [000028] -A---------                         *  ASG       ref   
               [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         
               [000026] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

------------ BB07 [025..02E) -> BB13 (cret), preds={} succs={BB13}

***** BB07
STMT00010 ( 0x025[--] ... 0x02C )
               [000040] -A---O-----                         *  ASG       ref   
               [000039] D------N---                         +--*  LCL_VAR   ref    V05 tmp2         
               [000018] -----O-----                         \--*  CATCH_ARG ref   

***** BB07
STMT00011 ( 0x026[E-] ... ??? )
               [000043] --C-G------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
               [000042] ----------- arg0                    \--*  LCL_VAR   ref    V00 this         

------------ BB13 [???..???) -> BB14 (always), preds={} succs={BB14}

------------ BB08 [02E..02E) -> BB22 (cond), preds={} succs={BB21,BB22}

***** BB08
STMT00014 ( 0x02E[E-] ... ??? )
               [000051] -A-XG------                         *  ASG       ref   
               [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         
               [000048] ---XG------                         \--*  FIELD     ref    m_methodHandle
               [000049] -----------                            \--*  LCL_VAR   ref    V01 loc0         

***** BB08
STMT00015 ( 0x02E[E-] ... ??? )
               [000058] ---X-------                         *  JTRUE     void  
               [000057] ---X-------                         \--*  NE        int   
               [000056] #----------                            +--*  IND       long  
               [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
               [000054] #--X-------                            \--*  IND       long  
               [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         

------------ BB21 [???..???) -> BB20 (always), preds={} succs={BB20}

***** BB21
STMT00016 ( ??? ... ??? )
               [000061] -A---------                         *  ASG       ref   
               [000060] D------N---                         +--*  LCL_VAR   ref    V08 tmp5         
               [000059] -----------                         \--*  LCL_VAR   ref    V07 tmp4         

***** BB21
STMT00017 ( 0x02E[E-] ... ??? )
               [000062] I-CXG------                         *  CALL r2r_ind struct System.RuntimeMethodInfoStub.System.IRuntimeMethodInfo.get_Value (exactContextHnd=0x4000000000425878)
               [000064] ----------- this                    \--*  LCL_VAR   ref    V08 tmp5         

***** BB21
STMT00018 ( ??? ... ??? )
               [000068] -AC--------                         *  ASG       struct (copy)
               [000066] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8> V06 tmp3         
               [000065] --C----N---                         \--*  RET_EXPR  struct(inl return expr [000062])

------------ BB22 [???..???), preds={} succs={BB20}

***** BB22
STMT00019 ( 0x02E[E-] ... ??? )
               [000071] -ACXG------                         *  ASG       struct (copy)
               [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8> V06 tmp3         
               [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] ----------- this                       \--*  LCL_VAR   ref    V07 tmp4         

------------ BB20 [02E..041) -> BB11 (always), preds={} succs={BB11}

***** BB20
STMT00008 ( 0x02E[E-] ... ??? )
               [000037] -ACXG------                         *  ASG       struct (copy)
               [000036] ---XG------                         +--*  BLK       struct<System.RuntimeMethodHandleInternal, 8>
               [000035] ---XG------                         |  \--*  ADDR      byref 
               [000034] ---XG--N---                         |     \--*  FIELD     struct m_methodHandle
               [000029] -----------                         |        \--*  LCL_VAR   ref    V02 loc1         
               [000047] -----------                         \--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8> V06 tmp3         

------------ BB18 [???..???) -> BB09 (callf), preds={} succs={BB09}

------------ BB19 [???..???) -> BB10 (ALWAYS), preds={} succs={BB10}

------------ BB16 [???..???) -> BB09 (callf), preds={} succs={BB09}

------------ BB17 [???..???) -> BB10 (ALWAYS), preds={} succs={BB10}

------------ BB14 [???..???) -> BB09 (callf), preds={} succs={BB09}

------------ BB15 [???..???) -> BB10 (ALWAYS), preds={} succs={BB10}

------------ BB11 [???..???) -> BB09 (callf), preds={} succs={BB09}

------------ BB12 [???..???) -> BB10 (ALWAYS), preds={} succs={BB10}

------------ BB09 [041..048) (finret), preds={} succs={BB19,BB17,BB15,BB12}

***** BB09
STMT00012 ( 0x041[E-] ... 0x047 )
               [000045] I-C-G------                         *  CALL r2r_ind void   System.Object.Finalize (exactContextHnd=0x4000000000420039)
               [000044] ----------- this                    \--*  LCL_VAR   ref    V00 this         

***** BB09
STMT00013 ( 0x047[E-] ... ??? )
               [000046] -----------                         *  RETFILT   void  

------------ BB10 [048..049) (return), preds={} succs={}

***** BB10
STMT00009 ( 0x048[E-] ... 0x048 )
               [000038] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Post-import

*************** Finishing PHASE Post-import

*************** Starting PHASE Morph - Init

New BlockSet epoch 2, # of blocks (including unused BB00): 23, bitset array size: 1 (short)

*************** In fgPostImportationCleanup

*************** Finishing PHASE Morph - Init
*************** In fgDebugCheckBBlist

*************** Starting PHASE Morph - Inlining
Querying runtime about current class of field System.Reflection.Emit.DynamicResolver.m_method (declared as System.Reflection.Emit.DynamicMethod)
Field's current class not available
Expanding INLINE_CANDIDATE in statement STMT00001 in BB01:
STMT00001 ( 0x007[E-] ... 0x00E )
               [000006] I-C-G------                         *  CALL r2r_ind int    System.Reflection.MethodInfo.op_Equality (exactContextHnd=0x40000000004205B9)
               [000004] ----------- arg0                    +--*  LCL_VAR   ref    V01 loc0         
               [000005] ----------- arg1                    \--*  CNS_INT   ref    null

Argument #0: is a local var
               [000004] -----------                         *  LCL_VAR   ref    V01 loc0         


Argument #1: is a constant
               [000005] -----------                         *  CNS_INT   ref    null

INLINER: inlineInfo.tokenLookupContextHandle for System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool set to 0x40000000004205B9:

Invoking compiler for the inlinee method System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool :
IL to import:
IL_0000  03                ldarg.1     
IL_0001  2d 07             brtrue.s     7 (IL_000a)
IL_0003  02                ldarg.0     
IL_0004  2c 02             brfalse.s    2 (IL_0008)
IL_0006  16                ldc.i4.0    
IL_0007  2a                ret         
IL_0008  17                ldc.i4.1    
IL_0009  2a                ret         
IL_000a  02                ldarg.0     
IL_000b  03                ldarg.1     
IL_000c  33 02             bne.un.s     2 (IL_0010)
IL_000e  17                ldc.i4.1    
IL_000f  2a                ret         
IL_0010  02                ldarg.0     
IL_0011  2c 08             brfalse.s    8 (IL_001b)
IL_0013  02                ldarg.0     
IL_0014  03                ldarg.1     
IL_0015  6f 01 06 00 06    callvirt     0x6000601
IL_001a  2a                ret         
IL_001b  16                ldc.i4.0    
IL_001c  2a                ret         

INLINER impTokenLookupContextHandle for System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool is 0x40000000004205B9.
*************** In compInitDebuggingInfo() for System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool
info.compStmtOffsetsCount    = 0
info.compStmtOffsetsImplicit = 0007h ( STACK_EMPTY NOP CALL_SITE )
*************** In fgFindBasicBlocks() for System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool
Jump targets:
  IL_0008
  IL_000a
  IL_0010
  IL_001b
New Basic Block BB23 [0022] created.
BB23 [000..003)
New Basic Block BB24 [0023] created.
BB24 [003..006)
New Basic Block BB25 [0024] created.
BB25 [006..008)
New Basic Block BB26 [0025] created.
BB26 [008..00A)
New Basic Block BB27 [0026] created.
BB27 [00A..00E)
New Basic Block BB28 [0027] created.
BB28 [00E..010)
New Basic Block BB29 [0028] created.
BB29 [010..013)
New Basic Block BB30 [0029] created.
BB30 [013..01B)
New Basic Block BB31 [0030] created.
BB31 [01B..01D)

lvaGrabTemp returning 9 (V09 tmp6) (a long lifetime temp) called for Inline return value spill temp.
Basic block list for 'System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB23 [0022]  1                           100       [000..003)-> BB27 ( cond )                     
BB24 [0023]  1                           100       [003..006)-> BB26 ( cond )                     
BB25 [0024]  1                           100       [006..008)        (return)                     
BB26 [0025]  1                           100       [008..00A)        (return)                     
BB27 [0026]  1                           100       [00A..00E)-> BB29 ( cond )                     
BB28 [0027]  1                           100       [00E..010)        (return)                     
BB29 [0028]  1                           100       [010..013)-> BB31 ( cond )                     
BB30 [0029]  1                           100       [013..01B)        (return)                     
BB31 [0030]  1                           100       [01B..01D)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000006] Starting PHASE Pre-import

*************** Inline @[000006] Finishing PHASE Pre-import

*************** Inline @[000006] Starting PHASE Profile incorporation
Have static profile data: 8 schema records (schema at 000001D693B4B648, data at 000001D693B4BED0)
Profile summary: 8 runs, 0 block probes, 5 edge probes, 1 class profiles, 0 method profiles, 0 other records

Reconstructing block counts from sparse edge instrumentation
... adding known edge BB25 -> BB23: weight 73485
... adding known edge BB26 -> BB23: weight 25242
... adding known edge BB28 -> BB23: weight 15599
... adding known edge BB30 -> BB23: weight 1857
... adding known edge BB31 -> BB23: weight 2

New BlockSet epoch 3, # of blocks (including unused BB00): 32, bitset array size: 1 (short)
 ... unknown edge BB23 -> BB27
 ... unknown edge BB23 -> BB24
 ... unknown edge BB24 -> BB26
 ... unknown edge BB24 -> BB25
 ... unknown edge BB27 -> BB29
 ... unknown edge BB27 -> BB28
 ... unknown edge BB29 -> BB31
 ... unknown edge BB29 -> BB30

Solver: 9 blocks, 9 unknown; 13 edges, 8 unknown, 0 zero (and so ignored)

Pass [1]: 9 unknown blocks, 8 unknown edges
BB31: 1 incoming unknown, 0 outgoing unknown
BB31: all outgoing edge weights known, summming...
  BB31 -> BB23 has weight 2
BB31: all outgoing edge weights known, sum is 2
BB29 -> BB31: target block weight and all other incoming edge weights known, so weight is 2
BB30: 1 incoming unknown, 0 outgoing unknown
BB30: all outgoing edge weights known, summming...
  BB30 -> BB23 has weight 1857
BB30: all outgoing edge weights known, sum is 1857
BB29 -> BB30: target block weight and all other incoming edge weights known, so weight is 1857
BB29: 1 incoming unknown, 0 outgoing unknown
BB29: all outgoing edge weights known, summming...
  BB29 -> BB30 has weight 1857
  BB29 -> BB31 has weight 2
BB29: all outgoing edge weights known, sum is 1859
BB27 -> BB29: target block weight and all other incoming edge weights known, so weight is 1859
BB28: 1 incoming unknown, 0 outgoing unknown
BB28: all outgoing edge weights known, summming...
  BB28 -> BB23 has weight 15599
BB28: all outgoing edge weights known, sum is 15599
BB27 -> BB28: target block weight and all other incoming edge weights known, so weight is 15599
BB27: 1 incoming unknown, 0 outgoing unknown
BB27: all outgoing edge weights known, summming...
  BB27 -> BB28 has weight 15599
  BB27 -> BB29 has weight 1859
BB27: all outgoing edge weights known, sum is 17458
BB23 -> BB27: target block weight and all other incoming edge weights known, so weight is 17458
BB26: 1 incoming unknown, 0 outgoing unknown
BB26: all outgoing edge weights known, summming...
  BB26 -> BB23 has weight 25242
BB26: all outgoing edge weights known, sum is 25242
BB24 -> BB26: target block weight and all other incoming edge weights known, so weight is 25242
BB25: 1 incoming unknown, 0 outgoing unknown
BB25: all outgoing edge weights known, summming...
  BB25 -> BB23 has weight 73485
BB25: all outgoing edge weights known, sum is 73485
BB24 -> BB25: target block weight and all other incoming edge weights known, so weight is 73485
BB24: 1 incoming unknown, 0 outgoing unknown
BB24: all outgoing edge weights known, summming...
  BB24 -> BB25 has weight 73485
  BB24 -> BB26 has weight 25242
BB24: all outgoing edge weights known, sum is 98727
BB23 -> BB24: target block weight and all other incoming edge weights known, so weight is 98727
BB23: 0 incoming unknown, 0 outgoing unknown
BB23: all incoming edge weights known, summming...
  BB31 -> BB23 has weight 2
  BB30 -> BB23 has weight 1857
  BB28 -> BB23 has weight 15599
  BB26 -> BB23 has weight 25242
  BB25 -> BB23 has weight 73485
BB23: all incoming edge weights known, sum is 116185

Solver: converged in 1 passes
Computing inlinee profile scale:
   call site count 85 callee entry count 116185 scale 0.0007315919
Scaling inlinee blocks

*************** Inline @[000006] Finishing PHASE Profile incorporation
Trees after Profile incorporation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB23 [0022]  1                            85     85    [000..003)-> BB27 ( cond )                     IBC 
BB24 [0023]  1                            72.23  72    [003..006)-> BB26 ( cond )                     IBC 
BB25 [0024]  1                            53.76  54    [006..008)        (return)                     IBC 
BB26 [0025]  1                            18.47  18    [008..00A)        (return)                     IBC 
BB27 [0026]  1                            12.77  13    [00A..00E)-> BB29 ( cond )                     IBC 
BB28 [0027]  1                            11.41  11    [00E..010)        (return)                     IBC 
BB29 [0028]  1                             1.36   1    [010..013)-> BB31 ( cond )                     IBC 
BB30 [0029]  1                             1.36   1    [013..01B)        (return)                     IBC 
BB31 [0030]  1                             0.00   0    [01B..01D)        (return)                     IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB23 [000..003) -> BB27 (cond), preds={} succs={BB24,BB27}

------------ BB24 [003..006) -> BB26 (cond), preds={} succs={BB25,BB26}

------------ BB25 [006..008) (return), preds={} succs={}

------------ BB26 [008..00A) (return), preds={} succs={}

------------ BB27 [00A..00E) -> BB29 (cond), preds={} succs={BB28,BB29}

------------ BB28 [00E..010) (return), preds={} succs={}

------------ BB29 [010..013) -> BB31 (cond), preds={} succs={BB30,BB31}

------------ BB30 [013..01B) (return), preds={} succs={}

------------ BB31 [01B..01D) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000006] Starting PHASE Importation
*************** In impImport() for System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool

impImportBlockPending for BB23

Importing BB23 (PC=000) of 'System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool'
    [ 0]   0 (0x000) ldarg.1
    [ 1]   1 (0x001) brtrue.s
Folding operator with constant nodes into a constant:
               [000075] -----------                         *  NE        int   
               [000073] -----------                         +--*  CNS_INT   ref    null
               [000074] -----------                         \--*  CNS_INT   ref    null
Bashed to int constant:
               [000075] -----------                         *  CNS_INT   int    0

The block falls through into the next BB24

impImportBlockPending for BB24

Importing BB24 (PC=003) of 'System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool'
    [ 0]   3 (0x003) ldarg.0
    [ 1]   4 (0x004) brfalse.s

STMT00020 ( 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000078] -----------                         *  JTRUE     void  
               [000077] -----------                         \--*  EQ        int   
               [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         
               [000076] -----------                            \--*  CNS_INT   ref    null

impImportBlockPending for BB25

impImportBlockPending for BB26

Importing BB26 (PC=008) of 'System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool'
    [ 0]   8 (0x008) ldc.i4.1 1
    [ 1]   9 (0x009) ret

    Inlinee Return expression (before normalization)  =>
               [000079] -----------                         *  CNS_INT   int    1


STMT00021 ( 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000082] -A---------                         *  ASG       bool  
               [000081] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000080] -----------                         \--*  CAST      int <- bool <- int
               [000079] -----------                            \--*  CNS_INT   int    1


    Inlinee Return expression (after normalization) =>
               [000083] -----------                         *  LCL_VAR   bool   V09 tmp6         

Importing BB25 (PC=006) of 'System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool'
    [ 0]   6 (0x006) ldc.i4.0 0
    [ 1]   7 (0x007) ret

    Inlinee Return expression (before normalization)  =>
               [000084] -----------                         *  CNS_INT   int    0


STMT00022 ( 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000087] -A---------                         *  ASG       bool  
               [000086] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000085] -----------                         \--*  CAST      int <- bool <- int
               [000084] -----------                            \--*  CNS_INT   int    0


    Inlinee Return expression (after normalization) =>
               [000088] -----------                         *  LCL_VAR   bool   V09 tmp6         

After impImport() added block for try,catch,finally
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB23 [0022]  1                            85     85    [000..003)                                     i IBC 
BB24 [0023]  1                            72.23  72    [003..006)-> BB26 ( cond )                     i IBC 
BB25 [0024]  1                            53.76  54    [006..008)        (return)                     i IBC 
BB26 [0025]  1                            18.47  18    [008..00A)        (return)                     i IBC 
BB27 [0026]  1                            12.77  13    [00A..00E)-> BB29 ( cond )                     IBC 
BB28 [0027]  1                            11.41  11    [00E..010)        (return)                     IBC 
BB29 [0028]  1                             1.36   1    [010..013)-> BB31 ( cond )                     IBC 
BB30 [0029]  1                             1.36   1    [013..01B)        (return)                     IBC 
BB31 [0030]  1                             0.00   0    [01B..01D)        (return)                     IBC 
-----------------------------------------------------------------------------------------------------------------------------------------


** Note: inlinee IL was partially imported -- imported 7 of 29 bytes of method IL

*************** Inline @[000006] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB23 [0022]  1                            85     85    [000..003)                                     i IBC 
BB24 [0023]  1                            72.23  72    [003..006)-> BB26 ( cond )                     i IBC 
BB25 [0024]  1                            53.76  54    [006..008)        (return)                     i IBC 
BB26 [0025]  1                            18.47  18    [008..00A)        (return)                     i IBC 
BB27 [0026]  1                            12.77  13    [00A..00E)-> BB29 ( cond )                     IBC 
BB28 [0027]  1                            11.41  11    [00E..010)        (return)                     IBC 
BB29 [0028]  1                             1.36   1    [010..013)-> BB31 ( cond )                     IBC 
BB30 [0029]  1                             1.36   1    [013..01B)        (return)                     IBC 
BB31 [0030]  1                             0.00   0    [01B..01D)        (return)                     IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB23 [000..003), preds={} succs={BB24}

------------ BB24 [003..006) -> BB26 (cond), preds={} succs={BB25,BB26}

***** BB24
STMT00020 ( 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000078] -----------                         *  JTRUE     void  
               [000077] -----------                         \--*  EQ        int   
               [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         
               [000076] -----------                            \--*  CNS_INT   ref    null

------------ BB25 [006..008) (return), preds={} succs={}

***** BB25
STMT00022 ( 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000087] -A---------                         *  ASG       bool  
               [000086] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000085] -----------                         \--*  CAST      int <- bool <- int
               [000084] -----------                            \--*  CNS_INT   int    0

------------ BB26 [008..00A) (return), preds={} succs={}

***** BB26
STMT00021 ( 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000082] -A---------                         *  ASG       bool  
               [000081] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000080] -----------                         \--*  CAST      int <- bool <- int
               [000079] -----------                            \--*  CNS_INT   int    1

------------ BB27 [00A..00E) -> BB29 (cond), preds={} succs={BB28,BB29}

------------ BB28 [00E..010) (return), preds={} succs={}

------------ BB29 [010..013) -> BB31 (cond), preds={} succs={BB30,BB31}

------------ BB30 [013..01B) (return), preds={} succs={}

------------ BB31 [01B..01D) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000006] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000006] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000006] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000006] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000006] Starting PHASE Post-import

*************** In fgPostImportationCleanup
BB27 was not imported, marking as removed (0)
BB28 was not imported, marking as removed (1)
BB29 was not imported, marking as removed (2)
BB30 was not imported, marking as removed (3)
BB31 was not imported, marking as removed (4)

Renumbering the basic blocks for fgPostImporterCleanup

*************** Before renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB23 [0022]  1                            85     85    [000..003)                                     i IBC 
BB24 [0023]  1                            72.23  72    [003..006)-> BB26 ( cond )                     i IBC 
BB25 [0024]  1                            53.76  54    [006..008)        (return)                     i IBC 
BB26 [0025]  1                            18.47  18    [008..00A)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB20 [000..041), Finally at BB09..BB09 [041..048)
Renumber BB23 to BB32
Renumber BB24 to BB33
Renumber BB25 to BB34
Renumber BB26 to BB35

*************** After renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB32 [0022]  1                            85     85    [000..003)                                     i IBC 
BB33 [0023]  1                            72.23  72    [003..006)-> BB35 ( cond )                     i IBC 
BB34 [0024]  1                            53.76  54    [006..008)        (return)                     i IBC 
BB35 [0025]  1                            18.47  18    [008..00A)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB20 [000..041), Finally at BB09..BB09 [041..048)

New BlockSet epoch 1, # of blocks (including unused BB00): 10, bitset array size: 1 (short)

*************** Inline @[000006] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000006] -----------

Arguments setup:

Inlinee method body:New Basic Block BB36 [0031] created.

Convert bbJumpKind of BB34 to BBJ_ALWAYS to bottomBlock BB36

Convert bbJumpKind of BB35 to BBJ_NONE
fgInlineAppendStatements: no gc ref inline locals.

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB32 [0022]  1  1                         85     85    [007..008)                 T1                  i IBC 
BB33 [0023]  1  1                         72.23  72    [007..008)-> BB35 ( cond ) T1                  i IBC 
BB34 [0024]  1  1                         53.76  54    [007..008)-> BB36 (always) T1                  i IBC 
BB35 [0025]  1  1                         18.47  18    [007..008)                 T1                  i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB32 [007..008), preds={} succs={BB33}

------------ BB33 [007..008) -> BB35 (cond), preds={} succs={BB34,BB35}

***** BB33
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000078] -----------                         *  JTRUE     void  
               [000077] -----------                         \--*  EQ        int   
               [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         
               [000076] -----------                            \--*  CNS_INT   ref    null

------------ BB34 [007..008) -> BB36 (always), preds={} succs={BB36}

***** BB34
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000087] -A---------                         *  ASG       bool  
               [000086] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000085] -----------                         \--*  CAST      int <- bool <- int
               [000084] -----------                            \--*  CNS_INT   int    0

------------ BB35 [007..008), preds={} succs={BB36}

***** BB35
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000082] -A---------                         *  ASG       bool  
               [000081] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000080] -----------                         \--*  CAST      int <- bool <- int
               [000079] -----------                            \--*  CNS_INT   int    1

-------------------------------------------------------------------------------------------------------------------

Return expression for call at [000006] is
               [000088] -----------                         *  LCL_VAR   bool   V09 tmp6         
Successfully inlined System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool (29 IL bytes) (depth 1) [aggressive inline attribute]
--------------------------------------------------------------------------------------------
INLINER: during 'fgInline' result 'success' reason 'aggressive inline attribute' for 'System.Reflection.Emit.DynamicResolver:Finalize():this' calling 'System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool'
INLINER: during 'fgInline' result 'success' reason 'aggressive inline attribute'

Replacing the return expression placeholder [000007] with [000088]
               [000007] --C--------                         *  RET_EXPR  int   (inl return expr [000088])

Inserting the inline return expression
               [000088] -----------                         *  LCL_VAR   bool   V09 tmp6         

Expanding INLINE_CANDIDATE in statement STMT00005 in BB06:
STMT00005 ( ??? ... ??? )
               [000025] I-C-G------                         *  CALL r2r_ind void   DestroyScout..ctor (exactContextHnd=0x40000000004267F9)
               [000024] ----------- this                    \--*  LCL_VAR   ref    V04 tmp1         
thisArg: is a local var
               [000024] -----------                         *  LCL_VAR   ref    V04 tmp1         

INLINER: inlineInfo.tokenLookupContextHandle for DestroyScout:.ctor():this set to 0x40000000004267F9:

Invoking compiler for the inlinee method DestroyScout:.ctor():this :
IL to import:
IL_0000  02                ldarg.0     
IL_0001  28 fe 05 00 06    call         0x60005FE
IL_0006  2a                ret         

INLINER impTokenLookupContextHandle for DestroyScout:.ctor():this is 0x40000000004267F9.
*************** In compInitDebuggingInfo() for DestroyScout:.ctor():this
info.compStmtOffsetsCount    = 0
info.compStmtOffsetsImplicit = 0007h ( STACK_EMPTY NOP CALL_SITE )
*************** In fgFindBasicBlocks() for DestroyScout:.ctor():this
Jump targets:
  none
New Basic Block BB37 [0032] created.
BB37 [000..007)
Basic block list for 'DestroyScout:.ctor():this'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB37 [0032]  1                             1       [000..007)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000025] Starting PHASE Pre-import

*************** Inline @[000025] Finishing PHASE Pre-import

*************** Inline @[000025] Starting PHASE Profile incorporation
BBOPT set, but no profile data available (hr=80004001)
Computing inlinee profile scale:
   ... no callee profile data, will use non-pgo weight to scale
   call site count 85 callee entry count 100 scale 0.85
Scaling inlinee blocks

*************** Inline @[000025] Finishing PHASE Profile incorporation
Trees after Profile incorporation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB37 [0032]  1                             1       [000..007)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB37 [000..007) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000025] Starting PHASE Importation
*************** In impImport() for DestroyScout:.ctor():this

impImportBlockPending for BB37

Importing BB37 (PC=000) of 'DestroyScout:.ctor():this'
    [ 0]   0 (0x000) ldarg.0
    [ 1]   1 (0x001) call 060005FE
In Compiler::impImportCall: opcode is call, kind=0, callRetType is void, structSize is 0


STMT00023 ( 0x000[E-] ... ??? ) <- INLRT @ ???
               [000090] I-C-G------                         *  CALL r2r_ind void   System.Object..ctor (exactContextHnd=0x4000000000420039)
               [000024] ----------- this                    \--*  LCL_VAR   ref    V04 tmp1         

    [ 0]   6 (0x006) ret
After impImport() added block for try,catch,finally
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB37 [0032]  1                             1       [000..007)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------


*************** Inline @[000025] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB37 [0032]  1                             1       [000..007)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB37 [000..007) (return), preds={} succs={}

***** BB37
STMT00023 ( 0x000[E-] ... ??? ) <- INLRT @ ???
               [000090] I-C-G------                         *  CALL r2r_ind void   System.Object..ctor (exactContextHnd=0x4000000000420039)
               [000024] ----------- this                    \--*  LCL_VAR   ref    V04 tmp1         

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000025] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000025] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000025] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000025] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000025] Starting PHASE Post-import

*************** In fgPostImportationCleanup

*************** Inline @[000025] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000025] -----------

Arguments setup:

Inlinee method body:
STMT00023 ( INL02 @ 0x000[E-] ... ??? ) <- INLRT @ ???
               [000090] I-C-G------                         *  CALL r2r_ind void   System.Object..ctor (exactContextHnd=0x4000000000420039)
               [000024] ----------- this                    \--*  LCL_VAR   ref    V04 tmp1         

fgInlineAppendStatements: no gc ref inline locals.
Successfully inlined DestroyScout:.ctor():this (7 IL bytes) (depth 1) [below ALWAYS_INLINE size]
--------------------------------------------------------------------------------------------
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size' for 'System.Reflection.Emit.DynamicResolver:Finalize():this' calling 'DestroyScout:.ctor():this'
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size'
Expanding INLINE_CANDIDATE in statement STMT00023 in BB06:
STMT00023 ( INL02 @ 0x000[E-] ... ??? ) <- INLRT @ ???
               [000090] I-C-G------                         *  CALL r2r_ind void   System.Object..ctor (exactContextHnd=0x4000000000420039)
               [000024] ----------- this                    \--*  LCL_VAR   ref    V04 tmp1         
thisArg: is a local var
               [000024] -----------                         *  LCL_VAR   ref    V04 tmp1         

INLINER: inlineInfo.tokenLookupContextHandle for System.Object:.ctor():this set to 0x4000000000420039:

Invoking compiler for the inlinee method System.Object:.ctor():this :
IL to import:
IL_0000  2a                ret         

INLINER impTokenLookupContextHandle for System.Object:.ctor():this is 0x4000000000420039.
*************** In compInitDebuggingInfo() for System.Object:.ctor():this
info.compStmtOffsetsCount    = 0
info.compStmtOffsetsImplicit = 0007h ( STACK_EMPTY NOP CALL_SITE )
*************** In fgFindBasicBlocks() for System.Object:.ctor():this
Jump targets:
  none
New Basic Block BB38 [0033] created.
BB38 [000..001)
Basic block list for 'System.Object:.ctor():this'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB38 [0033]  1                             1       [000..001)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000090] Starting PHASE Pre-import

*************** Inline @[000090] Finishing PHASE Pre-import

*************** Inline @[000090] Starting PHASE Profile incorporation
BBOPT set, but no profile data available (hr=80004001)
Computing inlinee profile scale:
   ... no callee profile data, will use non-pgo weight to scale
   call site count 85 callee entry count 100 scale 0.85
Scaling inlinee blocks

*************** Inline @[000090] Finishing PHASE Profile incorporation
Trees after Profile incorporation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB38 [0033]  1                             1       [000..001)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB38 [000..001) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000090] Starting PHASE Importation
*************** In impImport() for System.Object:.ctor():this

impImportBlockPending for BB38

Importing BB38 (PC=000) of 'System.Object:.ctor():this'
    [ 0]   0 (0x000) ret
After impImport() added block for try,catch,finally
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB38 [0033]  1                             1       [000..001)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------


** Note: inlinee IL was partially imported -- imported 0 of 1 bytes of method IL

*************** Inline @[000090] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB38 [0033]  1                             1       [000..001)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB38 [000..001) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000090] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000090] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000090] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000090] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000090] Starting PHASE Post-import

*************** In fgPostImportationCleanup

*************** Inline @[000090] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000090] -----------

Arguments setup:

Inlinee method body:fgInlineAppendStatements: no gc ref inline locals.
Successfully inlined System.Object:.ctor():this (1 IL bytes) (depth 2) [below ALWAYS_INLINE size]
--------------------------------------------------------------------------------------------
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size' for 'System.Reflection.Emit.DynamicResolver:Finalize():this' calling 'System.Object:.ctor():this'
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size'
Expanding INLINE_CANDIDATE in statement STMT00017 in BB21:
STMT00017 ( 0x02E[E-] ... ??? )
               [000062] I-CXG------                         *  CALL r2r_ind struct System.RuntimeMethodInfoStub.System.IRuntimeMethodInfo.get_Value (exactContextHnd=0x4000000000425878)
               [000064] ----------- this                    \--*  LCL_VAR   ref    V08 tmp5         
thisArg: is a local var
               [000064] -----------                         *  LCL_VAR   ref    V08 tmp5         

INLINER: inlineInfo.tokenLookupContextHandle for System.RuntimeMethodInfoStub:System.IRuntimeMethodInfo.get_Value():System.RuntimeMethodHandleInternal:this set to 0x4000000000425878:

Invoking compiler for the inlinee method System.RuntimeMethodInfoStub:System.IRuntimeMethodInfo.get_Value():System.RuntimeMethodHandleInternal:this :
IL to import:
IL_0000  02                ldarg.0     
IL_0001  7b 89 02 00 04    ldfld        0x4000289
IL_0006  2a                ret         

INLINER impTokenLookupContextHandle for System.RuntimeMethodInfoStub:System.IRuntimeMethodInfo.get_Value():System.RuntimeMethodHandleInternal:this is 0x4000000000425878.
*************** In compInitDebuggingInfo() for System.RuntimeMethodInfoStub:System.IRuntimeMethodInfo.get_Value():System.RuntimeMethodHandleInternal:this
info.compStmtOffsetsCount    = 0
info.compStmtOffsetsImplicit = 0007h ( STACK_EMPTY NOP CALL_SITE )
*************** In fgFindBasicBlocks() for System.RuntimeMethodInfoStub:System.IRuntimeMethodInfo.get_Value():System.RuntimeMethodHandleInternal:this
Jump targets:
  none
New Basic Block BB39 [0034] created.
BB39 [000..007)
Basic block list for 'System.RuntimeMethodInfoStub:System.IRuntimeMethodInfo.get_Value():System.RuntimeMethodHandleInternal:this'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB39 [0034]  1                             1       [000..007)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000062] Starting PHASE Pre-import

*************** Inline @[000062] Finishing PHASE Pre-import

*************** Inline @[000062] Starting PHASE Profile incorporation
BBOPT set, but no profile data available (hr=80004001)
Computing inlinee profile scale:
   ... no callee profile data, will use non-pgo weight to scale
   call site count 85 callee entry count 100 scale 0.85
Scaling inlinee blocks

*************** Inline @[000062] Finishing PHASE Profile incorporation
Trees after Profile incorporation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB39 [0034]  1                             1       [000..007)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB39 [000..007) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000062] Starting PHASE Importation
*************** In impImport() for System.RuntimeMethodInfoStub:System.IRuntimeMethodInfo.get_Value():System.RuntimeMethodHandleInternal:this

impImportBlockPending for BB39

Importing BB39 (PC=000) of 'System.RuntimeMethodInfoStub:System.IRuntimeMethodInfo.get_Value():System.RuntimeMethodHandleInternal:this'
    [ 0]   0 (0x000) ldarg.0
    [ 1]   1 (0x001) ldfld 04000289
    [ 1]   6 (0x006) ret

    Inlinee Return expression (before normalization)  =>
               [000093] ---XG------                         *  FIELD     struct m_value
               [000064] -----------                         \--*  LCL_VAR   ref    V08 tmp5         

impFixupStructReturnType: retyping
               [000093] ---XG------                         *  FIELD     struct m_value
               [000064] -----------                         \--*  LCL_VAR   ref    V08 tmp5         


    Inlinee Return expression (after normalization) =>
               [000093] ---XG------                         *  FIELD     struct m_value
               [000064] -----------                         \--*  LCL_VAR   ref    V08 tmp5         

After impImport() added block for try,catch,finally
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB39 [0034]  1                             1       [000..007)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------


** Note: inlinee IL was partially imported -- imported 0 of 7 bytes of method IL

*************** Inline @[000062] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB39 [0034]  1                             1       [000..007)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB39 [000..007) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000062] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000062] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000062] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000062] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000062] Starting PHASE Post-import

*************** In fgPostImportationCleanup

*************** Inline @[000062] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000062] -----------

Arguments setup:

Inlinee method body:fgInlineAppendStatements: no gc ref inline locals.

Return expression for call at [000062] is
               [000093] ---XG------                         *  FIELD     struct m_value
               [000064] -----------                         \--*  LCL_VAR   ref    V08 tmp5         
Successfully inlined System.RuntimeMethodInfoStub:System.IRuntimeMethodInfo.get_Value():System.RuntimeMethodHandleInternal:this (7 IL bytes) (depth 1) [below ALWAYS_INLINE size]
--------------------------------------------------------------------------------------------
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size' for 'System.Reflection.Emit.DynamicResolver:Finalize():this' calling 'System.RuntimeMethodInfoStub:System.IRuntimeMethodInfo.get_Value():System.RuntimeMethodHandleInternal:this'
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size'

Replacing the return expression placeholder [000065] with [000093]
               [000065] --C----N---                         *  RET_EXPR  struct(inl return expr [000093])

Inserting the inline return expression
               [000093] ---XG------                         *  FIELD     struct m_value
               [000064] -----------                         \--*  LCL_VAR   ref    V08 tmp5         

**** Late devirt opportunity
               [000032] --CXG--N---                         *  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] ----------- this                    \--*  LCL_VAR   ref    V07 tmp4         

impDevirtualizeCall: no type available (op=LCL_VAR)
No guarded devirt during late devirtualization
Expanding INLINE_CANDIDATE in statement STMT00012 in BB09:
STMT00012 ( 0x041[E-] ... 0x047 )
               [000045] I-C-G------                         *  CALL r2r_ind void   System.Object.Finalize (exactContextHnd=0x4000000000420039)
               [000044] ----------- this                    \--*  LCL_VAR   ref    V00 this         
thisArg: is a local var
               [000044] -----------                         *  LCL_VAR   ref    V00 this         

INLINER: inlineInfo.tokenLookupContextHandle for System.Object:Finalize():this set to 0x4000000000420039:

Invoking compiler for the inlinee method System.Object:Finalize():this :
IL to import:
IL_0000  2a                ret         

INLINER impTokenLookupContextHandle for System.Object:Finalize():this is 0x4000000000420039.
*************** In compInitDebuggingInfo() for System.Object:Finalize():this
info.compStmtOffsetsCount    = 0
info.compStmtOffsetsImplicit = 0007h ( STACK_EMPTY NOP CALL_SITE )
*************** In fgFindBasicBlocks() for System.Object:Finalize():this
Jump targets:
  none
New Basic Block BB40 [0035] created.
BB40 [000..001)
Basic block list for 'System.Object:Finalize():this'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB40 [0035]  1                             1       [000..001)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Inline @[000045] Starting PHASE Pre-import

*************** Inline @[000045] Finishing PHASE Pre-import

*************** Inline @[000045] Starting PHASE Profile incorporation
BBOPT set, but no profile data available (hr=80004001)
Computing inlinee profile scale:
   ... no callee profile data, will use non-pgo weight to scale
   call site count 85 callee entry count 100 scale 0.85
Scaling inlinee blocks

*************** Inline @[000045] Finishing PHASE Profile incorporation
Trees after Profile incorporation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB40 [0035]  1                             1       [000..001)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB40 [000..001) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000045] Starting PHASE Importation
*************** In impImport() for System.Object:Finalize():this

impImportBlockPending for BB40

Importing BB40 (PC=000) of 'System.Object:Finalize():this'
    [ 0]   0 (0x000) ret
After impImport() added block for try,catch,finally
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB40 [0035]  1                             1       [000..001)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------


** Note: inlinee IL was partially imported -- imported 0 of 1 bytes of method IL

*************** Inline @[000045] Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB40 [0035]  1                             1       [000..001)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB40 [000..001) (return), preds={} succs={}

-------------------------------------------------------------------------------------------------------------------

*************** Inline @[000045] Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Inline @[000045] Finishing PHASE Expand patchpoints [no changes]

*************** Inline @[000045] Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Inline @[000045] Finishing PHASE Indirect call transform [no changes]

*************** Inline @[000045] Starting PHASE Post-import

*************** In fgPostImportationCleanup

*************** Inline @[000045] Finishing PHASE Post-import


----------- Statements (and blocks) added due to the inlining of call [000045] -----------

Arguments setup:

Inlinee method body:fgInlineAppendStatements: no gc ref inline locals.
Successfully inlined System.Object:Finalize():this (1 IL bytes) (depth 1) [below ALWAYS_INLINE size]
--------------------------------------------------------------------------------------------
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size' for 'System.Reflection.Emit.DynamicResolver:Finalize():this' calling 'System.Object:Finalize():this'
INLINER: during 'fgInline' result 'success' reason 'below ALWAYS_INLINE size'
**************** Inline Tree

Inlines into 06006115 [via ExtendedDefaultPolicy] System.Reflection.Emit.DynamicResolver:Finalize():this:
  [INL01 IL=0009 TR=000006 06005E6D] [INLINED: callee: aggressive inline attribute] System.Reflection.MethodInfo:op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo):bool
  [INL02 IL=0029 TR=000025 06006121] [INLINED: callee: below ALWAYS_INLINE size] DestroyScout:.ctor():this
    [INL03 IL=0001 TR=000090 060005FE] [INLINED: callee: below ALWAYS_INLINE size] System.Object:.ctor():this
  [INL00 IL=0039 TR=000043 06000514] [FAILED: call site: within catch region] System.GC:ReRegisterForFinalize(System.Object)
  [INL04 IL=0053 TR=000062 06000681] [INLINED: callee: below ALWAYS_INLINE size GUARDED DEVIRT] System.RuntimeMethodInfoStub:System.IRuntimeMethodInfo.get_Value():System.RuntimeMethodHandleInternal:this
  [INL00 IL=0053 TR=000032 06000682] [FAILED: call site: not inline candidate GUARDED] System.IRuntimeMethodInfo:get_Value():System.RuntimeMethodHandleInternal:this
  [INL05 IL=0066 TR=000045 060005FF] [INLINED: callee: below ALWAYS_INLINE size] System.Object:Finalize():this
Budget: initialTime=279, finalTime=237, initialBudget=2790, currentBudget=2790
Budget: initialSize=1795, finalSize=1795

*************** Finishing PHASE Morph - Inlining
Trees after Morph - Inlining

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)                 T1      try {       keep i try IBC 
BB32 [0022]  1  1                         85     85    [007..008)                 T1                  i IBC 
BB33 [0023]  1  1                         72.23  72    [007..008)-> BB35 ( cond ) T1                  i IBC 
BB34 [0024]  1  1                         53.76  54    [007..008)-> BB36 (always) T1                  i IBC 
BB35 [0025]  1  1                         18.47  18    [007..008)                 T1                  i IBC 
BB36 [0031]  1  1                         85     85    [???..???)-> BB03 ( cond ) T1                  keep internal IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB18 (always) T1                  i rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB16 (always) T1                  i rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB13 ( cret ) T1 H0   catch { }   keep i 
BB13 [0012]  1  1                          1           [???..???)-> BB14 (always) T1                  i internal 
BB08 [0007]  1  1                         85     85    [02E..02E)-> BB22 ( cond ) T1                  i IBC 
BB21 [0020]  0  1                         85     85    [???..???)-> BB20 (always) T1                  i internal IBC 
BB22 [0021]  0  1                          0      0    [???..???)                 T1                  i internal rare IBC 
BB20 [0019]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i internal IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB19 [0018]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB16 [0015]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB17 [0016]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB14 [0013]  1                             1           [???..???)-> BB09 (callf )                     i internal 
BB15 [0014]  0                             1           [???..???)-> BB10 (ALWAYS)                     i internal KEEP 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep i IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010), preds={} succs={BB32}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
               [000003] -A-XG------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         
               [000001] ---XG------                         \--*  FIELD     ref    m_method
               [000000] -----------                            \--*  LCL_VAR   ref    V00 this         

------------ BB32 [007..008), preds={} succs={BB33}

------------ BB33 [007..008) -> BB35 (cond), preds={} succs={BB34,BB35}

***** BB33
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000078] -----------                         *  JTRUE     void  
               [000077] -----------                         \--*  EQ        int   
               [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         
               [000076] -----------                            \--*  CNS_INT   ref    null

------------ BB34 [007..008) -> BB36 (always), preds={} succs={BB36}

***** BB34
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000087] -A---------                         *  ASG       bool  
               [000086] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000085] -----------                         \--*  CAST      int <- bool <- int
               [000084] -----------                            \--*  CNS_INT   int    0

------------ BB35 [007..008), preds={} succs={BB36}

***** BB35
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000082] -A---------                         *  ASG       bool  
               [000081] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000080] -----------                         \--*  CAST      int <- bool <- int
               [000079] -----------                            \--*  CNS_INT   int    1

------------ BB36 [???..???) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB36
STMT00002 ( 0x007[E-] ... ??? )
               [000011] --C--------                         *  JTRUE     void  
               [000010] --C--------                         \--*  EQ        int   
               [000008] --C--------                            +--*  CAST      int <- bool <- int
               [000088] -----------                            |  \--*  LCL_VAR   bool   V09 tmp6         
               [000009] -----------                            \--*  CNS_INT   int    0

------------ BB02 [010..012) -> BB18 (always), preds={} succs={BB18}

------------ BB03 [012..01A) -> BB05 (cond), preds={} succs={BB04,BB05}

***** BB03
STMT00003 ( 0x012[E-] ... 0x018 )
               [000016] ---XG------                         *  JTRUE     void  
               [000015] ---XG------                         \--*  NE        int   
               [000013] ---XG------                            +--*  FIELD     ref    m_methodHandle
               [000012] -----------                            |  \--*  LCL_VAR   ref    V01 loc0         
               [000014] -----------                            \--*  CNS_INT   ref    null

------------ BB04 [01A..01C) -> BB16 (always), preds={} succs={BB16}

------------ BB05 [01C..01D), preds={} succs={BB06}

------------ BB06 [01D..025) -> BB08 (always), preds={} succs={BB08}

***** BB06
STMT00004 ( 0x01D[E-] ... 0x022 )
               [000023] -A---------                         *  ASG       ref   
               [000022] D------N---                         +--*  LCL_VAR   ref    V04 tmp1         
               [000021] -----------                         \--*  ALLOCOBJ  ref   
               [000020] #----------                            \--*  IND       long  
               [000019] H----------                               \--*  CNS_INT(h) long   0x4000000000426c70 method

***** BB06
STMT00006 ( 0x022[--] ... ??? )
               [000028] -A---------                         *  ASG       ref   
               [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         
               [000026] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

------------ BB07 [025..02E) -> BB13 (cret), preds={} succs={BB13}

***** BB07
STMT00010 ( 0x025[--] ... 0x02C )
               [000040] -A---O-----                         *  ASG       ref   
               [000039] D------N---                         +--*  LCL_VAR   ref    V05 tmp2         
               [000018] -----O-----                         \--*  CATCH_ARG ref   

***** BB07
STMT00011 ( 0x026[E-] ... ??? )
               [000043] --C-G------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
               [000042] ----------- arg0                    \--*  LCL_VAR   ref    V00 this         

------------ BB13 [???..???) -> BB14 (always), preds={} succs={BB14}

------------ BB08 [02E..02E) -> BB22 (cond), preds={} succs={BB21,BB22}

***** BB08
STMT00014 ( 0x02E[E-] ... ??? )
               [000051] -A-XG------                         *  ASG       ref   
               [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         
               [000048] ---XG------                         \--*  FIELD     ref    m_methodHandle
               [000049] -----------                            \--*  LCL_VAR   ref    V01 loc0         

***** BB08
STMT00015 ( 0x02E[E-] ... ??? )
               [000058] ---X-------                         *  JTRUE     void  
               [000057] ---X-------                         \--*  NE        int   
               [000056] #----------                            +--*  IND       long  
               [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
               [000054] #--X-------                            \--*  IND       long  
               [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         

------------ BB21 [???..???) -> BB20 (always), preds={} succs={BB20}

***** BB21
STMT00016 ( ??? ... ??? )
               [000061] -A---------                         *  ASG       ref   
               [000060] D------N---                         +--*  LCL_VAR   ref    V08 tmp5         
               [000059] -----------                         \--*  LCL_VAR   ref    V07 tmp4         

***** BB21
STMT00018 ( ??? ... ??? )
               [000068] -AC--------                         *  ASG       struct (copy)
               [000066] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8> V06 tmp3         
               [000093] ---XG------                         \--*  FIELD     struct m_value
               [000064] -----------                            \--*  LCL_VAR   ref    V08 tmp5         

------------ BB22 [???..???), preds={} succs={BB20}

***** BB22
STMT00019 ( 0x02E[E-] ... ??? )
               [000071] -ACXG------                         *  ASG       struct (copy)
               [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8> V06 tmp3         
               [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] ----------- this                       \--*  LCL_VAR   ref    V07 tmp4         

------------ BB20 [02E..041) -> BB11 (always), preds={} succs={BB11}

***** BB20
STMT00008 ( 0x02E[E-] ... ??? )
               [000037] -ACXG------                         *  ASG       struct (copy)
               [000036] ---XG------                         +--*  BLK       struct<System.RuntimeMethodHandleInternal, 8>
               [000035] ---XG------                         |  \--*  ADDR      byref 
               [000034] ---XG--N---                         |     \--*  FIELD     struct m_methodHandle
               [000029] -----------                         |        \--*  LCL_VAR   ref    V02 loc1         
               [000047] -----------                         \--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8> V06 tmp3         

------------ BB18 [???..???) -> BB09 (callf), preds={} succs={BB09}

------------ BB19 [???..???) -> BB10 (ALWAYS), preds={} succs={BB10}

------------ BB16 [???..???) -> BB09 (callf), preds={} succs={BB09}

------------ BB17 [???..???) -> BB10 (ALWAYS), preds={} succs={BB10}

------------ BB14 [???..???) -> BB09 (callf), preds={} succs={BB09}

------------ BB15 [???..???) -> BB10 (ALWAYS), preds={} succs={BB10}

------------ BB11 [???..???) -> BB09 (callf), preds={} succs={BB09}

------------ BB12 [???..???) -> BB10 (ALWAYS), preds={} succs={BB10}

------------ BB09 [041..048) (finret), preds={} succs={BB19,BB17,BB15,BB12}

***** BB09
STMT00013 ( 0x047[E-] ... ??? )
               [000046] -----------                         *  RETFILT   void  

------------ BB10 [048..049) (return), preds={} succs={}

***** BB10
STMT00009 ( 0x048[E-] ... 0x048 )
               [000038] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Allocate Objects
disabled, punting

*************** Finishing PHASE Allocate Objects [no changes]

*************** Starting PHASE Morph - Add internal blocks

*************** After fgAddInternal()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)                 T1      try {       keep i try IBC 
BB32 [0022]  1  1                         85     85    [007..008)                 T1                  i IBC 
BB33 [0023]  1  1                         72.23  72    [007..008)-> BB35 ( cond ) T1                  i IBC 
BB34 [0024]  1  1                         53.76  54    [007..008)-> BB36 (always) T1                  i IBC 
BB35 [0025]  1  1                         18.47  18    [007..008)                 T1                  i IBC 
BB36 [0031]  1  1                         85     85    [???..???)-> BB03 ( cond ) T1                  keep internal IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB18 (always) T1                  i rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB16 (always) T1                  i rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB13 ( cret ) T1 H0   catch { }   keep i 
BB13 [0012]  1  1                          1           [???..???)-> BB14 (always) T1                  i internal 
BB08 [0007]  1  1                         85     85    [02E..02E)-> BB22 ( cond ) T1                  i IBC 
BB21 [0020]  0  1                         85     85    [???..???)-> BB20 (always) T1                  i internal IBC 
BB22 [0021]  0  1                          0      0    [???..???)                 T1                  i internal rare IBC 
BB20 [0019]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i internal IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB19 [0018]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB16 [0015]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB17 [0016]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB14 [0013]  1                             1           [???..???)-> BB09 (callf )                     i internal 
BB15 [0014]  0                             1           [???..???)-> BB10 (ALWAYS)                     i internal KEEP 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep i IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB20 [000..041), Finally at BB09..BB09 [041..048)

*************** Finishing PHASE Morph - Add internal blocks

*************** Starting PHASE Remove empty try

*************** In fgRemoveEmptyTry()

*************** Before fgRemoveEmptyTry()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)                 T1      try {       keep i try IBC 
BB32 [0022]  1  1                         85     85    [007..008)                 T1                  i IBC 
BB33 [0023]  1  1                         72.23  72    [007..008)-> BB35 ( cond ) T1                  i IBC 
BB34 [0024]  1  1                         53.76  54    [007..008)-> BB36 (always) T1                  i IBC 
BB35 [0025]  1  1                         18.47  18    [007..008)                 T1                  i IBC 
BB36 [0031]  1  1                         85     85    [???..???)-> BB03 ( cond ) T1                  keep internal IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB18 (always) T1                  i rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB16 (always) T1                  i rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB13 ( cret ) T1 H0   catch { }   keep i 
BB13 [0012]  1  1                          1           [???..???)-> BB14 (always) T1                  i internal 
BB08 [0007]  1  1                         85     85    [02E..02E)-> BB22 ( cond ) T1                  i IBC 
BB21 [0020]  0  1                         85     85    [???..???)-> BB20 (always) T1                  i internal IBC 
BB22 [0021]  0  1                          0      0    [???..???)                 T1                  i internal rare IBC 
BB20 [0019]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i internal IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB19 [0018]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB16 [0015]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB17 [0016]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB14 [0013]  1                             1           [???..???)-> BB09 (callf )                     i internal 
BB15 [0014]  0                             1           [???..???)-> BB10 (ALWAYS)                     i internal KEEP 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep i IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB20 [000..041), Finally at BB09..BB09 [041..048)

EH#0 is not a try-finally; skipping.
EH#1 first try block BB01 not empty; skipping.

*************** Finishing PHASE Remove empty try [no changes]

*************** Starting PHASE Remove empty finally

*************** Before fgRemoveEmptyFinally()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1  1                         85     85    [000..010)                 T1      try {       keep i try IBC 
BB32 [0022]  1  1                         85     85    [007..008)                 T1                  i IBC 
BB33 [0023]  1  1                         72.23  72    [007..008)-> BB35 ( cond ) T1                  i IBC 
BB34 [0024]  1  1                         53.76  54    [007..008)-> BB36 (always) T1                  i IBC 
BB35 [0025]  1  1                         18.47  18    [007..008)                 T1                  i IBC 
BB36 [0031]  1  1                         85     85    [???..???)-> BB03 ( cond ) T1                  keep internal IBC 
BB02 [0001]  1  1                          0      0    [010..012)-> BB18 (always) T1                  i rare IBC 
BB03 [0002]  1  1                         85     85    [012..01A)-> BB05 ( cond ) T1                  i IBC 
BB04 [0003]  1  1                          0      0    [01A..01C)-> BB16 (always) T1                  i rare IBC 
BB05 [0004]  1  1                         85     85    [01C..01D)                 T1                  i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1  1  0                       1           [025..02E)-> BB13 ( cret ) T1 H0   catch { }   keep i 
BB13 [0012]  1  1                          1           [???..???)-> BB14 (always) T1                  i internal 
BB08 [0007]  1  1                         85     85    [02E..02E)-> BB22 ( cond ) T1                  i IBC 
BB21 [0020]  0  1                         85     85    [???..???)-> BB20 (always) T1                  i internal IBC 
BB22 [0021]  0  1                          0      0    [???..???)                 T1                  i internal rare IBC 
BB20 [0019]  1  1                         85     85    [02E..041)-> BB11 (always) T1      }           i internal IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB19 [0018]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB16 [0015]  1                             0      0    [???..???)-> BB09 (callf )                     i internal rare IBC 
BB17 [0016]  0                             0      0    [???..???)-> BB10 (ALWAYS)                     i internal rare IBC KEEP 
BB14 [0013]  1                             1           [???..???)-> BB09 (callf )                     i internal 
BB15 [0014]  0                             1           [???..???)-> BB10 (ALWAYS)                     i internal KEEP 
BB11 [0010]  1                            85     85    [???..???)-> BB09 (callf )                     i internal IBC 
BB12 [0011]  0                            85     85    [???..???)-> BB10 (ALWAYS)                     i internal IBC KEEP 
BB09 [0008]  1     1                      85     85    [041..048)        (finret)    H1   finally { } keep i IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::   1        - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
  1  ::            - Try at BB01..BB20 [000..041), Finally at BB09..BB09 [041..048)

EH#0 is not a try-finally; skipping.
EH#1 has empty finally, removing the region.
Modifying callfinally BB18 leave BB19 finally BB09 continuation BB10
so that BB18 jumps to BB10; then remove BB19
fgRemoveBlock BB19, unreachable=true

Removing unreachable BB19
Modifying callfinally BB16 leave BB17 finally BB09 continuation BB10
so that BB16 jumps to BB10; then remove BB17
fgRemoveBlock BB17, unreachable=true

Removing unreachable BB17
Modifying callfinally BB14 leave BB15 finally BB09 continuation BB10
so that BB14 jumps to BB10; then remove BB15
fgRemoveBlock BB15, unreachable=true

Removing unreachable BB15
Modifying callfinally BB11 leave BB12 finally BB09 continuation BB10
so that BB11 jumps to BB10; then remove BB12
fgRemoveBlock BB12, unreachable=true

Removing unreachable BB12
Remove now-unreachable handler BB09
fgRemoveBlock BB09, unreachable=true

Removing unreachable BB09

removing useless STMT00013 ( 0x047[E-] ... ??? )
               [000046] -----------                         *  RETFILT   void  
 from BB09

BB09 becomes empty
EH#1: New last block of handler: BB11
fgRemoveEmptyFinally() removed 1 try-finally clauses from 1 finallys

*************** After fgRemoveEmptyFinally()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                            85     85    [000..010)                                     keep i IBC 
BB32 [0022]  1                            85     85    [007..008)                                     i IBC 
BB33 [0023]  1                            72.23  72    [007..008)-> BB35 ( cond )                     i IBC 
BB34 [0024]  1                            53.76  54    [007..008)-> BB36 (always)                     i IBC 
BB35 [0025]  1                            18.47  18    [007..008)                                     i IBC 
BB36 [0031]  1                            85     85    [???..???)-> BB03 ( cond )                     keep internal IBC 
BB02 [0001]  1                             0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB03 [0002]  1                            85     85    [012..01A)-> BB05 ( cond )                     i IBC 
BB04 [0003]  1                             0      0    [01A..01C)-> BB16 (always)                     i rare IBC 
BB05 [0004]  1                            85     85    [01C..01D)                                     i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1     0                       1           [025..02E)-> BB13 ( cret )    H0   catch { }   keep i 
BB13 [0012]  1                             1           [???..???)-> BB14 (always)                     i internal 
BB08 [0007]  1                            85     85    [02E..02E)-> BB22 ( cond )                     i IBC 
BB21 [0020]  0                            85     85    [???..???)-> BB20 (always)                     i internal IBC 
BB22 [0021]  0                             0      0    [???..???)                                     i internal rare IBC 
BB20 [0019]  1                            85     85    [02E..041)-> BB11 (always)                     i internal IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB10 (always)                     i internal rare IBC 
BB16 [0015]  1                             0      0    [???..???)-> BB10 (always)                     i internal rare IBC 
BB14 [0013]  1                             1           [???..???)-> BB10 (always)                     i internal 
BB11 [0010]  1                            85     85    [???..???)                                     i internal IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)


*************** Finishing PHASE Remove empty finally
Trees after Remove empty finally

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                            85     85    [000..010)                                     keep i IBC 
BB32 [0022]  1                            85     85    [007..008)                                     i IBC 
BB33 [0023]  1                            72.23  72    [007..008)-> BB35 ( cond )                     i IBC 
BB34 [0024]  1                            53.76  54    [007..008)-> BB36 (always)                     i IBC 
BB35 [0025]  1                            18.47  18    [007..008)                                     i IBC 
BB36 [0031]  1                            85     85    [???..???)-> BB03 ( cond )                     keep internal IBC 
BB02 [0001]  1                             0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB03 [0002]  1                            85     85    [012..01A)-> BB05 ( cond )                     i IBC 
BB04 [0003]  1                             0      0    [01A..01C)-> BB16 (always)                     i rare IBC 
BB05 [0004]  1                            85     85    [01C..01D)                                     i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1     0                       1           [025..02E)-> BB13 ( cret )    H0   catch { }   keep i 
BB13 [0012]  1                             1           [???..???)-> BB14 (always)                     i internal 
BB08 [0007]  1                            85     85    [02E..02E)-> BB22 ( cond )                     i IBC 
BB21 [0020]  0                            85     85    [???..???)-> BB20 (always)                     i internal IBC 
BB22 [0021]  0                             0      0    [???..???)                                     i internal rare IBC 
BB20 [0019]  1                            85     85    [02E..041)-> BB11 (always)                     i internal IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB10 (always)                     i internal rare IBC 
BB16 [0015]  1                             0      0    [???..???)-> BB10 (always)                     i internal rare IBC 
BB14 [0013]  1                             1           [???..???)-> BB10 (always)                     i internal 
BB11 [0010]  1                            85     85    [???..???)                                     i internal IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010), preds={} succs={BB32}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
               [000003] -A-XG------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         
               [000001] ---XG------                         \--*  FIELD     ref    m_method
               [000000] -----------                            \--*  LCL_VAR   ref    V00 this         

------------ BB32 [007..008), preds={} succs={BB33}

------------ BB33 [007..008) -> BB35 (cond), preds={} succs={BB34,BB35}

***** BB33
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000078] -----------                         *  JTRUE     void  
               [000077] -----------                         \--*  EQ        int   
               [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         
               [000076] -----------                            \--*  CNS_INT   ref    null

------------ BB34 [007..008) -> BB36 (always), preds={} succs={BB36}

***** BB34
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000087] -A---------                         *  ASG       bool  
               [000086] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000085] -----------                         \--*  CAST      int <- bool <- int
               [000084] -----------                            \--*  CNS_INT   int    0

------------ BB35 [007..008), preds={} succs={BB36}

***** BB35
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000082] -A---------                         *  ASG       bool  
               [000081] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000080] -----------                         \--*  CAST      int <- bool <- int
               [000079] -----------                            \--*  CNS_INT   int    1

------------ BB36 [???..???) -> BB03 (cond), preds={} succs={BB02,BB03}

***** BB36
STMT00002 ( 0x007[E-] ... ??? )
               [000011] --C--------                         *  JTRUE     void  
               [000010] --C--------                         \--*  EQ        int   
               [000008] --C--------                            +--*  CAST      int <- bool <- int
               [000088] -----------                            |  \--*  LCL_VAR   bool   V09 tmp6         
               [000009] -----------                            \--*  CNS_INT   int    0

------------ BB02 [010..012) -> BB18 (always), preds={} succs={BB18}

------------ BB03 [012..01A) -> BB05 (cond), preds={} succs={BB04,BB05}

***** BB03
STMT00003 ( 0x012[E-] ... 0x018 )
               [000016] ---XG------                         *  JTRUE     void  
               [000015] ---XG------                         \--*  NE        int   
               [000013] ---XG------                            +--*  FIELD     ref    m_methodHandle
               [000012] -----------                            |  \--*  LCL_VAR   ref    V01 loc0         
               [000014] -----------                            \--*  CNS_INT   ref    null

------------ BB04 [01A..01C) -> BB16 (always), preds={} succs={BB16}

------------ BB05 [01C..01D), preds={} succs={BB06}

------------ BB06 [01D..025) -> BB08 (always), preds={} succs={BB08}

***** BB06
STMT00004 ( 0x01D[E-] ... 0x022 )
               [000023] -AC--------                         *  ASG       ref   
               [000022] D------N---                         +--*  LCL_VAR   ref    V04 tmp1         
               [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW

***** BB06
STMT00006 ( 0x022[--] ... ??? )
               [000028] -A---------                         *  ASG       ref   
               [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         
               [000026] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

------------ BB07 [025..02E) -> BB13 (cret), preds={} succs={BB13}

***** BB07
STMT00010 ( 0x025[--] ... 0x02C )
               [000040] -A---O-----                         *  ASG       ref   
               [000039] D------N---                         +--*  LCL_VAR   ref    V05 tmp2         
               [000018] -----O-----                         \--*  CATCH_ARG ref   

***** BB07
STMT00011 ( 0x026[E-] ... ??? )
               [000043] --C-G------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
               [000042] ----------- arg0                    \--*  LCL_VAR   ref    V00 this         

------------ BB13 [???..???) -> BB14 (always), preds={} succs={BB14}

------------ BB08 [02E..02E) -> BB22 (cond), preds={} succs={BB21,BB22}

***** BB08
STMT00014 ( 0x02E[E-] ... ??? )
               [000051] -A-XG------                         *  ASG       ref   
               [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         
               [000048] ---XG------                         \--*  FIELD     ref    m_methodHandle
               [000049] -----------                            \--*  LCL_VAR   ref    V01 loc0         

***** BB08
STMT00015 ( 0x02E[E-] ... ??? )
               [000058] ---X-------                         *  JTRUE     void  
               [000057] ---X-------                         \--*  NE        int   
               [000056] #----------                            +--*  IND       long  
               [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
               [000054] #--X-------                            \--*  IND       long  
               [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         

------------ BB21 [???..???) -> BB20 (always), preds={} succs={BB20}

***** BB21
STMT00016 ( ??? ... ??? )
               [000061] -A---------                         *  ASG       ref   
               [000060] D------N---                         +--*  LCL_VAR   ref    V08 tmp5         
               [000059] -----------                         \--*  LCL_VAR   ref    V07 tmp4         

***** BB21
STMT00018 ( ??? ... ??? )
               [000068] -AC--------                         *  ASG       struct (copy)
               [000066] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8> V06 tmp3         
               [000093] ---XG------                         \--*  FIELD     struct m_value
               [000064] -----------                            \--*  LCL_VAR   ref    V08 tmp5         

------------ BB22 [???..???), preds={} succs={BB20}

***** BB22
STMT00019 ( 0x02E[E-] ... ??? )
               [000071] -ACXG------                         *  ASG       struct (copy)
               [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8> V06 tmp3         
               [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] ----------- this                       \--*  LCL_VAR   ref    V07 tmp4         

------------ BB20 [02E..041) -> BB11 (always), preds={} succs={BB11}

***** BB20
STMT00008 ( 0x02E[E-] ... ??? )
               [000037] -ACXG------                         *  ASG       struct (copy)
               [000036] ---XG------                         +--*  BLK       struct<System.RuntimeMethodHandleInternal, 8>
               [000035] ---XG------                         |  \--*  ADDR      byref 
               [000034] ---XG--N---                         |     \--*  FIELD     struct m_methodHandle
               [000029] -----------                         |        \--*  LCL_VAR   ref    V02 loc1         
               [000047] -----------                         \--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8> V06 tmp3         

------------ BB18 [???..???) -> BB10 (always), preds={} succs={BB10}

------------ BB16 [???..???) -> BB10 (always), preds={} succs={BB10}

------------ BB14 [???..???) -> BB10 (always), preds={} succs={BB10}

------------ BB11 [???..???), preds={} succs={BB10}

------------ BB10 [048..049) (return), preds={} succs={}

***** BB10
STMT00009 ( 0x048[E-] ... 0x048 )
               [000038] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Merge callfinally chains

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                            85     85    [000..010)                                     keep i IBC 
BB32 [0022]  1                            85     85    [007..008)                                     i IBC 
BB33 [0023]  1                            72.23  72    [007..008)-> BB35 ( cond )                     i IBC 
BB34 [0024]  1                            53.76  54    [007..008)-> BB36 (always)                     i IBC 
BB35 [0025]  1                            18.47  18    [007..008)                                     i IBC 
BB36 [0031]  1                            85     85    [???..???)-> BB03 ( cond )                     keep internal IBC 
BB02 [0001]  1                             0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB03 [0002]  1                            85     85    [012..01A)-> BB05 ( cond )                     i IBC 
BB04 [0003]  1                             0      0    [01A..01C)-> BB16 (always)                     i rare IBC 
BB05 [0004]  1                            85     85    [01C..01D)                                     i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1     0                       1           [025..02E)-> BB13 ( cret )    H0   catch { }   keep i 
BB13 [0012]  1                             1           [???..???)-> BB14 (always)                     i internal 
BB08 [0007]  1                            85     85    [02E..02E)-> BB22 ( cond )                     i IBC 
BB21 [0020]  0                            85     85    [???..???)-> BB20 (always)                     i internal IBC 
BB22 [0021]  0                             0      0    [???..???)                                     i internal rare IBC 
BB20 [0019]  1                            85     85    [02E..041)-> BB11 (always)                     i internal IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB10 (always)                     i internal rare IBC 
BB16 [0015]  1                             0      0    [???..???)-> BB10 (always)                     i internal rare IBC 
BB14 [0013]  1                             1           [???..???)-> BB10 (always)                     i internal 
BB11 [0010]  1                            85     85    [???..???)                                     i internal IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)

Method does not have any try-finallys; no merging.

*************** Finishing PHASE Merge callfinally chains [no changes]

*************** Starting PHASE Clone finally

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                            85     85    [000..010)                                     keep i IBC 
BB32 [0022]  1                            85     85    [007..008)                                     i IBC 
BB33 [0023]  1                            72.23  72    [007..008)-> BB35 ( cond )                     i IBC 
BB34 [0024]  1                            53.76  54    [007..008)-> BB36 (always)                     i IBC 
BB35 [0025]  1                            18.47  18    [007..008)                                     i IBC 
BB36 [0031]  1                            85     85    [???..???)-> BB03 ( cond )                     keep internal IBC 
BB02 [0001]  1                             0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB03 [0002]  1                            85     85    [012..01A)-> BB05 ( cond )                     i IBC 
BB04 [0003]  1                             0      0    [01A..01C)-> BB16 (always)                     i rare IBC 
BB05 [0004]  1                            85     85    [01C..01D)                                     i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1     0                       1           [025..02E)-> BB13 ( cret )    H0   catch { }   keep i 
BB13 [0012]  1                             1           [???..???)-> BB14 (always)                     i internal 
BB08 [0007]  1                            85     85    [02E..02E)-> BB22 ( cond )                     i IBC 
BB21 [0020]  0                            85     85    [???..???)-> BB20 (always)                     i internal IBC 
BB22 [0021]  0                             0      0    [???..???)                                     i internal rare IBC 
BB20 [0019]  1                            85     85    [02E..041)-> BB11 (always)                     i internal IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB10 (always)                     i internal rare IBC 
BB16 [0015]  1                             0      0    [???..???)-> BB10 (always)                     i internal rare IBC 
BB14 [0013]  1                             1           [???..???)-> BB10 (always)                     i internal 
BB11 [0010]  1                            85     85    [???..???)                                     i internal IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)

EH#0 is not a try-finally; skipping.

*************** Finishing PHASE Clone finally [no changes]

*************** Starting PHASE Compute preds

Renumbering the basic blocks for fgComputePred

*************** Before renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                            85     85    [000..010)                                     keep i IBC 
BB32 [0022]  1                            85     85    [007..008)                                     i IBC 
BB33 [0023]  1                            72.23  72    [007..008)-> BB35 ( cond )                     i IBC 
BB34 [0024]  1                            53.76  54    [007..008)-> BB36 (always)                     i IBC 
BB35 [0025]  1                            18.47  18    [007..008)                                     i IBC 
BB36 [0031]  1                            85     85    [???..???)-> BB03 ( cond )                     keep internal IBC 
BB02 [0001]  1                             0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB03 [0002]  1                            85     85    [012..01A)-> BB05 ( cond )                     i IBC 
BB04 [0003]  1                             0      0    [01A..01C)-> BB16 (always)                     i rare IBC 
BB05 [0004]  1                            85     85    [01C..01D)                                     i IBC 
BB06 [0005]  1  0                         85     85    [01D..025)-> BB08 (always) T0      try { }     keep i try newobj IBC 
BB07 [0006]  1     0                       1           [025..02E)-> BB13 ( cret )    H0   catch { }   keep i 
BB13 [0012]  1                             1           [???..???)-> BB14 (always)                     i internal 
BB08 [0007]  1                            85     85    [02E..02E)-> BB22 ( cond )                     i IBC 
BB21 [0020]  0                            85     85    [???..???)-> BB20 (always)                     i internal IBC 
BB22 [0021]  0                             0      0    [???..???)                                     i internal rare IBC 
BB20 [0019]  1                            85     85    [02E..041)-> BB11 (always)                     i internal IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB10 (always)                     i internal rare IBC 
BB16 [0015]  1                             0      0    [???..???)-> BB10 (always)                     i internal rare IBC 
BB14 [0013]  1                             1           [???..???)-> BB10 (always)                     i internal 
BB11 [0010]  1                            85     85    [???..???)                                     i internal IBC 
BB10 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB06..BB06 [01D..025), Handler at BB07..BB07 [025..02E)
Renumber BB32 to BB02
Renumber BB33 to BB03
Renumber BB34 to BB04
Renumber BB35 to BB05
Renumber BB36 to BB06
Renumber BB02 to BB07
Renumber BB03 to BB08
Renumber BB04 to BB09
Renumber BB05 to BB10
Renumber BB06 to BB11
Renumber BB07 to BB12
Renumber BB08 to BB14
Renumber BB21 to BB15
Renumber BB22 to BB16
Renumber BB20 to BB17
Renumber BB16 to BB19
Renumber BB14 to BB20
Renumber BB11 to BB21
Renumber BB10 to BB22

*************** After renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                            85     85    [000..010)                                     keep i IBC 
BB02 [0022]  1                            85     85    [007..008)                                     i IBC 
BB03 [0023]  1                            72.23  72    [007..008)-> BB05 ( cond )                     i IBC 
BB04 [0024]  1                            53.76  54    [007..008)-> BB06 (always)                     i IBC 
BB05 [0025]  1                            18.47  18    [007..008)                                     i IBC 
BB06 [0031]  1                            85     85    [???..???)-> BB08 ( cond )                     keep internal IBC 
BB07 [0001]  1                             0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB08 [0002]  1                            85     85    [012..01A)-> BB10 ( cond )                     i IBC 
BB09 [0003]  1                             0      0    [01A..01C)-> BB19 (always)                     i rare IBC 
BB10 [0004]  1                            85     85    [01C..01D)                                     i IBC 
BB11 [0005]  1  0                         85     85    [01D..025)-> BB14 (always) T0      try { }     keep i try newobj IBC 
BB12 [0006]  1     0                       1           [025..02E)-> BB13 ( cret )    H0   catch { }   keep i 
BB13 [0012]  1                             1           [???..???)-> BB20 (always)                     i internal 
BB14 [0007]  1                            85     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  0                            85     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  0                             0      0    [???..???)                                     i internal rare IBC 
BB17 [0019]  1                            85     85    [02E..041)-> BB21 (always)                     i internal IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB22 (always)                     i internal rare IBC 
BB19 [0015]  1                             0      0    [???..???)-> BB22 (always)                     i internal rare IBC 
BB20 [0013]  1                             1           [???..???)-> BB22 (always)                     i internal 
BB21 [0010]  1                            85     85    [???..???)                                     i internal IBC 
BB22 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB11..BB11 [01D..025), Handler at BB12..BB12 [025..02E)

New BlockSet epoch 4, # of blocks (including unused BB00): 23, bitset array size: 1 (short)

*************** In fgComputePreds()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd                 weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                            85     85    [000..010)                                     keep i IBC 
BB02 [0022]  1                            85     85    [007..008)                                     i IBC 
BB03 [0023]  1                            72.23  72    [007..008)-> BB05 ( cond )                     i IBC 
BB04 [0024]  1                            53.76  54    [007..008)-> BB06 (always)                     i IBC 
BB05 [0025]  1                            18.47  18    [007..008)                                     i IBC 
BB06 [0031]  1                            85     85    [???..???)-> BB08 ( cond )                     keep internal IBC 
BB07 [0001]  1                             0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB08 [0002]  1                            85     85    [012..01A)-> BB10 ( cond )                     i IBC 
BB09 [0003]  1                             0      0    [01A..01C)-> BB19 (always)                     i rare IBC 
BB10 [0004]  1                            85     85    [01C..01D)                                     i IBC 
BB11 [0005]  1  0                         85     85    [01D..025)-> BB14 (always) T0      try { }     keep i try newobj IBC 
BB12 [0006]  1     0                       1           [025..02E)-> BB13 ( cret )    H0   catch { }   keep i 
BB13 [0012]  1                             1           [???..???)-> BB20 (always)                     i internal 
BB14 [0007]  1                            85     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  0                            85     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  0                             0      0    [???..???)                                     i internal rare IBC 
BB17 [0019]  1                            85     85    [02E..041)-> BB21 (always)                     i internal IBC 
BB18 [0017]  1                             0      0    [???..???)-> BB22 (always)                     i internal rare IBC 
BB19 [0015]  1                             0      0    [???..???)-> BB22 (always)                     i internal rare IBC 
BB20 [0013]  1                             1           [???..???)-> BB22 (always)                     i internal 
BB21 [0010]  1                            85     85    [???..???)                                     i internal IBC 
BB22 [0009]  4                            85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

Setting edge weights for BB01 -> BB02 to [0 .. 3.402823e+38]
Setting edge weights for BB02 -> BB03 to [0 .. 3.402823e+38]
Setting edge weights for BB03 -> BB05 to [0 .. 3.402823e+38]
Setting edge weights for BB03 -> BB04 to [0 .. 3.402823e+38]
Setting edge weights for BB04 -> BB06 to [0 .. 3.402823e+38]
Setting edge weights for BB05 -> BB06 to [0 .. 3.402823e+38]
Setting edge weights for BB06 -> BB08 to [0 .. 3.402823e+38]
Setting edge weights for BB06 -> BB07 to [0 .. 3.402823e+38]
Setting edge weights for BB07 -> BB18 to [0 .. 3.402823e+38]
Setting edge weights for BB08 -> BB10 to [0 .. 3.402823e+38]
Setting edge weights for BB08 -> BB09 to [0 .. 3.402823e+38]
Setting edge weights for BB09 -> BB19 to [0 .. 3.402823e+38]
Setting edge weights for BB10 -> BB11 to [0 .. 3.402823e+38]
Setting edge weights for BB11 -> BB14 to [0 .. 3.402823e+38]
Setting edge weights for BB12 -> BB13 to [0 .. 3.402823e+38]
Setting edge weights for BB13 -> BB20 to [0 .. 3.402823e+38]
Setting edge weights for BB14 -> BB16 to [0 .. 3.402823e+38]
Setting edge weights for BB14 -> BB15 to [0 .. 3.402823e+38]
Setting edge weights for BB15 -> BB17 to [0 .. 3.402823e+38]
Setting edge weights for BB16 -> BB17 to [0 .. 3.402823e+38]
Setting edge weights for BB17 -> BB21 to [0 .. 3.402823e+38]
Setting edge weights for BB18 -> BB22 to [0 .. 3.402823e+38]
Setting edge weights for BB19 -> BB22 to [0 .. 3.402823e+38]
Setting edge weights for BB20 -> BB22 to [0 .. 3.402823e+38]
Setting edge weights for BB21 -> BB22 to [0 .. 3.402823e+38]

*************** After fgComputePreds()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                            85     85    [000..010)                                     keep i IBC 
BB02 [0022]  1       BB01                 85     85    [007..008)                                     i IBC 
BB03 [0023]  1       BB02                 72.23  72    [007..008)-> BB05 ( cond )                     i IBC 
BB04 [0024]  1       BB03                 53.76  54    [007..008)-> BB06 (always)                     i IBC 
BB05 [0025]  1       BB03                 18.47  18    [007..008)                                     i IBC 
BB06 [0031]  2       BB04,BB05            85     85    [???..???)-> BB08 ( cond )                     keep internal IBC 
BB07 [0001]  1       BB06                  0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB08 [0002]  1       BB06                 85     85    [012..01A)-> BB10 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB19 (always)                     i rare IBC 
BB10 [0004]  1       BB08                 85     85    [01C..01D)                                     i IBC 
BB11 [0005]  1  0    BB10                 85     85    [01D..025)-> BB14 (always) T0      try { }     keep i try newobj IBC 
BB12 [0006]  1     0                       1           [025..02E)-> BB13 ( cret )    H0   catch { }   keep i 
BB13 [0012]  1       BB12                  1           [???..???)-> BB20 (always)                     i internal 
BB14 [0007]  1       BB11                 85     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                 85     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare IBC 
BB17 [0019]  2       BB15,BB16            85     85    [02E..041)-> BB21 (always)                     i internal IBC 
BB18 [0017]  1       BB07                  0      0    [???..???)-> BB22 (always)                     i internal rare IBC 
BB19 [0015]  1       BB09                  0      0    [???..???)-> BB22 (always)                     i internal rare IBC 
BB20 [0013]  1       BB13                  1           [???..???)-> BB22 (always)                     i internal 
BB21 [0010]  1       BB17                 85     85    [???..???)                                     i internal IBC 
BB22 [0009]  4       BB18,BB19,BB20,BB21  85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------


*************** Finishing PHASE Compute preds

*************** Starting PHASE Merge throw blocks

*************** In fgTailMergeThrows
Method does not have multiple noreturn calls.

*************** Finishing PHASE Merge throw blocks [no changes]

*************** Starting PHASE Update flow graph early pass

*************** In fgUpdateFlowGraph()
Before updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                            85     85    [000..010)                                     keep i IBC 
BB02 [0022]  1       BB01                 85     85    [007..008)                                     i IBC 
BB03 [0023]  1       BB02                 72.23  72    [007..008)-> BB05 ( cond )                     i IBC 
BB04 [0024]  1       BB03                 53.76  54    [007..008)-> BB06 (always)                     i IBC 
BB05 [0025]  1       BB03                 18.47  18    [007..008)                                     i IBC 
BB06 [0031]  2       BB04,BB05            85     85    [???..???)-> BB08 ( cond )                     keep internal IBC 
BB07 [0001]  1       BB06                  0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB08 [0002]  1       BB06                 85     85    [012..01A)-> BB10 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB19 (always)                     i rare IBC 
BB10 [0004]  1       BB08                 85     85    [01C..01D)                                     i IBC 
BB11 [0005]  1  0    BB10                 85     85    [01D..025)-> BB14 (always) T0      try { }     keep i try newobj IBC 
BB12 [0006]  1     0                       1           [025..02E)-> BB13 ( cret )    H0   catch { }   keep i 
BB13 [0012]  1       BB12                  1           [???..???)-> BB20 (always)                     i internal 
BB14 [0007]  1       BB11                 85     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                 85     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare IBC 
BB17 [0019]  2       BB15,BB16            85     85    [02E..041)-> BB21 (always)                     i internal IBC 
BB18 [0017]  1       BB07                  0      0    [???..???)-> BB22 (always)                     i internal rare IBC 
BB19 [0015]  1       BB09                  0      0    [???..???)-> BB22 (always)                     i internal rare IBC 
BB20 [0013]  1       BB13                  1           [???..???)-> BB22 (always)                     i internal 
BB21 [0010]  1       BB17                 85     85    [???..???)                                     i internal IBC 
BB22 [0009]  4       BB18,BB19,BB20,BB21  85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------


Compacting blocks BB01 and BB02:
*************** In fgDebugCheckBBlist

Compacting blocks BB01 and BB03:
*************** In fgDebugCheckBBlist
fgRemoveBlock BB10, unreachable=false
Removing empty BB10
Setting edge weights for BB08 -> BB11 to [0 .. 3.402823e+38]

Compacting blocks BB21 and BB22:
Second block has multiple incoming edges
Setting edge weights for BB18 -> BB21 to [0 .. 3.402823e+38]
Setting edge weights for BB19 -> BB21 to [0 .. 3.402823e+38]
Setting edge weights for BB20 -> BB21 to [0 .. 3.402823e+38]
*************** In fgDebugCheckBBlist

Removing unconditional jump to next block (BB20 -> BB21) (converted BB20 to fall-through)

Compacting blocks BB20 and BB21:
Second block has multiple incoming edges
Setting edge weights for BB17 -> BB20 to [0 .. 3.402823e+38]
Setting edge weights for BB18 -> BB20 to [0 .. 3.402823e+38]
Setting edge weights for BB19 -> BB20 to [0 .. 3.402823e+38]
*************** In fgDebugCheckBBlist

Removing unconditional jump to next block (BB19 -> BB20) (converted BB19 to fall-through)

Compacting blocks BB19 and BB20:
Second block has multiple incoming edges
Setting edge weights for BB13 -> BB19 to [0 .. 3.402823e+38]
Setting edge weights for BB17 -> BB19 to [0 .. 3.402823e+38]
Setting edge weights for BB18 -> BB19 to [0 .. 3.402823e+38]
*************** In fgDebugCheckBBlist

Removing unconditional jump to next block (BB18 -> BB19) (converted BB18 to fall-through)

Compacting blocks BB18 and BB19:
Second block has multiple incoming edges
Setting edge weights for BB09 -> BB18 to [0 .. 3.402823e+38]
Setting edge weights for BB13 -> BB18 to [0 .. 3.402823e+38]
Setting edge weights for BB17 -> BB18 to [0 .. 3.402823e+38]
*************** In fgDebugCheckBBlist

Removing unconditional jump to next block (BB17 -> BB18) (converted BB17 to fall-through)

After updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                            85     85    [000..010)-> BB05 ( cond )                     keep i IBC 
BB04 [0024]  1       BB01                 53.76  54    [007..008)-> BB06 (always)                     i IBC 
BB05 [0025]  1       BB01                 18.47  18    [007..008)                                     i IBC 
BB06 [0031]  2       BB04,BB05            85     85    [???..???)-> BB08 ( cond )                     keep internal IBC 
BB07 [0001]  1       BB06                  0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB08 [0002]  1       BB06                 85     85    [012..01A)-> BB11 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB18 (always)                     i rare IBC 
BB11 [0005]  1  0    BB08                 85     85    [01C..025)-> BB14 (always) T0      try { }     keep i try newobj IBC 
BB12 [0006]  1     0                       1           [025..02E)-> BB13 ( cret )    H0   catch { }   keep i 
BB13 [0012]  1       BB12                  1           [???..???)-> BB18 (always)                     i internal 
BB14 [0007]  1       BB11                 85     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                 85     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare IBC 
BB17 [0019]  2       BB15,BB16            85     85    [02E..041)                                     i internal IBC 
BB18 [0017]  4       BB07,BB09,BB13,BB17  85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB11..BB11 [01D..025), Handler at BB12..BB12 [025..02E)
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Update flow graph early pass

*************** Starting PHASE Morph - Promote Structs

*************** In fgResetImplicitByRefRefCount()
*************** In fgPromoteStructs()

lvaTable before fgPromoteStructs
; Initial local variable assignments
;
;  V00 this              ref  this class-hnd
;  V01 loc0              ref  class-hnd
;  V02 loc1              ref  class-hnd exact
;  V03 OutArgs        lclBlk <na>  "OutgoingArgSpace"
;  V04 tmp1              ref  class-hnd exact "NewObj constructor temp"
;  V05 tmp2              ref  class-hnd "impSpillSpecialSideEff"
;  V06 tmp3           struct <System.RuntimeMethodHandleInternal, 8> "guarded devirt return temp"
;  V07 tmp4              ref  "guarded devirt this temp"
;  V08 tmp5              ref  class-hnd exact "guarded devirt this exact temp"
;  V09 tmp6             bool  "Inline return value spill temp"

Promoting struct local V06 (System.RuntimeMethodHandleInternal):
lvaGrabTemp returning 10 (V10 tmp7) (a long lifetime temp) called for field V06.m_handle (fldOffset=0x0).

lvaTable after fgPromoteStructs
; Initial local variable assignments
;
;  V00 this              ref  this class-hnd
;  V01 loc0              ref  class-hnd
;  V02 loc1              ref  class-hnd exact
;  V03 OutArgs        lclBlk <na>  "OutgoingArgSpace"
;  V04 tmp1              ref  class-hnd exact "NewObj constructor temp"
;  V05 tmp2              ref  class-hnd "impSpillSpecialSideEff"
;  V06 tmp3           struct <System.RuntimeMethodHandleInternal, 8> "guarded devirt return temp"
;  V07 tmp4              ref  "guarded devirt this temp"
;  V08 tmp5              ref  class-hnd exact "guarded devirt this exact temp"
;  V09 tmp6             bool  "Inline return value spill temp"
;  V10 tmp7             long  V06.m_handle(offs=0x00) P-INDEP "field V06.m_handle (fldOffset=0x0)"

*************** Finishing PHASE Morph - Promote Structs

*************** Starting PHASE Morph - Structs/AddrExp

*************** In fgMarkAddressExposedLocals()
LocalAddressVisitor visiting statement:
STMT00000 ( 0x000[E-] ... 0x006 )
               [000003] -A-XG------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         
               [000001] ---XG------                         \--*  FIELD     ref    m_method
               [000000] -----------                            \--*  LCL_VAR   ref    V00 this         

LocalAddressVisitor visiting statement:
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000078] -----------                         *  JTRUE     void  
               [000077] -----------                         \--*  EQ        int   
               [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         
               [000076] -----------                            \--*  CNS_INT   ref    null

LocalAddressVisitor visiting statement:
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000087] -A---------                         *  ASG       bool  
               [000086] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000085] -----------                         \--*  CAST      int <- bool <- int
               [000084] -----------                            \--*  CNS_INT   int    0

LocalAddressVisitor visiting statement:
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000082] -A---------                         *  ASG       bool  
               [000081] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000080] -----------                         \--*  CAST      int <- bool <- int
               [000079] -----------                            \--*  CNS_INT   int    1

LocalAddressVisitor visiting statement:
STMT00002 ( 0x007[E-] ... ??? )
               [000011] --C--------                         *  JTRUE     void  
               [000010] --C--------                         \--*  EQ        int   
               [000008] --C--------                            +--*  CAST      int <- bool <- int
               [000088] -----------                            |  \--*  LCL_VAR   bool   V09 tmp6         
               [000009] -----------                            \--*  CNS_INT   int    0

LocalAddressVisitor visiting statement:
STMT00003 ( 0x012[E-] ... 0x018 )
               [000016] ---XG------                         *  JTRUE     void  
               [000015] ---XG------                         \--*  NE        int   
               [000013] ---XG------                            +--*  FIELD     ref    m_methodHandle
               [000012] -----------                            |  \--*  LCL_VAR   ref    V01 loc0         
               [000014] -----------                            \--*  CNS_INT   ref    null

LocalAddressVisitor visiting statement:
STMT00004 ( 0x01D[E-] ... 0x022 )
               [000023] -AC--------                         *  ASG       ref   
               [000022] D------N---                         +--*  LCL_VAR   ref    V04 tmp1         
               [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW

LocalAddressVisitor visiting statement:
STMT00006 ( 0x022[--] ... ??? )
               [000028] -A---------                         *  ASG       ref   
               [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         
               [000026] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

LocalAddressVisitor visiting statement:
STMT00010 ( 0x025[--] ... 0x02C )
               [000040] -A---O-----                         *  ASG       ref   
               [000039] D------N---                         +--*  LCL_VAR   ref    V05 tmp2         
               [000018] -----O-----                         \--*  CATCH_ARG ref   

LocalAddressVisitor visiting statement:
STMT00011 ( 0x026[E-] ... ??? )
               [000043] --C-G------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
               [000042] ----------- arg0                    \--*  LCL_VAR   ref    V00 this         

LocalAddressVisitor visiting statement:
STMT00014 ( 0x02E[E-] ... ??? )
               [000051] -A-XG------                         *  ASG       ref   
               [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         
               [000048] ---XG------                         \--*  FIELD     ref    m_methodHandle
               [000049] -----------                            \--*  LCL_VAR   ref    V01 loc0         

LocalAddressVisitor visiting statement:
STMT00015 ( 0x02E[E-] ... ??? )
               [000058] ---X-------                         *  JTRUE     void  
               [000057] ---X-------                         \--*  NE        int   
               [000056] #----------                            +--*  IND       long  
               [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
               [000054] #--X-------                            \--*  IND       long  
               [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         

LocalAddressVisitor visiting statement:
STMT00016 ( ??? ... ??? )
               [000061] -A---------                         *  ASG       ref   
               [000060] D------N---                         +--*  LCL_VAR   ref    V08 tmp5         
               [000059] -----------                         \--*  LCL_VAR   ref    V07 tmp4         

LocalAddressVisitor visiting statement:
STMT00018 ( ??? ... ??? )
               [000068] -AC--------                         *  ASG       struct (copy)
               [000066] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000093] ---XG------                         \--*  FIELD     struct m_value
               [000064] -----------                            \--*  LCL_VAR   ref    V08 tmp5         

LocalAddressVisitor visiting statement:
STMT00019 ( 0x02E[E-] ... ??? )
               [000071] -ACXG------                         *  ASG       struct (copy)
               [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] ----------- this                       \--*  LCL_VAR   ref    V07 tmp4         

LocalAddressVisitor visiting statement:
STMT00008 ( 0x02E[E-] ... ??? )
               [000037] -ACXG------                         *  ASG       struct (copy)
               [000036] ---XG------                         +--*  BLK       struct<System.RuntimeMethodHandleInternal, 8>
               [000035] ---XG------                         |  \--*  ADDR      byref 
               [000034] ---XG--N---                         |     \--*  FIELD     struct m_methodHandle
               [000029] -----------                         |        \--*  LCL_VAR   ref    V02 loc1         
               [000047] -----------                         \--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            \--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         

LocalAddressVisitor visiting statement:
STMT00009 ( 0x048[E-] ... 0x048 )
               [000038] -----------                         *  RETURN    void  


*************** Finishing PHASE Morph - Structs/AddrExp

*************** Starting PHASE Forward Substitution


===> BB01
    [000003]:  not asg (single-use lcl)


===> BB04


===> BB05


===> BB06


===> BB07


===> BB08


===> BB09


===> BB11
    [000023]:  [000026] is only use of [000022] (V04)  -- fwd subbing [000021]; new next stmt is
STMT00006 ( 0x022[--] ... ??? )
               [000028] -AC--------                         *  ASG       ref   
               [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         
               [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW

removing useless STMT00004 ( 0x01D[E-] ... 0x022 )
               [000023] -AC--------                         *  ASG       ref   
               [000022] D------N---                         +--*  LCL_VAR   ref    V04 tmp1         
               [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW
 from BB11


===> BB12
    [000040]:  not asg (single-use lcl)


===> BB13


===> BB14
    [000051]:  not asg (single-use lcl)


===> BB15
    [000061]:  [000064] is only use of [000060] (V08)  -- fwd subbing [000059]; new next stmt is
STMT00018 ( ??? ... ??? )
               [000068] -A-XG------                         *  ASG       struct (copy)
               [000066] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000093] ---XG------                         \--*  FIELD     struct m_value
               [000059] -----------                            \--*  LCL_VAR   ref    V07 tmp4         

removing useless STMT00016 ( ??? ... ??? )
               [000061] -A---------                         *  ASG       ref   
               [000060] D------N---                         +--*  LCL_VAR   ref    V08 tmp5         
               [000059] -----------                         \--*  LCL_VAR   ref    V07 tmp4         
 from BB15


===> BB16


===> BB17


===> BB18

*************** Finishing PHASE Forward Substitution
Trees after Forward Substitution

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                            85     85    [000..010)-> BB05 ( cond )                     keep i IBC 
BB04 [0024]  1       BB01                 53.76  54    [007..008)-> BB06 (always)                     i IBC 
BB05 [0025]  1       BB01                 18.47  18    [007..008)                                     i IBC 
BB06 [0031]  2       BB04,BB05            85     85    [???..???)-> BB08 ( cond )                     keep internal IBC 
BB07 [0001]  1       BB06                  0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB08 [0002]  1       BB06                 85     85    [012..01A)-> BB11 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB18 (always)                     i rare IBC 
BB11 [0005]  1  0    BB08                 85     85    [01C..025)-> BB14 (always) T0      try { }     keep i try newobj IBC 
BB12 [0006]  1     0                       1           [025..02E)-> BB13 ( cret )    H0   catch { }   keep i 
BB13 [0012]  1       BB12                  1           [???..???)-> BB18 (always)                     i internal 
BB14 [0007]  1       BB11                 85     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                 85     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare IBC 
BB17 [0019]  2       BB15,BB16            85     85    [02E..041)                                     i internal IBC 
BB18 [0017]  4       BB07,BB09,BB13,BB17  85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB05 (cond), preds={} succs={BB04,BB05}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
               [000003] -A-XG------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         
               [000001] ---XG------                         \--*  FIELD     ref    m_method
               [000000] -----------                            \--*  LCL_VAR   ref    V00 this         

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000078] -----------                         *  JTRUE     void  
               [000077] -----------                         \--*  EQ        int   
               [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         
               [000076] -----------                            \--*  CNS_INT   ref    null

------------ BB04 [007..008) -> BB06 (always), preds={BB01} succs={BB06}

***** BB04
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000087] -A---------                         *  ASG       bool  
               [000086] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000085] -----------                         \--*  CAST      int <- bool <- int
               [000084] -----------                            \--*  CNS_INT   int    0

------------ BB05 [007..008), preds={BB01} succs={BB06}

***** BB05
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000082] -A---------                         *  ASG       bool  
               [000081] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000080] -----------                         \--*  CAST      int <- bool <- int
               [000079] -----------                            \--*  CNS_INT   int    1

------------ BB06 [???..???) -> BB08 (cond), preds={BB04,BB05} succs={BB07,BB08}

***** BB06
STMT00002 ( 0x007[E-] ... ??? )
               [000011] --C--------                         *  JTRUE     void  
               [000010] --C--------                         \--*  EQ        int   
               [000008] --C--------                            +--*  CAST      int <- bool <- int
               [000088] -----------                            |  \--*  LCL_VAR   bool   V09 tmp6         
               [000009] -----------                            \--*  CNS_INT   int    0

------------ BB07 [010..012) -> BB18 (always), preds={BB06} succs={BB18}

------------ BB08 [012..01A) -> BB11 (cond), preds={BB06} succs={BB09,BB11}

***** BB08
STMT00003 ( 0x012[E-] ... 0x018 )
               [000016] ---XG------                         *  JTRUE     void  
               [000015] ---XG------                         \--*  NE        int   
               [000013] ---XG------                            +--*  FIELD     ref    m_methodHandle
               [000012] -----------                            |  \--*  LCL_VAR   ref    V01 loc0         
               [000014] -----------                            \--*  CNS_INT   ref    null

------------ BB09 [01A..01C) -> BB18 (always), preds={BB08} succs={BB18}

------------ BB11 [01C..025) -> BB14 (always), preds={BB08} succs={BB14}

***** BB11
STMT00006 ( 0x022[--] ... ??? )
               [000028] -AC--------                         *  ASG       ref   
               [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         
               [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW

------------ BB12 [025..02E) -> BB13 (cret), preds={} succs={BB13}

***** BB12
STMT00010 ( 0x025[--] ... 0x02C )
               [000040] -A---O-----                         *  ASG       ref   
               [000039] D------N---                         +--*  LCL_VAR   ref    V05 tmp2         
               [000018] -----O-----                         \--*  CATCH_ARG ref   

***** BB12
STMT00011 ( 0x026[E-] ... ??? )
               [000043] --C-G------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
               [000042] ----------- arg0                    \--*  LCL_VAR   ref    V00 this         

------------ BB13 [???..???) -> BB18 (always), preds={BB12} succs={BB18}

------------ BB14 [02E..02E) -> BB16 (cond), preds={BB11} succs={BB15,BB16}

***** BB14
STMT00014 ( 0x02E[E-] ... ??? )
               [000051] -A-XG------                         *  ASG       ref   
               [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         
               [000048] ---XG------                         \--*  FIELD     ref    m_methodHandle
               [000049] -----------                            \--*  LCL_VAR   ref    V01 loc0         

***** BB14
STMT00015 ( 0x02E[E-] ... ??? )
               [000058] ---X-------                         *  JTRUE     void  
               [000057] ---X-------                         \--*  NE        int   
               [000056] #----------                            +--*  IND       long  
               [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
               [000054] #--X-------                            \--*  IND       long  
               [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         

------------ BB15 [???..???) -> BB17 (always), preds={BB14} succs={BB17}

***** BB15
STMT00018 ( ??? ... ??? )
               [000068] -A-XG------                         *  ASG       struct (copy)
               [000066] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000093] ---XG------                         \--*  FIELD     struct m_value
               [000059] -----------                            \--*  LCL_VAR   ref    V07 tmp4         

------------ BB16 [???..???), preds={BB14} succs={BB17}

***** BB16
STMT00019 ( 0x02E[E-] ... ??? )
               [000071] -ACXG------                         *  ASG       struct (copy)
               [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] ----------- this                       \--*  LCL_VAR   ref    V07 tmp4         

------------ BB17 [02E..041), preds={BB15,BB16} succs={BB18}

***** BB17
STMT00008 ( 0x02E[E-] ... ??? )
               [000037] -ACXG------                         *  ASG       struct (copy)
               [000036] ---XG------                         +--*  BLK       struct<System.RuntimeMethodHandleInternal, 8>
               [000035] ---XG------                         |  \--*  ADDR      byref 
               [000034] ---XG--N---                         |     \--*  FIELD     struct m_methodHandle
               [000029] -----------                         |        \--*  LCL_VAR   ref    V02 loc1         
               [000047] -----------                         \--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            \--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         

------------ BB18 [048..049) (return), preds={BB07,BB09,BB13,BB17} succs={}

***** BB18
STMT00009 ( 0x048[E-] ... 0x048 )
               [000038] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Morph - ByRefs

*************** In fgRetypeImplicitByRefArgs()

*************** Finishing PHASE Morph - ByRefs

*************** Starting PHASE Morph - Global

*************** In fgMorphBlocks()

Morphing BB01 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

fgMorphTree BB01, STMT00000 (before)
               [000003] -A-XG------                         *  ASG       ref   
               [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         
               [000001] ---XG------                         \--*  FIELD     ref    m_method
               [000000] -----------                            \--*  LCL_VAR   ref    V00 this         
Notify VM instruction set (SSE2) must be supported.

Final value of Compiler::fgMorphField after calling fgMorphSmpOp:
               [000001] ---XG------                         *  IND       ref   
               [000097] -----+-----                         \--*  ADD       byref 
               [000000] -----+-----                            +--*  LCL_VAR   ref    V00 this         
               [000096] -----+-----                            \--*  CNS_INT   long   24 field offset Fseq[m_method]
GenTreeNode creates assertion:
               [000001] ---XG------                         *  IND       ref   
In BB01 New Local Constant Assertion: V00 != null, index = #01

fgMorphTree BB01, STMT00000 (after)
               [000003] -A-XG+-----                         *  ASG       ref   
               [000002] D----+-N---                         +--*  LCL_VAR   ref    V01 loc0         
               [000001] ---XG+-----                         \--*  IND       ref   
               [000097] -----+-----                            \--*  ADD       byref 
               [000000] -----+-----                               +--*  LCL_VAR   ref    V00 this         
               [000096] -----+-----                               \--*  CNS_INT   long   24 field offset Fseq[m_method]

fgMorphTree BB01, STMT00020 (before)
               [000078] -----------                         *  JTRUE     void  
               [000077] -----------                         \--*  EQ        int   
               [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         
               [000076] -----------                            \--*  CNS_INT   ref    null

Morphing BB04 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

fgMorphTree BB04, STMT00022 (before)
               [000087] -A---------                         *  ASG       bool  
               [000086] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000085] -----------                         \--*  CAST      int <- bool <- int
               [000084] -----------                            \--*  CNS_INT   int    0

Folding operator with constant nodes into a constant:
               [000085] -----------                         *  CAST      int <- bool <- int
               [000084] -----+-----                         \--*  CNS_INT   int    0
Bashed to int constant:
               [000085] -----------                         *  CNS_INT   int    0
GenTreeNode creates assertion:
               [000087] -A---------                         *  ASG       bool  
In BB04 New Local Constant Assertion: V09 == 0, index = #01

fgMorphTree BB04, STMT00022 (after)
               [000087] -A---+-----                         *  ASG       bool  
               [000086] D----+-N---                         +--*  LCL_VAR   int    V09 tmp6         
               [000085] -----+-----                         \--*  CNS_INT   int    0

Morphing BB05 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

fgMorphTree BB05, STMT00021 (before)
               [000082] -A---------                         *  ASG       bool  
               [000081] D------N---                         +--*  LCL_VAR   bool   V09 tmp6         
               [000080] -----------                         \--*  CAST      int <- bool <- int
               [000079] -----------                            \--*  CNS_INT   int    1

Folding operator with constant nodes into a constant:
               [000080] -----------                         *  CAST      int <- bool <- int
               [000079] -----+-----                         \--*  CNS_INT   int    1
Bashed to int constant:
               [000080] -----------                         *  CNS_INT   int    1
GenTreeNode creates assertion:
               [000082] -A---------                         *  ASG       bool  
In BB05 New Local Constant Assertion: V09 == 1, index = #01

fgMorphTree BB05, STMT00021 (after)
               [000082] -A---+-----                         *  ASG       bool  
               [000081] D----+-N---                         +--*  LCL_VAR   int    V09 tmp6         
               [000080] -----+-----                         \--*  CNS_INT   int    1

Morphing BB06 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

fgMorphTree BB06, STMT00002 (before)
               [000011] --C--------                         *  JTRUE     void  
               [000010] --C--------                         \--*  EQ        int   
               [000008] --C--------                            +--*  CAST      int <- bool <- int
               [000088] -----------                            |  \--*  LCL_VAR   bool   V09 tmp6         
               [000009] -----------                            \--*  CNS_INT   int    0

fgMorphTree BB06, STMT00002 (after)
               [000011] -----+-----                         *  JTRUE     void  
               [000010] J----+-N---                         \--*  EQ        int   
               [000088] -----+-----                            +--*  LCL_VAR   bool   V09 tmp6         
               [000009] -----+-----                            \--*  CNS_INT   int    0

Morphing BB07 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

Morphing BB08 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

fgMorphTree BB08, STMT00003 (before)
               [000016] ---XG------                         *  JTRUE     void  
               [000015] ---XG------                         \--*  NE        int   
               [000013] ---XG------                            +--*  FIELD     ref    m_methodHandle
               [000012] -----------                            |  \--*  LCL_VAR   ref    V01 loc0         
               [000014] -----------                            \--*  CNS_INT   ref    null
Querying runtime about current class of field System.Reflection.Emit.DynamicMethod.m_methodHandle (declared as System.IRuntimeMethodInfo)
Field's current class not available

Final value of Compiler::fgMorphField after calling fgMorphSmpOp:
               [000013] ---XG------                         *  IND       ref   
               [000099] -----+-----                         \--*  ADD       byref 
               [000012] -----+-----                            +--*  LCL_VAR   ref    V01 loc0         
               [000098] -----+-----                            \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]
GenTreeNode creates assertion:
               [000013] ---XG------                         *  IND       ref   
In BB08 New Local Constant Assertion: V01 != null, index = #01

fgMorphTree BB08, STMT00003 (after)
               [000016] ---XG+-----                         *  JTRUE     void  
               [000015] J--XG+-N---                         \--*  NE        int   
               [000013] ---XG+-----                            +--*  IND       ref   
               [000099] -----+-----                            |  \--*  ADD       byref 
               [000012] -----+-----                            |     +--*  LCL_VAR   ref    V01 loc0         
               [000098] -----+-----                            |     \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]
               [000014] -----+-----                            \--*  CNS_INT   ref    null

Morphing BB09 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

Morphing BB11 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

fgMorphTree BB11, STMT00006 (before)
               [000028] -AC--------                         *  ASG       ref   
               [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         
               [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW
Initializing arg info for 21.CALL:
Args for call [000021] CALL after AddFinalArgsAndDetermineABIInfo:

Morphing args for 21.CALL:
Args for [000021].CALL after fgMorphArgs:
OutgoingArgsStackSize is 32


Morphing BB12 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

fgMorphTree BB12, STMT00010 (before)
               [000040] -A---O-----                         *  ASG       ref   
               [000039] D------N---                         +--*  LCL_VAR   ref    V05 tmp2         
               [000018] -----O-----                         \--*  CATCH_ARG ref   

fgMorphTree BB12, STMT00011 (before)
               [000043] --C-G------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
               [000042] ----------- arg0                    \--*  LCL_VAR   ref    V00 this         
Initializing arg info for 43.CALL:
Args for call [000043] CALL after AddFinalArgsAndDetermineABIInfo:
CallArg[[000042].LCL_VAR ref (By value), 1 reg: rcx, byteAlignment=8]

Morphing args for 43.CALL:

Sorting the arguments:
Deferred argument ('rcx'):
               [000042] -----+-----                         *  LCL_VAR   ref    V00 this         
Moved to late list

Shuffled argument table:    rcx 
Args for [000043].CALL after fgMorphArgs:
CallArg[[000042].LCL_VAR ref (By value), 1 reg: rcx, byteAlignment=8, isLate, processed]
OutgoingArgsStackSize is 32


Morphing BB13 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

Morphing BB14 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

fgMorphTree BB14, STMT00014 (before)
               [000051] -A-XG------                         *  ASG       ref   
               [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         
               [000048] ---XG------                         \--*  FIELD     ref    m_methodHandle
               [000049] -----------                            \--*  LCL_VAR   ref    V01 loc0         

Final value of Compiler::fgMorphField after calling fgMorphSmpOp:
               [000048] ---XG------                         *  IND       ref   
               [000101] -----+-----                         \--*  ADD       byref 
               [000049] -----+-----                            +--*  LCL_VAR   ref    V01 loc0         
               [000100] -----+-----                            \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]
GenTreeNode creates assertion:
               [000048] ---XG------                         *  IND       ref   
In BB14 New Local Constant Assertion: V01 != null, index = #01

fgMorphTree BB14, STMT00014 (after)
               [000051] -A-XG+-----                         *  ASG       ref   
               [000050] D----+-N---                         +--*  LCL_VAR   ref    V07 tmp4         
               [000048] ---XG+-----                         \--*  IND       ref   
               [000101] -----+-----                            \--*  ADD       byref 
               [000049] -----+-----                               +--*  LCL_VAR   ref    V01 loc0         
               [000100] -----+-----                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]

fgMorphTree BB14, STMT00015 (before)
               [000058] ---X-------                         *  JTRUE     void  
               [000057] ---X-------                         \--*  NE        int   
               [000056] #----------                            +--*  IND       long  
               [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
               [000054] #--X-------                            \--*  IND       long  
               [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         
GenTreeNode creates assertion:
               [000054] #--X-------                         *  IND       long  
In BB14 New Local Constant Assertion: V07 != null, index = #02

Morphing BB15 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

fgMorphTree BB15, STMT00018 (before)
               [000068] -A-XG------                         *  ASG       struct (copy)
               [000066] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000093] ---XG------                         \--*  FIELD     struct m_value
               [000059] -----------                            \--*  LCL_VAR   ref    V07 tmp4         

Final value of Compiler::fgMorphField after calling fgMorphSmpOp:
               [000093] ---XG------                         *  IND       struct
               [000103] -----+-----                         \--*  ADD       byref 
               [000059] -----+-----                            +--*  LCL_VAR   ref    V07 tmp4         
               [000102] -----+-----                            \--*  CNS_INT   long   80 field offset Fseq[m_value]
GenTreeNode creates assertion:
               [000093] ---XG------                         *  IND       struct
In BB15 New Local Constant Assertion: V07 != null, index = #01
MorphCopyBlock:
MorphBlock for dst tree, before:
               [000066] D----+-N---                         *  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            *    long   V06.m_handle (offs=0x00) -> V10 tmp7         
MorphBlock after:
               [000066] D----+-N---                         *  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            *    long   V06.m_handle (offs=0x00) -> V10 tmp7         
PrepareDst for [000066] have found a local var V06.
MorphBlock for src tree, before:
               [000093] ---XG+-----                         *  IND       struct
               [000103] -----+-----                         \--*  ADD       byref 
               [000059] -----+-----                            +--*  LCL_VAR   ref    V07 tmp4         
               [000102] -----+-----                            \--*  CNS_INT   long   80 field offset Fseq[m_value]
MorphBlock after:
               [000093] ---XG+-----                         *  IND       struct
               [000103] -----+-----                         \--*  ADD       byref 
               [000059] -----+-----                            +--*  LCL_VAR   ref    V07 tmp4         
               [000102] -----+-----                            \--*  CNS_INT   long   80 field offset Fseq[m_value]
block assignment to morph:
               [000068] -A-XG------                         *  ASG       struct (copy)
               [000066] D----+-N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000093] ---XG+-----                         \--*  IND       struct
               [000103] -----+-----                            \--*  ADD       byref 
               [000059] -----+-----                               +--*  LCL_VAR   ref    V07 tmp4         
               [000102] -----+-----                               \--*  CNS_INT   long   80 field offset Fseq[m_value]
 (m_dstDoFldAsg=true) using field by field assignments.

fgAddFieldSeqForZeroOffset for Fseq[m_handle]
addr (Before)
               [000103] -----+-----                           ADD       byref 
     (After)
               [000102] -----+-----                           CNS_INT   long  
MorphCopyBlock (after):
               [000106] -A-X-+-----                         *  ASG       long  
               [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         
               [000105] ---X-------                         \--*  IND       long  
               [000103] -----+-----                            \--*  ADD       byref 
               [000059] -----+-----                               +--*  LCL_VAR   ref    V07 tmp4         
               [000102] -----+-----                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle]

fgMorphTree BB15, STMT00018 (after)
               [000106] -A-X-+-----                         *  ASG       long  
               [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         
               [000105] ---X-------                         \--*  IND       long  
               [000103] -----+-----                            \--*  ADD       byref 
               [000059] -----+-----                               +--*  LCL_VAR   ref    V07 tmp4         
               [000102] -----+-----                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle]

Morphing BB16 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

fgMorphTree BB16, STMT00019 (before)
               [000071] -ACXG------                         *  ASG       struct (copy)
               [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] ----------- this                       \--*  LCL_VAR   ref    V07 tmp4         
Initializing arg info for 32.CALL:
Args for call [000032] CALL after AddFinalArgsAndDetermineABIInfo:
CallArg[[000053].LCL_VAR ref (By value), 1 reg: rcx, byteAlignment=8, wellKnown[ThisPointer]]
CallArg[[000107].CNS_INT long (By value), 1 reg: r11, byteAlignment=8, wellKnown[VirtualStubCell]]

Morphing args for 32.CALL:

Sorting the arguments:
Deferred argument ('rcx'):
               [000053] -----+-----                         *  LCL_VAR   ref    V07 tmp4         
Moved to late list
Deferred argument ('r11'):
               [000107] H----+-----                         *  CNS_INT(h) long   0x4000000000424a90 ftn REG r11
Moved to late list

Shuffled argument table:    rcx r11 
Args for [000032].CALL after fgMorphArgs:
CallArg[[000053].LCL_VAR ref (By value), 1 reg: rcx, byteAlignment=8, isLate, processed, wellKnown[ThisPointer]]
CallArg[[000107].CNS_INT long (By value), 1 reg: r11, byteAlignment=8, isLate, processed, wellKnown[VirtualStubCell]]
OutgoingArgsStackSize is 32

GenTreeNode creates assertion:
               [000032] --CXG--N---                         *  CALLV stub struct System.IRuntimeMethodInfo.get_Value
In BB16 New Local Constant Assertion: V07 != null, index = #01
MorphCopyBlock:
MorphBlock for dst tree, before:
               [000069] D----+-N---                         *  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            *    long   V06.m_handle (offs=0x00) -> V10 tmp7         
MorphBlock after:
               [000069] D----+-N---                         *  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            *    long   V06.m_handle (offs=0x00) -> V10 tmp7         
PrepareDst for [000069] have found a local var V06.
MorphBlock for src tree, before:
               [000032] --CXG+-N---                         *  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] -----+----- this in rcx             +--*  LCL_VAR   ref    V07 tmp4         
               [000107] H----+----- vsd cell in r11         \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11
MorphBlock after:
               [000032] --CXG+-N---                         *  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] -----+----- this in rcx             +--*  LCL_VAR   ref    V07 tmp4         
               [000107] H----+----- vsd cell in r11         \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11
Not morphing a single reg call return
MorphCopyBlock (after):
               [000071] -ACXG------                         *  ASG       struct (copy)
               [000069] D----+-N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000032] --CXG+-N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] -----+----- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         
               [000107] H----+----- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11

fgMorphTree BB16, STMT00019 (after)
               [000071] -ACXG+-----                         *  ASG       struct (copy)
               [000069] D----+-N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000032] --CXG+-N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] -----+----- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         
               [000107] H----+----- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11

Morphing BB17 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

fgMorphTree BB17, STMT00008 (before)
               [000037] -ACXG------                         *  ASG       struct (copy)
               [000036] ---XG------                         +--*  BLK       struct<System.RuntimeMethodHandleInternal, 8>
               [000035] ---XG------                         |  \--*  ADDR      byref 
               [000034] ---XG--N---                         |     \--*  FIELD     struct m_methodHandle
               [000029] -----------                         |        \--*  LCL_VAR   ref    V02 loc1         
               [000047] -----------                         \--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            \--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         

Final value of Compiler::fgMorphField after calling fgMorphSmpOp:
               [000034] ---XG--N---                         *  IND       struct
               [000109] -----+-----                         \--*  ADD       byref 
               [000029] -----+-----                            +--*  LCL_VAR   ref    V02 loc1         
               [000108] -----+-----                            \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle]
GenTreeNode creates assertion:
               [000036] ---XG------                         *  BLK       struct<System.RuntimeMethodHandleInternal, 8>
In BB17 New Local Constant Assertion: V02 != null, index = #01
MorphCopyBlock:
MorphBlock for dst tree, before:
               [000036] ---XG+-----                         *  BLK       struct<System.RuntimeMethodHandleInternal, 8>
               [000109] -----+-----                         \--*  ADD       byref 
               [000029] -----+-----                            +--*  LCL_VAR   ref    V02 loc1         
               [000108] -----+-----                            \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle]
MorphBlock after:
               [000036] ---XG+-----                         *  BLK       struct<System.RuntimeMethodHandleInternal, 8>
               [000109] -----+-----                         \--*  ADD       byref 
               [000029] -----+-----                            +--*  LCL_VAR   ref    V02 loc1         
               [000108] -----+-----                            \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle]
PrepareDst for [000036] have not found a local var.
MorphBlock for src tree, before:
               [000047] -----+-----                         *  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            *    long   V06.m_handle (offs=0x00) -> V10 tmp7         
MorphBlock after:
               [000047] -----+-----                         *  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            *    long   V06.m_handle (offs=0x00) -> V10 tmp7         
block assignment to morph:
               [000037] -A-XG------                         *  ASG       struct (copy)
               [000036] ---XG+-----                         +--*  BLK       struct<System.RuntimeMethodHandleInternal, 8>
               [000109] -----+-----                         |  \--*  ADD       byref 
               [000029] -----+-----                         |     +--*  LCL_VAR   ref    V02 loc1         
               [000108] -----+-----                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle]
               [000047] -----+-----                         \--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            \--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
 (m_srcDoFldAsg=true) using field by field assignments.

fgAddFieldSeqForZeroOffset for Fseq[m_handle]
addr (Before)
               [000109] -----+-----                           ADD       byref 
     (After)
               [000108] -----+-----                           CNS_INT   long  
MorphCopyBlock (after):
               [000112] -A-X-+-----                         *  ASG       long  
               [000110] ---X---N---                         +--*  IND       long  
               [000109] -----+-----                         |  \--*  ADD       byref 
               [000029] -----+-----                         |     +--*  LCL_VAR   ref    V02 loc1         
               [000108] -----+-----                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle]
               [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         

fgMorphTree BB17, STMT00008 (after)
               [000112] -A-X-+-----                         *  ASG       long  
               [000110] ---X---N---                         +--*  IND       long  
               [000109] -----+-----                         |  \--*  ADD       byref 
               [000029] -----+-----                         |     +--*  LCL_VAR   ref    V02 loc1         
               [000108] -----+-----                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle]
               [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         

Morphing BB18 of 'System.Reflection.Emit.DynamicResolver:Finalize():this'

fgMorphTree BB18, STMT00009 (before)
               [000038] -----------                         *  RETURN    void  

*************** In fgMarkDemotedImplicitByRefArgs()
Method has EH, marking method as fully interruptible

*************** Finishing PHASE Morph - Global
Trees after Morph - Global

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                            85     85    [000..010)-> BB05 ( cond )                     keep i IBC 
BB04 [0024]  1       BB01                 53.76  54    [007..008)-> BB06 (always)                     i IBC 
BB05 [0025]  1       BB01                 18.47  18    [007..008)                                     i IBC 
BB06 [0031]  2       BB04,BB05            85     85    [???..???)-> BB08 ( cond )                     keep internal IBC 
BB07 [0001]  1       BB06                  0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB08 [0002]  1       BB06                 85     85    [012..01A)-> BB11 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB18 (always)                     i rare IBC 
BB11 [0005]  1  0    BB08                 85     85    [01C..025)-> BB14 (always) T0      try { }     keep i try hascall newobj IBC 
BB12 [0006]  1     0                       1           [025..02E)-> BB13 ( cret )    H0   catch { }   keep i hascall gcsafe 
BB13 [0012]  1       BB12                  1           [???..???)-> BB18 (always)                     i internal 
BB14 [0007]  1       BB11                 85     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                 85     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB17 [0019]  2       BB15,BB16            85     85    [02E..041)                                     i internal IBC 
BB18 [0017]  4       BB07,BB09,BB13,BB17  85     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB05 (cond), preds={} succs={BB04,BB05}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
               [000003] -A-XG+-----                         *  ASG       ref   
               [000002] D----+-N---                         +--*  LCL_VAR   ref    V01 loc0         
               [000001] ---XG+-----                         \--*  IND       ref   
               [000097] -----+-----                            \--*  ADD       byref 
               [000000] -----+-----                               +--*  LCL_VAR   ref    V00 this         
               [000096] -----+-----                               \--*  CNS_INT   long   24 field offset Fseq[m_method]

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000078] -----+-----                         *  JTRUE     void  
               [000077] J----+-N---                         \--*  EQ        int   
               [000004] -----+-----                            +--*  LCL_VAR   ref    V01 loc0         
               [000076] -----+-----                            \--*  CNS_INT   ref    null

------------ BB04 [007..008) -> BB06 (always), preds={BB01} succs={BB06}

***** BB04
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000087] -A---+-----                         *  ASG       bool  
               [000086] D----+-N---                         +--*  LCL_VAR   int    V09 tmp6         
               [000085] -----+-----                         \--*  CNS_INT   int    0

------------ BB05 [007..008), preds={BB01} succs={BB06}

***** BB05
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000082] -A---+-----                         *  ASG       bool  
               [000081] D----+-N---                         +--*  LCL_VAR   int    V09 tmp6         
               [000080] -----+-----                         \--*  CNS_INT   int    1

------------ BB06 [???..???) -> BB08 (cond), preds={BB04,BB05} succs={BB07,BB08}

***** BB06
STMT00002 ( 0x007[E-] ... ??? )
               [000011] -----+-----                         *  JTRUE     void  
               [000010] J----+-N---                         \--*  EQ        int   
               [000088] -----+-----                            +--*  LCL_VAR   bool   V09 tmp6         
               [000009] -----+-----                            \--*  CNS_INT   int    0

------------ BB07 [010..012) -> BB18 (always), preds={BB06} succs={BB18}

------------ BB08 [012..01A) -> BB11 (cond), preds={BB06} succs={BB09,BB11}

***** BB08
STMT00003 ( 0x012[E-] ... 0x018 )
               [000016] ---XG+-----                         *  JTRUE     void  
               [000015] J--XG+-N---                         \--*  NE        int   
               [000013] ---XG+-----                            +--*  IND       ref   
               [000099] -----+-----                            |  \--*  ADD       byref 
               [000012] -----+-----                            |     +--*  LCL_VAR   ref    V01 loc0         
               [000098] -----+-----                            |     \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]
               [000014] -----+-----                            \--*  CNS_INT   ref    null

------------ BB09 [01A..01C) -> BB18 (always), preds={BB08} succs={BB18}

------------ BB11 [01C..025) -> BB14 (always), preds={BB08} succs={BB14}

***** BB11
STMT00006 ( 0x022[--] ... ??? )
               [000028] -AC--+-----                         *  ASG       ref   
               [000027] D----+-N---                         +--*  LCL_VAR   ref    V02 loc1         
               [000021] --C--+-----                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW

------------ BB12 [025..02E) -> BB13 (cret), preds={} succs={BB13}

***** BB12
STMT00010 ( 0x025[--] ... 0x02C )
               [000040] -A---+-----                         *  ASG       ref   
               [000039] D----+-N---                         +--*  LCL_VAR   ref    V05 tmp2         
               [000018] -----+-----                         \--*  CATCH_ARG ref   

***** BB12
STMT00011 ( 0x026[E-] ... ??? )
               [000043] --CXG+-----                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
               [000042] -----+----- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         

------------ BB13 [???..???) -> BB18 (always), preds={BB12} succs={BB18}

------------ BB14 [02E..02E) -> BB16 (cond), preds={BB11} succs={BB15,BB16}

***** BB14
STMT00014 ( 0x02E[E-] ... ??? )
               [000051] -A-XG+-----                         *  ASG       ref   
               [000050] D----+-N---                         +--*  LCL_VAR   ref    V07 tmp4         
               [000048] ---XG+-----                         \--*  IND       ref   
               [000101] -----+-----                            \--*  ADD       byref 
               [000049] -----+-----                               +--*  LCL_VAR   ref    V01 loc0         
               [000100] -----+-----                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]

***** BB14
STMT00015 ( 0x02E[E-] ... ??? )
               [000058] ---X-+-----                         *  JTRUE     void  
               [000057] J--X-+-N---                         \--*  NE        int   
               [000056] #----+-----                            +--*  IND       long  
               [000055] H----+-----                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
               [000054] #--X-+-----                            \--*  IND       long  
               [000052] -----+-----                               \--*  LCL_VAR   ref    V07 tmp4         

------------ BB15 [???..???) -> BB17 (always), preds={BB14} succs={BB17}

***** BB15
STMT00018 ( ??? ... ??? )
               [000106] -A-X-+-----                         *  ASG       long  
               [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         
               [000105] ---X-------                         \--*  IND       long  
               [000103] -----+-----                            \--*  ADD       byref 
               [000059] -----+-----                               +--*  LCL_VAR   ref    V07 tmp4         
               [000102] -----+-----                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle]

------------ BB16 [???..???), preds={BB14} succs={BB17}

***** BB16
STMT00019 ( 0x02E[E-] ... ??? )
               [000071] -ACXG+-----                         *  ASG       struct (copy)
               [000069] D----+-N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000032] --CXG+-N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] -----+----- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         
               [000107] H----+----- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11

------------ BB17 [02E..041), preds={BB15,BB16} succs={BB18}

***** BB17
STMT00008 ( 0x02E[E-] ... ??? )
               [000112] -A-X-+-----                         *  ASG       long  
               [000110] ---X---N---                         +--*  IND       long  
               [000109] -----+-----                         |  \--*  ADD       byref 
               [000029] -----+-----                         |     +--*  LCL_VAR   ref    V02 loc1         
               [000108] -----+-----                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle]
               [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         

------------ BB18 [048..049) (return), preds={BB07,BB09,BB13,BB17} succs={}

***** BB18
STMT00009 ( 0x048[E-] ... 0x048 )
               [000038] -----+-----                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE GS Cookie
No GS security needed

*************** Finishing PHASE GS Cookie

*************** Starting PHASE Compute edge weights (1, false)
*************** In fgComputeBlockAndEdgeWeights()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             0.85  85    [000..010)-> BB05 ( cond )                     keep i IBC 
BB04 [0024]  1       BB01                  0.54  54    [007..008)-> BB06 (always)                     i IBC 
BB05 [0025]  1       BB01                  0.18  18    [007..008)                                     i IBC 
BB06 [0031]  2       BB04,BB05             0.85  85    [???..???)-> BB08 ( cond )                     keep internal IBC 
BB07 [0001]  1       BB06                  0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB08 [0002]  1       BB06                  0.85  85    [012..01A)-> BB11 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB18 (always)                     i rare IBC 
BB11 [0005]  1  0    BB08                  0.85  85    [01C..025)-> BB14 (always) T0      try { }     keep i try hascall newobj IBC 
BB12 [0006]  1     0                       0.01        [025..02E)-> BB13 ( cret )    H0   catch { }   keep i hascall gcsafe 
BB13 [0012]  1       BB12                  0.01        [???..???)-> BB18 (always)                     i internal 
BB14 [0007]  1       BB11                  0.85  85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                  0.85  85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB17 [0019]  2       BB15,BB16             0.85  85    [02E..041)                                     i internal IBC 
BB18 [0017]  4       BB07,BB09,BB13,BB17   0.85  85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

We are using the Profile Weights and fgCalledCount is 85
Initial weight assignments

Updated max weight of BB01 -> BB04 to [0..85]
Updated max weight of BB01 -> BB04 to [0..53.76103]
Updated max weight of BB01 -> BB05 to [0..85]
Updated max weight of BB01 -> BB05 to [0..18.46684]
Updated min weight of BB04 -> BB06 to [53.76103..3.402823e+38]
Updated max weight of BB04 -> BB06 to [53.76103..53.76103]
Updated min weight of BB05 -> BB06 to [18.46684..3.402823e+38]
Updated max weight of BB05 -> BB06 to [18.46684..18.46684]
Updated max weight of BB06 -> BB07 to [0..85]
Updated max weight of BB06 -> BB07 to [0..0]
Updated max weight of BB06 -> BB08 to [0..85]
Updated max weight of BB08 -> BB09 to [0..85]
Updated max weight of BB08 -> BB09 to [0..0]
Updated max weight of BB08 -> BB11 to [0..85]
Setting edge weights for BB12 -> BB13 to [0 .. 3.402823e+38]
Updated min weight of BB12 -> BB13 to [1..3.402823e+38]
Updated max weight of BB12 -> BB13 to [1..1]
Updated min weight of BB11 -> BB14 to [85..3.402823e+38]
Updated max weight of BB11 -> BB14 to [85..85]
Updated max weight of BB14 -> BB15 to [0..85]
Updated max weight of BB14 -> BB16 to [0..85]
Updated max weight of BB14 -> BB16 to [0..0]
Updated min weight of BB15 -> BB17 to [85..3.402823e+38]
Updated max weight of BB15 -> BB17 to [85..85]
Updated min weight of BB16 -> BB17 to [0..3.402823e+38]
Updated max weight of BB16 -> BB17 to [0..0]
Updated min weight of BB07 -> BB18 to [0..3.402823e+38]
Updated max weight of BB07 -> BB18 to [0..0]
Updated min weight of BB09 -> BB18 to [0..3.402823e+38]
Updated max weight of BB09 -> BB18 to [0..0]
Setting edge weights for BB13 -> BB18 to [0 .. 3.402823e+38]
Updated min weight of BB13 -> BB18 to [1..3.402823e+38]
Updated max weight of BB13 -> BB18 to [1..1]
Updated min weight of BB17 -> BB18 to [85..3.402823e+38]
Updated max weight of BB17 -> BB18 to [85..85]

Solver pass 0

 -- step 1 --
Not adjusting min weight of BB01 -> BB04; new value 66.53316 not in range [0..53.76103] (+/- 2.164062)
Not adjusting min weight of BB01 -> BB05; new value 31.23897 not in range [0..18.46684] (+/- 2.164062)
fgComputeEdgeWeights() found inconsistent profile data, not using the edge weights

*************** Finishing PHASE Compute edge weights (1, false)

*************** Starting PHASE Create EH funclets
*************** In fgCreateFunclets()
Relocating handler range BB12..BB12 (EH#0) to end of BBlist

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB05 ( cond )                     keep i IBC 
BB04 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 (always)                     i IBC 
BB05 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB06 [0031]  2       BB04,BB05             1     85    [???..???)-> BB08 ( cond )                     keep internal IBC 
BB07 [0001]  1       BB06                  0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB08 [0002]  1       BB06                  1     85    [012..01A)-> BB11 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB18 (always)                     i rare IBC 
BB11 [0005]  1  0    BB08                  1     85    [01C..025)-> BB14 (always) T0      try { }     keep i try hascall newobj IBC 
BB12 [0006]  1     0                       0.01        [025..02E)-> BB13 ( cret )    H0   catch { }   keep i hascall gcsafe 
BB13 [0012]  1       BB12                  0.01        [???..???)-> BB18 (always)                     i internal 
BB14 [0007]  1       BB11                  1     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                  1     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB17 [0019]  2       BB15,BB16             1     85    [02E..041)                                     i internal IBC 
BB18 [0017]  4       BB07,BB09,BB13,BB17   1     85    [048..049)        (return)                     i IBC 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB11..BB11 [01D..025), Handler at BB12..BB12 [025..02E)
Relocated block [BB12..BB12] inserted after BB18 at the end of method
Create funclets: moved region

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB11..BB11 [01D..025), Handler at BB12..BB12 [025..02E)

After fgCreateFunclets()
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB05 ( cond )                     keep i IBC 
BB04 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 (always)                     i IBC 
BB05 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB06 [0031]  2       BB04,BB05             1     85    [???..???)-> BB08 ( cond )                     keep internal IBC 
BB07 [0001]  1       BB06                  0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB08 [0002]  1       BB06                  1     85    [012..01A)-> BB11 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB18 (always)                     i rare IBC 
BB11 [0005]  1  0    BB08                  1     85    [01C..025)-> BB14 (always) T0      try { }     keep i try hascall newobj IBC 
BB13 [0012]  1       BB12                  0.01        [???..???)-> BB18 (always)                     i internal 
BB14 [0007]  1       BB11                  1     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                  1     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB17 [0019]  2       BB15,BB16             1     85    [02E..041)                                     i internal IBC 
BB18 [0017]  4       BB07,BB09,BB13,BB17   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB12 [0006]  1     0                       0.01        [025..02E)-> BB13 ( cret )    H0 F catch { }   keep i hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB11..BB11 [01D..025), Handler at BB12..BB12 [025..02E)
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Create EH funclets

*************** Starting PHASE Invert loops

*************** Finishing PHASE Invert loops [no changes]

*************** Starting PHASE Optimize control flow

*************** In fgUpdateFlowGraph()
Before updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB05 ( cond )                     keep i IBC 
BB04 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 (always)                     i IBC 
BB05 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB06 [0031]  2       BB04,BB05             1     85    [???..???)-> BB08 ( cond )                     keep internal IBC 
BB07 [0001]  1       BB06                  0      0    [010..012)-> BB18 (always)                     i rare IBC 
BB08 [0002]  1       BB06                  1     85    [012..01A)-> BB11 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB18 (always)                     i rare IBC 
BB11 [0005]  1  0    BB08                  1     85    [01C..025)-> BB14 (always) T0      try { }     keep i try hascall newobj IBC 
BB13 [0012]  1       BB12                  0.01        [???..???)-> BB18 (always)                     i internal 
BB14 [0007]  1       BB11                  1     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                  1     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB17 [0019]  2       BB15,BB16             1     85    [02E..041)                                     i internal IBC 
BB18 [0017]  4       BB07,BB09,BB13,BB17   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB12 [0006]  1     0                       0.01        [025..02E)-> BB13 ( cret )    H0 F catch { }   keep i hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

Considering uncond to cond BB04 -> BB06
Setting edge weights for BB04 -> BB08 to [0 .. 3.402823e+38]
New Basic Block BB23 [0036] created.
Setting edge weights for BB04 -> BB23 to [0 .. 3.402823e+38]
Setting edge weights for BB23 -> BB07 to [0 .. 3.402823e+38]
fgOptimizeUncondBranchToSimpleCond(from BB04 to cond BB06), created new uncond BB23
   expecting opts to key off V09 in BB04
Considering uncond to cond BB23 -> BB07

Optimizing a jump to an unconditional jump (BB23 -> BB07 -> BB18)
Setting edge weights for BB23 -> BB18 to [0 .. 3.402823e+38]
Considering uncond to cond BB23 -> BB18
Considering uncond to cond BB05 -> BB06

Reversing a conditional jump around an unconditional jump (BB06 -> BB08, BB07 -> BB18)
Setting edge weights for BB06 -> BB18 to [0 .. 3.402823e+38]

After reversing the jump:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB05 ( cond )                     keep i IBC 
BB04 [0024]  1       BB01                  0.63  54    [007..008)-> BB08 ( cond )                     i IBC 
BB23 [0036]  1       BB04                  0.63  54    [???..???)-> BB18 (always)                     internal IBC 
BB05 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB06 [0031]  1       BB05                  1     85    [???..???)-> BB18 ( cond )                     keep internal IBC 
BB08 [0002]  2       BB04,BB06             1     85    [012..01A)-> BB11 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB18 (always)                     i rare IBC 
BB11 [0005]  1  0    BB08                  1     85    [01C..025)-> BB14 (always) T0      try { }     keep i try hascall newobj IBC 
BB13 [0012]  1       BB12                  0.01        [???..???)-> BB18 (always)                     i internal 
BB14 [0007]  1       BB11                  1     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                  1     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB17 [0019]  2       BB15,BB16             1     85    [02E..041)                                     i internal IBC 
BB18 [0017]  5       BB06,BB09,BB13,BB17,BB23   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB12 [0006]  1     0                       0.01        [025..02E)-> BB13 ( cret )    H0 F catch { }   keep i hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------
Considering uncond to cond BB09 -> BB18
Considering uncond to cond BB11 -> BB14
Considering uncond to cond BB13 -> BB18
Considering uncond to cond BB15 -> BB17
Considering uncond to cond BB16 -> BB17
Considering uncond to cond BB17 -> BB18
Considering uncond to cond BB23 -> BB18
Considering uncond to cond BB05 -> BB06
Considering uncond to cond BB09 -> BB18
Considering uncond to cond BB11 -> BB14
Considering uncond to cond BB13 -> BB18
Considering uncond to cond BB15 -> BB17
Considering uncond to cond BB16 -> BB17
Considering uncond to cond BB17 -> BB18

After updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB05 ( cond )                     keep i IBC 
BB04 [0024]  1       BB01                  0.63  54    [007..008)-> BB08 ( cond )                     i IBC 
BB23 [0036]  1       BB04                  0.63  54    [???..???)-> BB18 (always)                     internal IBC 
BB05 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB06 [0031]  1       BB05                  1     85    [???..???)-> BB18 ( cond )                     keep internal IBC 
BB08 [0002]  2       BB04,BB06             1     85    [012..01A)-> BB11 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB18 (always)                     i rare IBC 
BB11 [0005]  1  0    BB08                  1     85    [01C..025)-> BB14 (always) T0      try { }     keep i try hascall newobj IBC 
BB13 [0012]  1       BB12                  0.01        [???..???)-> BB18 (always)                     i internal 
BB14 [0007]  1       BB11                  1     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                  1     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB17 [0019]  2       BB15,BB16             1     85    [02E..041)                                     i internal IBC 
BB18 [0017]  5       BB06,BB09,BB13,BB17,BB23   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB12 [0006]  1     0                       0.01        [025..02E)-> BB13 ( cret )    H0 F catch { }   keep i hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB11..BB11 [01D..025), Handler at BB12..BB12 [025..02E)
*************** In fgDebugCheckBBlist

*************** In fgExpandRarelyRunBlocks()
*************** In fgReorderBlocks()

Initial BasicBlocks
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB05 ( cond )                     keep i IBC 
BB04 [0024]  1       BB01                  0.63  54    [007..008)-> BB08 ( cond )                     i IBC 
BB23 [0036]  1       BB04                  0.63  54    [???..???)-> BB18 (always)                     internal IBC 
BB05 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB06 [0031]  1       BB05                  1     85    [???..???)-> BB18 ( cond )                     keep internal IBC 
BB08 [0002]  2       BB04,BB06             1     85    [012..01A)-> BB11 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB18 (always)                     i rare IBC 
BB11 [0005]  1  0    BB08                  1     85    [01C..025)-> BB14 (always) T0      try { }     keep i try hascall newobj IBC 
BB13 [0012]  1       BB12                  0.01        [???..???)-> BB18 (always)                     i internal 
BB14 [0007]  1       BB11                  1     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                  1     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB17 [0019]  2       BB15,BB16             1     85    [02E..041)                                     i internal IBC 
BB18 [0017]  5       BB06,BB09,BB13,BB17,BB23   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB12 [0006]  1     0                       0.01        [025..02E)-> BB13 ( cret )    H0 F catch { }   keep i hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------


*************** In fgUpdateFlowGraph()
Before updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB05 ( cond )                     keep i IBC 
BB04 [0024]  1       BB01                  0.63  54    [007..008)-> BB08 ( cond )                     i IBC 
BB23 [0036]  1       BB04                  0.63  54    [???..???)-> BB18 (always)                     internal IBC 
BB05 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB06 [0031]  1       BB05                  1     85    [???..???)-> BB18 ( cond )                     keep internal IBC 
BB08 [0002]  2       BB04,BB06             1     85    [012..01A)-> BB11 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB18 (always)                     i rare IBC 
BB11 [0005]  1  0    BB08                  1     85    [01C..025)-> BB14 (always) T0      try { }     keep i try hascall newobj IBC 
BB13 [0012]  1       BB12                  0.01        [???..???)-> BB18 (always)                     i internal 
BB14 [0007]  1       BB11                  1     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                  1     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB17 [0019]  2       BB15,BB16             1     85    [02E..041)                                     i internal IBC 
BB18 [0017]  5       BB06,BB09,BB13,BB17,BB23   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB12 [0006]  1     0                       0.01        [025..02E)-> BB13 ( cret )    H0 F catch { }   keep i hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** In fgDebugCheckBBlist

*************** Finishing PHASE Optimize control flow

*************** Starting PHASE Compute blocks reachability
*************** In fgComputeReachability
*************** In fgDebugCheckBBlist
Return blocks: BB18

Renumbering the basic blocks for fgComputeReachability pass #1

*************** Before renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB05 ( cond )                     keep i IBC 
BB04 [0024]  1       BB01                  0.63  54    [007..008)-> BB08 ( cond )                     i IBC 
BB23 [0036]  1       BB04                  0.63  54    [???..???)-> BB18 (always)                     internal IBC 
BB05 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB06 [0031]  1       BB05                  1     85    [???..???)-> BB18 ( cond )                     keep internal IBC 
BB08 [0002]  2       BB04,BB06             1     85    [012..01A)-> BB11 ( cond )                     i IBC 
BB09 [0003]  1       BB08                  0      0    [01A..01C)-> BB18 (always)                     i rare IBC 
BB11 [0005]  1  0    BB08                  1     85    [01C..025)-> BB14 (always) T0      try { }     keep i try hascall newobj IBC 
BB13 [0012]  1       BB12                  0.01        [???..???)-> BB18 (always)                     i internal 
BB14 [0007]  1       BB11                  1     85    [02E..02E)-> BB16 ( cond )                     i IBC 
BB15 [0020]  1       BB14                  1     85    [???..???)-> BB17 (always)                     i internal IBC 
BB16 [0021]  1       BB14                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB17 [0019]  2       BB15,BB16             1     85    [02E..041)                                     i internal IBC 
BB18 [0017]  5       BB06,BB09,BB13,BB17,BB23   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB12 [0006]  1     0                       0.01        [025..02E)-> BB13 ( cret )    H0 F catch { }   keep i hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB11..BB11 [01D..025), Handler at BB12..BB12 [025..02E)
Renumber BB04 to BB02
Renumber BB23 to BB03
Renumber BB05 to BB04
Renumber BB06 to BB05
Renumber BB08 to BB06
Renumber BB09 to BB07
Renumber BB11 to BB08
Renumber BB13 to BB09
Renumber BB14 to BB10
Renumber BB15 to BB11
Renumber BB16 to BB12
Renumber BB17 to BB13
Renumber BB18 to BB14
Renumber BB12 to BB15

*************** After renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 ( cond )                     i IBC 
BB03 [0036]  1       BB02                  0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 ( cond )                     keep internal IBC 
BB06 [0002]  2       BB02,BB05             1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0.01        [???..???)-> BB14 (always)                     i internal 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0.01        [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB08..BB08 [01D..025), Handler at BB15..BB15 [025..02E)

New BlockSet epoch 5, # of blocks (including unused BB00): 16, bitset array size: 1 (short)
Enter blocks: BB01 BB15 

After computing reachability sets:
------------------------------------------------
BBnum  Reachable by 
------------------------------------------------
BB01 : BB01 
BB02 : BB01 BB02 
BB03 : BB01 BB02 BB03 
BB04 : BB01 BB04 
BB05 : BB01 BB04 BB05 
BB06 : BB01 BB02 BB04 BB05 BB06 
BB07 : BB01 BB02 BB04 BB05 BB06 BB07 
BB08 : BB01 BB02 BB04 BB05 BB06 BB08 
BB09 : BB09 BB15 
BB10 : BB01 BB02 BB04 BB05 BB06 BB08 BB10 
BB11 : BB01 BB02 BB04 BB05 BB06 BB08 BB10 BB11 
BB12 : BB01 BB02 BB04 BB05 BB06 BB08 BB10 BB12 
BB13 : BB01 BB02 BB04 BB05 BB06 BB08 BB10 BB11 BB12 BB13 
BB14 : BB01 BB02 BB03 BB04 BB05 BB06 BB07 BB08 BB09 BB10 BB11 BB12 BB13 BB14 BB15 
BB15 : BB15 

After computing reachability:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 ( cond )                     i IBC 
BB03 [0036]  1       BB02                  0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 ( cond )                     keep internal IBC 
BB06 [0002]  2       BB02,BB05             1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0.01        [???..???)-> BB14 (always)                     i internal gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0.01        [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** In fgDebugCheckBBlist
*************** In fgComputeDoms
*************** In fgDebugCheckBBlist

Dominator computation start blocks (those blocks with no incoming edges):
BB01 BB15 
------------------------------------------------
BBnum  Dominated by
------------------------------------------------
BB15:  BB15 
BB09:  BB09 BB15 
BB01:  BB01 
BB02:  BB02 BB01 
BB03:  BB03 BB02 BB01 
BB04:  BB04 BB01 
BB05:  BB05 BB04 BB01 
BB06:  BB06 BB01 
BB07:  BB07 BB06 BB01 
BB08:  BB08 BB06 BB01 
BB10:  BB10 BB08 BB06 BB01 
BB11:  BB11 BB10 BB08 BB06 BB01 
BB12:  BB12 BB10 BB08 BB06 BB01 
BB13:  BB13 BB10 BB08 BB06 BB01 
BB14:  BB14 

Inside fgBuildDomTree

After computing the Dominance Tree:
BB01 : BB06 BB04 BB02 
BB02 : BB03 
BB04 : BB05 
BB06 : BB08 BB07 
BB08 : BB10 
BB10 : BB13 BB12 BB11 
BB15 : BB09 


After numbering the dominator tree:
BB01: pre=01, post=12
BB02: pre=11, post=11
BB03: pre=12, post=10
BB04: pre=09, post=09
BB05: pre=10, post=08
BB06: pre=02, post=07
BB07: pre=08, post=06
BB08: pre=03, post=05
BB09: pre=15, post=14
BB10: pre=04, post=04
BB11: pre=07, post=03
BB12: pre=06, post=02
BB13: pre=05, post=01
BB14: pre=13, post=13
BB15: pre=14, post=15

*************** Finishing PHASE Compute blocks reachability

*************** Starting PHASE Set block weights
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Set block weights

*************** Starting PHASE Find loops
*************** In optFindLoops()
*************** In optMarkLoopHeads()
0 loop heads marked
*************** In fgDebugCheckLoopTable

*************** Finishing PHASE Find loops
Trees after Find loops

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 ( cond )                     i IBC 
BB03 [0036]  1       BB02                  0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 ( cond )                     keep internal IBC 
BB06 [0002]  2       BB02,BB05             1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
               [000003] -A-XG+-----                         *  ASG       ref   
               [000002] D----+-N---                         +--*  LCL_VAR   ref    V01 loc0         
               [000001] ---XG+-----                         \--*  IND       ref   
               [000097] -----+-----                            \--*  ADD       byref 
               [000000] -----+-----                               +--*  LCL_VAR   ref    V00 this         
               [000096] -----+-----                               \--*  CNS_INT   long   24 field offset Fseq[m_method]

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000078] -----+-----                         *  JTRUE     void  
               [000077] J----+-N---                         \--*  EQ        int   
               [000004] -----+-----                            +--*  LCL_VAR   ref    V01 loc0         
               [000076] -----+-----                            \--*  CNS_INT   ref    null

------------ BB02 [007..008) -> BB06 (cond), preds={BB01} succs={BB03,BB06}

***** BB02
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000087] -A---+-----                         *  ASG       bool  
               [000086] D----+-N---                         +--*  LCL_VAR   int    V09 tmp6         
               [000085] -----+-----                         \--*  CNS_INT   int    0

***** BB02
STMT00024 ( ??? ... ??? )
               [000113] -----------                         *  JTRUE     void  
               [000114] J------N---                         \--*  EQ        int   
               [000115] -----------                            +--*  LCL_VAR   bool   V09 tmp6         
               [000116] -----------                            \--*  CNS_INT   int    0

------------ BB03 [???..???) -> BB14 (always), preds={BB02} succs={BB14}

------------ BB04 [007..008), preds={BB01} succs={BB05}

***** BB04
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000082] -A---+-----                         *  ASG       bool  
               [000081] D----+-N---                         +--*  LCL_VAR   int    V09 tmp6         
               [000080] -----+-----                         \--*  CNS_INT   int    1

------------ BB05 [???..???) -> BB14 (cond), preds={BB04} succs={BB06,BB14}

***** BB05
STMT00002 ( 0x007[E-] ... ??? )
               [000011] -----+-----                         *  JTRUE     void  
               [000010] J----+-N---                         \--*  NE        int   
               [000088] -----+-----                            +--*  LCL_VAR   bool   V09 tmp6         
               [000009] -----+-----                            \--*  CNS_INT   int    0

------------ BB06 [012..01A) -> BB08 (cond), preds={BB02,BB05} succs={BB07,BB08}

***** BB06
STMT00003 ( 0x012[E-] ... 0x018 )
               [000016] ---XG+-----                         *  JTRUE     void  
               [000015] J--XG+-N---                         \--*  NE        int   
               [000013] ---XG+-----                            +--*  IND       ref   
               [000099] -----+-----                            |  \--*  ADD       byref 
               [000012] -----+-----                            |     +--*  LCL_VAR   ref    V01 loc0         
               [000098] -----+-----                            |     \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]
               [000014] -----+-----                            \--*  CNS_INT   ref    null

------------ BB07 [01A..01C) -> BB14 (always), preds={BB06} succs={BB14}

------------ BB08 [01C..025) -> BB10 (always), preds={BB06} succs={BB10}

***** BB08
STMT00006 ( 0x022[--] ... ??? )
               [000028] -AC--+-----                         *  ASG       ref   
               [000027] D----+-N---                         +--*  LCL_VAR   ref    V02 loc1         
               [000021] --C--+-----                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}

***** BB10
STMT00014 ( 0x02E[E-] ... ??? )
               [000051] -A-XG+-----                         *  ASG       ref   
               [000050] D----+-N---                         +--*  LCL_VAR   ref    V07 tmp4         
               [000048] ---XG+-----                         \--*  IND       ref   
               [000101] -----+-----                            \--*  ADD       byref 
               [000049] -----+-----                               +--*  LCL_VAR   ref    V01 loc0         
               [000100] -----+-----                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]

***** BB10
STMT00015 ( 0x02E[E-] ... ??? )
               [000058] ---X-+-----                         *  JTRUE     void  
               [000057] J--X-+-N---                         \--*  NE        int   
               [000056] #----+-----                            +--*  IND       long  
               [000055] H----+-----                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
               [000054] #--X-+-----                            \--*  IND       long  
               [000052] -----+-----                               \--*  LCL_VAR   ref    V07 tmp4         

------------ BB11 [???..???) -> BB13 (always), preds={BB10} succs={BB13}

***** BB11
STMT00018 ( ??? ... ??? )
               [000106] -A-X-+-----                         *  ASG       long  
               [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         
               [000105] ---X-------                         \--*  IND       long  
               [000103] -----+-----                            \--*  ADD       byref 
               [000059] -----+-----                               +--*  LCL_VAR   ref    V07 tmp4         
               [000102] -----+-----                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle]

------------ BB12 [???..???), preds={BB10} succs={BB13}

***** BB12
STMT00019 ( 0x02E[E-] ... ??? )
               [000071] -ACXG+-----                         *  ASG       struct (copy)
               [000069] D----+-N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000032] --CXG+-N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] -----+----- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         
               [000107] H----+----- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}

***** BB13
STMT00008 ( 0x02E[E-] ... ??? )
               [000112] -A-X-+-----                         *  ASG       long  
               [000110] ---X---N---                         +--*  IND       long  
               [000109] -----+-----                         |  \--*  ADD       byref 
               [000029] -----+-----                         |     +--*  LCL_VAR   ref    V02 loc1         
               [000108] -----+-----                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle]
               [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         

------------ BB14 [048..049) (return), preds={BB03,BB05,BB07,BB09,BB13} succs={}

***** BB14
STMT00009 ( 0x048[E-] ... 0x048 )
               [000038] -----+-----                         *  RETURN    void  

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}

***** BB15
STMT00010 ( 0x025[--] ... 0x02C )
               [000040] -A---+-----                         *  ASG       ref   
               [000039] D----+-N---                         +--*  LCL_VAR   ref    V05 tmp2         
               [000018] -----+-----                         \--*  CATCH_ARG ref   

***** BB15
STMT00011 ( 0x026[E-] ... ??? )
               [000043] --CXG+-----                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
               [000042] -----+----- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE Clone loops

*************** In optCloneLoops()
  No loops to clone

*************** Finishing PHASE Clone loops [no changes]

*************** Starting PHASE Unroll loops

*************** Finishing PHASE Unroll loops [no changes]

*************** Starting PHASE Clear loop info

*************** Finishing PHASE Clear loop info

*************** Starting PHASE Mark local vars

*************** In lvaMarkLocalVars()
lvaGrabTemp returning 11 (V11 tmp8) (a long lifetime temp) called for PSPSym.

Local V11 should not be enregistered because: VM needs stack addr

*** lvaComputeRefCounts ***

*** lvaComputeRefCounts -- explicit counts ***

*** marking local variables in block BB01 (weight=1   )
STMT00000 ( 0x000[E-] ... 0x006 )
               [000003] -A-XG+-----                         *  ASG       ref   
               [000002] D----+-N---                         +--*  LCL_VAR   ref    V01 loc0         
               [000001] ---XG+-----                         \--*  IND       ref   
               [000097] -----+-----                            \--*  ADD       byref 
               [000000] -----+-----                               +--*  LCL_VAR   ref    V00 this         
               [000096] -----+-----                               \--*  CNS_INT   long   24 field offset Fseq[m_method]
New refCnts for V01: refCnt =  1, refCntWtd = 1   
Marking EH Var V01 as a register candidate.
New refCnts for V00: refCnt =  1, refCntWtd = 1   
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000078] -----+-----                         *  JTRUE     void  
               [000077] J----+-N---                         \--*  EQ        int   
               [000004] -----+-----                            +--*  LCL_VAR   ref    V01 loc0         
               [000076] -----+-----                            \--*  CNS_INT   ref    null
New refCnts for V01: refCnt =  2, refCntWtd = 2   

*** marking local variables in block BB02 (weight=0.63)
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000087] -A---+-----                         *  ASG       bool  
               [000086] D----+-N---                         +--*  LCL_VAR   int    V09 tmp6         
               [000085] -----+-----                         \--*  CNS_INT   int    0
New refCnts for V09: refCnt =  1, refCntWtd = 0.63
V09 needs explicit zero init. Disqualified as a single-def register candidate.
STMT00024 ( ??? ... ??? )
               [000113] -----------                         *  JTRUE     void  
               [000114] J------N---                         \--*  EQ        int   
               [000115] -----------                            +--*  LCL_VAR   bool   V09 tmp6         
               [000116] -----------                            \--*  CNS_INT   int    0
New refCnts for V09: refCnt =  2, refCntWtd = 1.26

*** marking local variables in block BB03 (weight=0.63)

*** marking local variables in block BB04 (weight=0.22)
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
               [000082] -A---+-----                         *  ASG       bool  
               [000081] D----+-N---                         +--*  LCL_VAR   int    V09 tmp6         
               [000080] -----+-----                         \--*  CNS_INT   int    1
New refCnts for V09: refCnt =  3, refCntWtd = 1.48

*** marking local variables in block BB05 (weight=1   )
STMT00002 ( 0x007[E-] ... ??? )
               [000011] -----+-----                         *  JTRUE     void  
               [000010] J----+-N---                         \--*  NE        int   
               [000088] -----+-----                            +--*  LCL_VAR   bool   V09 tmp6         
               [000009] -----+-----                            \--*  CNS_INT   int    0
New refCnts for V09: refCnt =  4, refCntWtd = 2.48

*** marking local variables in block BB06 (weight=1   )
STMT00003 ( 0x012[E-] ... 0x018 )
               [000016] ---XG+-----                         *  JTRUE     void  
               [000015] J--XG+-N---                         \--*  NE        int   
               [000013] ---XG+-----                            +--*  IND       ref   
               [000099] -----+-----                            |  \--*  ADD       byref 
               [000012] -----+-----                            |     +--*  LCL_VAR   ref    V01 loc0         
               [000098] -----+-----                            |     \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]
               [000014] -----+-----                            \--*  CNS_INT   ref    null
New refCnts for V01: refCnt =  3, refCntWtd = 3   

*** marking local variables in block BB07 (weight=0   )

*** marking local variables in block BB08 (weight=1   )
STMT00006 ( 0x022[--] ... ??? )
               [000028] -AC--+-----                         *  ASG       ref   
               [000027] D----+-N---                         +--*  LCL_VAR   ref    V02 loc1         
               [000021] --C--+-----                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW
New refCnts for V02: refCnt =  1, refCntWtd = 1   
Marking EH Var V02 as a register candidate.

*** marking local variables in block BB09 (weight=0   )

*** marking local variables in block BB10 (weight=1   )
STMT00014 ( 0x02E[E-] ... ??? )
               [000051] -A-XG+-----                         *  ASG       ref   
               [000050] D----+-N---                         +--*  LCL_VAR   ref    V07 tmp4         
               [000048] ---XG+-----                         \--*  IND       ref   
               [000101] -----+-----                            \--*  ADD       byref 
               [000049] -----+-----                               +--*  LCL_VAR   ref    V01 loc0         
               [000100] -----+-----                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]
New refCnts for V07: refCnt =  1, refCntWtd = 2   
Marking EH Var V07 as a register candidate.
New refCnts for V01: refCnt =  4, refCntWtd = 4   
STMT00015 ( 0x02E[E-] ... ??? )
               [000058] ---X-+-----                         *  JTRUE     void  
               [000057] J--X-+-N---                         \--*  NE        int   
               [000056] #----+-----                            +--*  IND       long  
               [000055] H----+-----                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
               [000054] #--X-+-----                            \--*  IND       long  
               [000052] -----+-----                               \--*  LCL_VAR   ref    V07 tmp4         
New refCnts for V07: refCnt =  2, refCntWtd = 4   

*** marking local variables in block BB11 (weight=1   )
STMT00018 ( ??? ... ??? )
               [000106] -A-X-+-----                         *  ASG       long  
               [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         
               [000105] ---X-------                         \--*  IND       long  
               [000103] -----+-----                            \--*  ADD       byref 
               [000059] -----+-----                               +--*  LCL_VAR   ref    V07 tmp4         
               [000102] -----+-----                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle]
New refCnts for V10: refCnt =  1, refCntWtd = 1   
V10 needs explicit zero init. Disqualified as a single-def register candidate.
New refCnts for V07: refCnt =  3, refCntWtd = 6   

*** marking local variables in block BB12 (weight=0   )
STMT00019 ( 0x02E[E-] ... ??? )
               [000071] -ACXG+-----                         *  ASG       struct (copy)
               [000069] D----+-N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
               [000032] --CXG+-N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
               [000053] -----+----- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         
               [000107] H----+----- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11
New refCnts for V10: refCnt =  2, refCntWtd = 1   
New refCnts for V06: refCnt =  0, refCntWtd = 0   
V06 needs explicit zero init. Disqualified as a single-def register candidate.
New refCnts for V07: refCnt =  4, refCntWtd = 6   

*** marking local variables in block BB13 (weight=1   )
STMT00008 ( 0x02E[E-] ... ??? )
               [000112] -A-X-+-----                         *  ASG       long  
               [000110] ---X---N---                         +--*  IND       long  
               [000109] -----+-----                         |  \--*  ADD       byref 
               [000029] -----+-----                         |     +--*  LCL_VAR   ref    V02 loc1         
               [000108] -----+-----                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle]
               [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         
New refCnts for V02: refCnt =  2, refCntWtd = 2   
New refCnts for V10: refCnt =  3, refCntWtd = 2   

*** marking local variables in block BB14 (weight=1   )
STMT00009 ( 0x048[E-] ... 0x048 )
               [000038] -----+-----                         *  RETURN    void  

*** marking local variables in block BB15 (weight=0   )
STMT00010 ( 0x025[--] ... 0x02C )
               [000040] -A---+-----                         *  ASG       ref   
               [000039] D----+-N---                         +--*  LCL_VAR   ref    V05 tmp2         
               [000018] -----+-----                         \--*  CATCH_ARG ref   
New refCnts for V05: refCnt =  1, refCntWtd = 0   
Marking EH Var V05 as a register candidate.
STMT00011 ( 0x026[E-] ... ??? )
               [000043] --CXG+-----                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
               [000042] -----+----- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         
New refCnts for V00: refCnt =  2, refCntWtd = 1   

*** lvaComputeRefCounts -- implicit counts ***
New refCnts for V00: refCnt =  3, refCntWtd = 2   
New refCnts for V00: refCnt =  4, refCntWtd = 3   

*************** In optAddCopies()


*************** Finishing PHASE Mark local vars

*************** Starting PHASE Optimize bools
*************** In optOptimizeBools()
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Optimize bools

*************** Starting PHASE Find oper order
*************** In fgFindOperOrder()

*************** Finishing PHASE Find oper order

*************** Starting PHASE Set block order
*************** In fgSetBlockOrder()
The biggest BB has    7 tree nodes

*************** Finishing PHASE Set block order
Trees before Build SSA representation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 ( cond )                     i IBC 
BB03 [0036]  1       BB02                  0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 ( cond )                     keep internal IBC 
BB06 [0002]  2       BB02,BB05             1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
N006 (  4,  4) [000003] -A-XG---R--                         *  ASG       ref   
N005 (  1,  1) [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         
N004 (  4,  4) [000001] ---XG------                         \--*  IND       ref   
N003 (  2,  2) [000097] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000000] -----------                               +--*  LCL_VAR   ref    V00 this         
N002 (  1,  1) [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method]

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
N004 (  5,  5) [000078] -----------                         *  JTRUE     void  
N003 (  3,  3) [000077] J------N---                         \--*  EQ        int   
N001 (  1,  1) [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         
N002 (  1,  1) [000076] -----------                            \--*  CNS_INT   ref    null

------------ BB02 [007..008) -> BB06 (cond), preds={BB01} succs={BB03,BB06}

***** BB02
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000087] -A------R--                         *  ASG       bool  
N002 (  3,  2) [000086] D------N---                         +--*  LCL_VAR   int    V09 tmp6         
N001 (  1,  1) [000085] -----------                         \--*  CNS_INT   int    0

***** BB02
STMT00024 ( ??? ... ??? )
N004 (  8,  7) [000113] -----------                         *  JTRUE     void  
N003 (  6,  5) [000114] J------N---                         \--*  EQ        int   
N001 (  4,  3) [000115] -----------                            +--*  LCL_VAR   bool   V09 tmp6         
N002 (  1,  1) [000116] -----------                            \--*  CNS_INT   int    0

------------ BB03 [???..???) -> BB14 (always), preds={BB02} succs={BB14}

------------ BB04 [007..008), preds={BB01} succs={BB05}

***** BB04
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000082] -A------R--                         *  ASG       bool  
N002 (  3,  2) [000081] D------N---                         +--*  LCL_VAR   int    V09 tmp6         
N001 (  1,  1) [000080] -----------                         \--*  CNS_INT   int    1

------------ BB05 [???..???) -> BB14 (cond), preds={BB04} succs={BB06,BB14}

***** BB05
STMT00002 ( 0x007[E-] ... ??? )
N004 (  8,  7) [000011] -----------                         *  JTRUE     void  
N003 (  6,  5) [000010] J------N---                         \--*  NE        int   
N001 (  4,  3) [000088] -----------                            +--*  LCL_VAR   bool   V09 tmp6         
N002 (  1,  1) [000009] -----------                            \--*  CNS_INT   int    0

------------ BB06 [012..01A) -> BB08 (cond), preds={BB02,BB05} succs={BB07,BB08}

***** BB06
STMT00003 ( 0x012[E-] ... 0x018 )
N007 (  8,  8) [000016] ---XG------                         *  JTRUE     void  
N006 (  6,  6) [000015] J--XG--N---                         \--*  NE        int   
N004 (  4,  4) [000013] ---XG------                            +--*  IND       ref   
N003 (  2,  2) [000099] -------N---                            |  \--*  ADD       byref 
N001 (  1,  1) [000012] -----------                            |     +--*  LCL_VAR   ref    V01 loc0         
N002 (  1,  1) [000098] -----------                            |     \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]
N005 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null

------------ BB07 [01A..01C) -> BB14 (always), preds={BB06} succs={BB14}

------------ BB08 [01C..025) -> BB10 (always), preds={BB06} succs={BB10}

***** BB08
STMT00006 ( 0x022[--] ... ??? )
N003 ( 18,  8) [000028] -AC-----R--                         *  ASG       ref   
N002 (  3,  2) [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         
N001 ( 14,  5) [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}

***** BB10
STMT00014 ( 0x02E[E-] ... ??? )
N006 (  4,  4) [000051] -A-XG---R--                         *  ASG       ref   
N005 (  1,  1) [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         
N004 (  4,  4) [000048] ---XG------                         \--*  IND       ref   
N003 (  2,  2) [000101] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000049] -----------                               +--*  LCL_VAR   ref    V01 loc0         
N002 (  1,  1) [000100] -----------                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]

***** BB10
STMT00015 ( 0x02E[E-] ... ??? )
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void  
N005 (  7,  9) [000057] J--X---N---                         \--*  NE        int   
N002 (  3,  6) [000056] #----------                            +--*  IND       long  
N001 (  1,  4) [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
N004 (  3,  2) [000054] #--X-------                            \--*  IND       long  
N003 (  1,  1) [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         

------------ BB11 [???..???) -> BB13 (always), preds={BB10} succs={BB13}

***** BB11
STMT00018 ( ??? ... ??? )
N006 (  8,  7) [000106] -A-X----R--                         *  ASG       long  
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         
N004 (  4,  4) [000105] ---X-------                         \--*  IND       long  
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle]

------------ BB12 [???..???), preds={BB10} succs={BB13}

***** BB12
STMT00019 ( 0x02E[E-] ... ??? )
N005 ( 26, 17) [000071] -ACXG---R--                         *  ASG       struct (copy)
N004 (  3,  2) [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
N003 ( 22, 14) [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
N001 (  1,  1) [000053] ----------- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         
N002 (  1,  4) [000107] H---------- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}

***** BB13
STMT00008 ( 0x02E[E-] ... ??? )
N006 ( 10,  8) [000112] -A-X-------                         *  ASG       long  
N004 (  6,  5) [000110] ---X---N---                         +--*  IND       long  
N003 (  4,  3) [000109] -------N---                         |  \--*  ADD       byref 
N001 (  3,  2) [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         
N002 (  1,  1) [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle]
N005 (  3,  2) [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         

------------ BB14 [048..049) (return), preds={BB03,BB05,BB07,BB09,BB13} succs={}

***** BB14
STMT00009 ( 0x048[E-] ... 0x048 )
N001 (  0,  0) [000038] -----------                         *  RETURN    void  

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}

***** BB15
STMT00010 ( 0x025[--] ... 0x02C )
N003 (  5,  4) [000040] -A---O--R--                         *  ASG       ref   
N002 (  3,  2) [000039] D------N---                         +--*  LCL_VAR   ref    V05 tmp2         
N001 (  1,  1) [000018] -----O-----                         \--*  CATCH_ARG ref   

***** BB15
STMT00011 ( 0x026[E-] ... ??? )
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
N001 (  1,  1) [000042] ----------- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Build SSA representation
*************** In SsaBuilder::Build()
[SsaBuilder] Max block count is 16.

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 ( cond )                     i IBC 
BB03 [0036]  1       BB02                  0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 ( cond )                     keep internal IBC 
BB06 [0002]  2       BB02,BB05             1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB08..BB08 [01D..025), Handler at BB15..BB15 [025..02E)
[SsaBuilder] Topologically sorted the graph.
[SsaBuilder::ComputeImmediateDom]

Inside fgBuildDomTree

After computing the Dominance Tree:
BB01 : BB14 BB06 BB04 BB02 
BB02 : BB03 
BB04 : BB05 
BB06 : BB15 BB08 BB07 
BB08 : BB10 
BB10 : BB13 BB12 BB11 
BB15 : BB09 

*************** In fgLocalVarLiveness()
In fgLocalVarLivenessInit
Tracked variable (8 out of 12) table:
V07 tmp4          [   ref]: refCnt =    4, refCntWtd =   6   
V00 this          [   ref]: refCnt =    4, refCntWtd =   3   
V01 loc0          [   ref]: refCnt =    4, refCntWtd =   4   
V09 tmp6          [  bool]: refCnt =    4, refCntWtd =   2.48
V10 tmp7          [  long]: refCnt =    3, refCntWtd =   2   
V02 loc1          [   ref]: refCnt =    2, refCntWtd =   2   
V11 PSPSym        [  long]: refCnt =    1, refCntWtd =   1   
V05 tmp2          [   ref]: refCnt =    1, refCntWtd =   0   

*************** In fgPerBlockLocalVarLiveness()
BB01 USE(1)={V00    } + ByrefExposed + GcHeap
     DEF(1)={    V01}

BB02 USE(0)={   }
     DEF(1)={V09}

BB03 USE(0)={}
     DEF(0)={}

BB04 USE(0)={   }
     DEF(1)={V09}

BB05 USE(1)={V09}
     DEF(0)={   }

BB06 USE(1)={V01} + ByrefExposed + GcHeap
     DEF(0)={   }

BB07 USE(0)={}
     DEF(0)={}

BB08 USE(0)={   }
     DEF(1)={V02}

BB09 USE(0)={}
     DEF(0)={}

BB10 USE(1)={    V01} + ByrefExposed + GcHeap
     DEF(1)={V07    }

BB11 USE(1)={V07    } + ByrefExposed + GcHeap
     DEF(1)={    V10}

BB12 USE(1)={V07    } + ByrefExposed + GcHeap
     DEF(1)={    V10} + ByrefExposed* + GcHeap*

BB13 USE(2)={V10 V02} + ByrefExposed + GcHeap
     DEF(0)={       } + ByrefExposed + GcHeap

BB14 USE(0)={}
     DEF(0)={}

BB15 USE(1)={V00    } + ByrefExposed + GcHeap
     DEF(1)={    V05} + ByrefExposed* + GcHeap*

** Memory liveness computed, GcHeap states and ByrefExposed states match
*************** In fgInterBlockLocalVarLiveness()

BB liveness after fgLiveVarAnalysis():

BB01 IN (1)={V00    } + ByrefExposed + GcHeap
     OUT(2)={V00 V01} + ByrefExposed + GcHeap

BB02 IN (2)={V00 V01} + ByrefExposed + GcHeap
     OUT(2)={V00 V01} + ByrefExposed + GcHeap

BB03 IN (0)={}
     OUT(0)={}

BB04 IN (2)={V00 V01    } + ByrefExposed + GcHeap
     OUT(3)={V00 V01 V09} + ByrefExposed + GcHeap

BB05 IN (3)={V00 V01 V09} + ByrefExposed + GcHeap
     OUT(2)={V00 V01    } + ByrefExposed + GcHeap

BB06 IN (2)={V00 V01} + ByrefExposed + GcHeap
     OUT(2)={V00 V01} + ByrefExposed + GcHeap

BB07 IN (0)={}
     OUT(0)={}

BB08 IN (2)={V00 V01    } + ByrefExposed + GcHeap
     OUT(3)={V00 V01 V02} + ByrefExposed + GcHeap

BB09 IN (0)={}
     OUT(0)={}

BB10 IN (2)={    V01 V02} + ByrefExposed + GcHeap
     OUT(2)={V07     V02} + ByrefExposed + GcHeap

BB11 IN (2)={V07     V02} + ByrefExposed + GcHeap
     OUT(2)={    V10 V02} + ByrefExposed + GcHeap

BB12 IN (2)={V07     V02} + ByrefExposed + GcHeap
     OUT(2)={    V10 V02} + ByrefExposed + GcHeap

BB13 IN (2)={V10 V02} + ByrefExposed + GcHeap
     OUT(0)={       }

BB14 IN (0)={}
     OUT(0)={}

BB15 IN (1)={V00} + ByrefExposed + GcHeap
     OUT(0)={   }

top level assign
removing stmt with no side effects

removing useless STMT00010 ( 0x025[--] ... 0x02C )
N003 (  5,  4) [000040] -A---O--R--                         *  ASG       ref   
N002 (  3,  2) [000039] D------N---                         +--*  LCL_VAR   ref    V05 tmp2         
N001 (  1,  1) [000018] -----O-----                         \--*  CATCH_ARG ref   
 from BB15
*************** In optRemoveRedundantZeroInits()
*************** In SsaBuilder::InsertPhiFunctions()
Inserting phi functions:
Added PHI definition for V10 at start of BB13.
Inserting phi definition for ByrefExposed at start of BB13.
*************** In SsaBuilder::RenameVariables()

After fgSsaBuild:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 ( cond )                     i IBC 
BB03 [0036]  1       BB02                  0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 ( cond )                     keep internal IBC 
BB06 [0002]  2       BB02,BB05             1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
N006 (  4,  4) [000003] -A-XG---R--                         *  ASG       ref   
N005 (  1,  1) [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         d:1
N004 (  4,  4) [000001] ---XG------                         \--*  IND       ref   
N003 (  2,  2) [000097] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000000] -----------                               +--*  LCL_VAR   ref    V00 this         u:1
N002 (  1,  1) [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method]

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
N004 (  5,  5) [000078] -----------                         *  JTRUE     void  
N003 (  3,  3) [000077] J------N---                         \--*  EQ        int   
N001 (  1,  1) [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1
N002 (  1,  1) [000076] -----------                            \--*  CNS_INT   ref    null

------------ BB02 [007..008) -> BB06 (cond), preds={BB01} succs={BB03,BB06}

***** BB02
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000087] -A------R--                         *  ASG       bool  
N002 (  3,  2) [000086] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:2
N001 (  1,  1) [000085] -----------                         \--*  CNS_INT   int    0

***** BB02
STMT00024 ( ??? ... ??? )
N004 (  8,  7) [000113] -----------                         *  JTRUE     void  
N003 (  6,  5) [000114] J------N---                         \--*  EQ        int   
N001 (  4,  3) [000115] -----------                            +--*  LCL_VAR   bool   V09 tmp6         u:2 (last use)
N002 (  1,  1) [000116] -----------                            \--*  CNS_INT   int    0

------------ BB03 [???..???) -> BB14 (always), preds={BB02} succs={BB14}

------------ BB04 [007..008), preds={BB01} succs={BB05}

***** BB04
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000082] -A------R--                         *  ASG       bool  
N002 (  3,  2) [000081] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:1
N001 (  1,  1) [000080] -----------                         \--*  CNS_INT   int    1

------------ BB05 [???..???) -> BB14 (cond), preds={BB04} succs={BB06,BB14}

***** BB05
STMT00002 ( 0x007[E-] ... ??? )
N004 (  8,  7) [000011] -----------                         *  JTRUE     void  
N003 (  6,  5) [000010] J------N---                         \--*  NE        int   
N001 (  4,  3) [000088] -----------                            +--*  LCL_VAR   bool   V09 tmp6         u:1 (last use)
N002 (  1,  1) [000009] -----------                            \--*  CNS_INT   int    0

------------ BB06 [012..01A) -> BB08 (cond), preds={BB02,BB05} succs={BB07,BB08}

***** BB06
STMT00003 ( 0x012[E-] ... 0x018 )
N007 (  8,  8) [000016] ---XG------                         *  JTRUE     void  
N006 (  6,  6) [000015] J--XG--N---                         \--*  NE        int   
N004 (  4,  4) [000013] ---XG------                            +--*  IND       ref   
N003 (  2,  2) [000099] -------N---                            |  \--*  ADD       byref 
N001 (  1,  1) [000012] -----------                            |     +--*  LCL_VAR   ref    V01 loc0         u:1
N002 (  1,  1) [000098] -----------                            |     \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]
N005 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null

------------ BB07 [01A..01C) -> BB14 (always), preds={BB06} succs={BB14}

------------ BB08 [01C..025) -> BB10 (always), preds={BB06} succs={BB10}

***** BB08
STMT00006 ( 0x022[--] ... ??? )
N003 ( 18,  8) [000028] -AC-----R--                         *  ASG       ref   
N002 (  3,  2) [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         d:1
N001 ( 14,  5) [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}

***** BB10
STMT00014 ( 0x02E[E-] ... ??? )
N006 (  4,  4) [000051] -A-XG---R--                         *  ASG       ref   
N005 (  1,  1) [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1
N004 (  4,  4) [000048] ---XG------                         \--*  IND       ref   
N003 (  2,  2) [000101] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000049] -----------                               +--*  LCL_VAR   ref    V01 loc0         u:1 (last use)
N002 (  1,  1) [000100] -----------                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]

***** BB10
STMT00015 ( 0x02E[E-] ... ??? )
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void  
N005 (  7,  9) [000057] J--X---N---                         \--*  NE        int   
N002 (  3,  6) [000056] #----------                            +--*  IND       long  
N001 (  1,  4) [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
N004 (  3,  2) [000054] #--X-------                            \--*  IND       long  
N003 (  1,  1) [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         u:1

------------ BB11 [???..???) -> BB13 (always), preds={BB10} succs={BB13}

***** BB11
STMT00018 ( ??? ... ??? )
N006 (  8,  7) [000106] -A-X----R--                         *  ASG       long  
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3
N004 (  4,  4) [000105] ---X-------                         \--*  IND       long  
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use)
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle]

------------ BB12 [???..???), preds={BB10} succs={BB13}

***** BB12
STMT00019 ( 0x02E[E-] ... ??? )
N005 ( 26, 17) [000071] -ACXG---R--                         *  ASG       struct (copy)
N004 (  3,  2) [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
N003 ( 22, 14) [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
N001 (  1,  1) [000053] ----------- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use)
N002 (  1,  4) [000107] H---------- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}

***** BB13
STMT00025 ( ??? ... ??? )
N005 (  0,  0) [000119] -A------R--                         *  ASG       long  
N004 (  0,  0) [000117] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:1
N003 (  0,  0) [000118] -----------                         \--*  PHI       long  
N001 (  0,  0) [000121] ----------- pred BB11                  +--*  PHI_ARG   long   V10 tmp7         u:3
N002 (  0,  0) [000120] ----------- pred BB12                  \--*  PHI_ARG   long   V10 tmp7         u:2

***** BB13
STMT00008 ( 0x02E[E-] ... ??? )
N006 ( 10,  8) [000112] -A-X-------                         *  ASG       long  
N004 (  6,  5) [000110] D--X---N---                         +--*  IND       long  
N003 (  4,  3) [000109] -------N---                         |  \--*  ADD       byref 
N001 (  3,  2) [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         u:1 (last use)
N002 (  1,  1) [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle]
N005 (  3,  2) [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         u:1 (last use)

------------ BB14 [048..049) (return), preds={BB03,BB05,BB07,BB09,BB13} succs={}

***** BB14
STMT00009 ( 0x048[E-] ... 0x048 )
N001 (  0,  0) [000038] -----------                         *  RETURN    void  

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}

***** BB15
STMT00011 ( 0x026[E-] ... ??? )
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
N001 (  1,  1) [000042] ----------- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         u:1 (last use)

-------------------------------------------------------------------------------------------------------------------

*************** Finishing PHASE Build SSA representation
Trees after Build SSA representation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 ( cond )                     i IBC 
BB03 [0036]  1       BB02                  0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 ( cond )                     keep internal IBC 
BB06 [0002]  2       BB02,BB05             1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
N006 (  4,  4) [000003] -A-XG---R--                         *  ASG       ref   
N005 (  1,  1) [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         d:1
N004 (  4,  4) [000001] ---XG------                         \--*  IND       ref   
N003 (  2,  2) [000097] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000000] -----------                               +--*  LCL_VAR   ref    V00 this         u:1
N002 (  1,  1) [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method]

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
N004 (  5,  5) [000078] -----------                         *  JTRUE     void  
N003 (  3,  3) [000077] J------N---                         \--*  EQ        int   
N001 (  1,  1) [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1
N002 (  1,  1) [000076] -----------                            \--*  CNS_INT   ref    null

------------ BB02 [007..008) -> BB06 (cond), preds={BB01} succs={BB03,BB06}

***** BB02
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000087] -A------R--                         *  ASG       bool  
N002 (  3,  2) [000086] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:2
N001 (  1,  1) [000085] -----------                         \--*  CNS_INT   int    0

***** BB02
STMT00024 ( ??? ... ??? )
N004 (  8,  7) [000113] -----------                         *  JTRUE     void  
N003 (  6,  5) [000114] J------N---                         \--*  EQ        int   
N001 (  4,  3) [000115] -----------                            +--*  LCL_VAR   bool   V09 tmp6         u:2 (last use)
N002 (  1,  1) [000116] -----------                            \--*  CNS_INT   int    0

------------ BB03 [???..???) -> BB14 (always), preds={BB02} succs={BB14}

------------ BB04 [007..008), preds={BB01} succs={BB05}

***** BB04
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000082] -A------R--                         *  ASG       bool  
N002 (  3,  2) [000081] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:1
N001 (  1,  1) [000080] -----------                         \--*  CNS_INT   int    1

------------ BB05 [???..???) -> BB14 (cond), preds={BB04} succs={BB06,BB14}

***** BB05
STMT00002 ( 0x007[E-] ... ??? )
N004 (  8,  7) [000011] -----------                         *  JTRUE     void  
N003 (  6,  5) [000010] J------N---                         \--*  NE        int   
N001 (  4,  3) [000088] -----------                            +--*  LCL_VAR   bool   V09 tmp6         u:1 (last use)
N002 (  1,  1) [000009] -----------                            \--*  CNS_INT   int    0

------------ BB06 [012..01A) -> BB08 (cond), preds={BB02,BB05} succs={BB07,BB08}

***** BB06
STMT00003 ( 0x012[E-] ... 0x018 )
N007 (  8,  8) [000016] ---XG------                         *  JTRUE     void  
N006 (  6,  6) [000015] J--XG--N---                         \--*  NE        int   
N004 (  4,  4) [000013] ---XG------                            +--*  IND       ref   
N003 (  2,  2) [000099] -------N---                            |  \--*  ADD       byref 
N001 (  1,  1) [000012] -----------                            |     +--*  LCL_VAR   ref    V01 loc0         u:1
N002 (  1,  1) [000098] -----------                            |     \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]
N005 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null

------------ BB07 [01A..01C) -> BB14 (always), preds={BB06} succs={BB14}

------------ BB08 [01C..025) -> BB10 (always), preds={BB06} succs={BB10}

***** BB08
STMT00006 ( 0x022[--] ... ??? )
N003 ( 18,  8) [000028] -AC-----R--                         *  ASG       ref   
N002 (  3,  2) [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         d:1
N001 ( 14,  5) [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}

***** BB10
STMT00014 ( 0x02E[E-] ... ??? )
N006 (  4,  4) [000051] -A-XG---R--                         *  ASG       ref   
N005 (  1,  1) [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1
N004 (  4,  4) [000048] ---XG------                         \--*  IND       ref   
N003 (  2,  2) [000101] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000049] -----------                               +--*  LCL_VAR   ref    V01 loc0         u:1 (last use)
N002 (  1,  1) [000100] -----------                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]

***** BB10
STMT00015 ( 0x02E[E-] ... ??? )
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void  
N005 (  7,  9) [000057] J--X---N---                         \--*  NE        int   
N002 (  3,  6) [000056] #----------                            +--*  IND       long  
N001 (  1,  4) [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
N004 (  3,  2) [000054] #--X-------                            \--*  IND       long  
N003 (  1,  1) [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         u:1

------------ BB11 [???..???) -> BB13 (always), preds={BB10} succs={BB13}

***** BB11
STMT00018 ( ??? ... ??? )
N006 (  8,  7) [000106] -A-X----R--                         *  ASG       long  
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3
N004 (  4,  4) [000105] ---X-------                         \--*  IND       long  
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use)
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle]

------------ BB12 [???..???), preds={BB10} succs={BB13}

***** BB12
STMT00019 ( 0x02E[E-] ... ??? )
N005 ( 26, 17) [000071] -ACXG---R--                         *  ASG       struct (copy)
N004 (  3,  2) [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
N003 ( 22, 14) [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
N001 (  1,  1) [000053] ----------- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use)
N002 (  1,  4) [000107] H---------- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}

***** BB13
STMT00025 ( ??? ... ??? )
N005 (  0,  0) [000119] -A------R--                         *  ASG       long  
N004 (  0,  0) [000117] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:1
N003 (  0,  0) [000118] -----------                         \--*  PHI       long  
N001 (  0,  0) [000121] ----------- pred BB11                  +--*  PHI_ARG   long   V10 tmp7         u:3
N002 (  0,  0) [000120] ----------- pred BB12                  \--*  PHI_ARG   long   V10 tmp7         u:2

***** BB13
STMT00008 ( 0x02E[E-] ... ??? )
N006 ( 10,  8) [000112] -A-X-------                         *  ASG       long  
N004 (  6,  5) [000110] D--X---N---                         +--*  IND       long  
N003 (  4,  3) [000109] -------N---                         |  \--*  ADD       byref 
N001 (  3,  2) [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         u:1 (last use)
N002 (  1,  1) [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle]
N005 (  3,  2) [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         u:1 (last use)

------------ BB14 [048..049) (return), preds={BB03,BB05,BB07,BB09,BB13} succs={}

***** BB14
STMT00009 ( 0x048[E-] ... 0x048 )
N001 (  0,  0) [000038] -----------                         *  RETURN    void  

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}

***** BB15
STMT00011 ( 0x026[E-] ... ??? )
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
N001 (  1,  1) [000042] ----------- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         u:1 (last use)

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE Early Value Propagation
*************** In optEarlyProp()

After optEarlyProp:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 ( cond )                     i IBC 
BB03 [0036]  1       BB02                  0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 ( cond )                     keep internal IBC 
BB06 [0002]  2       BB02,BB05             1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
N006 (  4,  4) [000003] -A-XG---R--                         *  ASG       ref   
N005 (  1,  1) [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         d:1
N004 (  4,  4) [000001] ---XG------                         \--*  IND       ref   
N003 (  2,  2) [000097] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000000] -----------                               +--*  LCL_VAR   ref    V00 this         u:1
N002 (  1,  1) [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method]

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
N004 (  5,  5) [000078] -----------                         *  JTRUE     void  
N003 (  3,  3) [000077] J------N---                         \--*  EQ        int   
N001 (  1,  1) [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1
N002 (  1,  1) [000076] -----------                            \--*  CNS_INT   ref    null

------------ BB02 [007..008) -> BB06 (cond), preds={BB01} succs={BB03,BB06}

***** BB02
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000087] -A------R--                         *  ASG       bool  
N002 (  3,  2) [000086] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:2
N001 (  1,  1) [000085] -----------                         \--*  CNS_INT   int    0

***** BB02
STMT00024 ( ??? ... ??? )
N004 (  8,  7) [000113] -----------                         *  JTRUE     void  
N003 (  6,  5) [000114] J------N---                         \--*  EQ        int   
N001 (  4,  3) [000115] -----------                            +--*  LCL_VAR   bool   V09 tmp6         u:2 (last use)
N002 (  1,  1) [000116] -----------                            \--*  CNS_INT   int    0

------------ BB03 [???..???) -> BB14 (always), preds={BB02} succs={BB14}

------------ BB04 [007..008), preds={BB01} succs={BB05}

***** BB04
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000082] -A------R--                         *  ASG       bool  
N002 (  3,  2) [000081] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:1
N001 (  1,  1) [000080] -----------                         \--*  CNS_INT   int    1

------------ BB05 [???..???) -> BB14 (cond), preds={BB04} succs={BB06,BB14}

***** BB05
STMT00002 ( 0x007[E-] ... ??? )
N004 (  8,  7) [000011] -----------                         *  JTRUE     void  
N003 (  6,  5) [000010] J------N---                         \--*  NE        int   
N001 (  4,  3) [000088] -----------                            +--*  LCL_VAR   bool   V09 tmp6         u:1 (last use)
N002 (  1,  1) [000009] -----------                            \--*  CNS_INT   int    0

------------ BB06 [012..01A) -> BB08 (cond), preds={BB02,BB05} succs={BB07,BB08}

***** BB06
STMT00003 ( 0x012[E-] ... 0x018 )
N007 (  8,  8) [000016] ---XG------                         *  JTRUE     void  
N006 (  6,  6) [000015] J--XG--N---                         \--*  NE        int   
N004 (  4,  4) [000013] ---XG------                            +--*  IND       ref   
N003 (  2,  2) [000099] -------N---                            |  \--*  ADD       byref 
N001 (  1,  1) [000012] -----------                            |     +--*  LCL_VAR   ref    V01 loc0         u:1
N002 (  1,  1) [000098] -----------                            |     \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]
N005 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null

------------ BB07 [01A..01C) -> BB14 (always), preds={BB06} succs={BB14}

------------ BB08 [01C..025) -> BB10 (always), preds={BB06} succs={BB10}

***** BB08
STMT00006 ( 0x022[--] ... ??? )
N003 ( 18,  8) [000028] -AC-----R--                         *  ASG       ref   
N002 (  3,  2) [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         d:1
N001 ( 14,  5) [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}

***** BB10
STMT00014 ( 0x02E[E-] ... ??? )
N006 (  4,  4) [000051] -A-XG---R--                         *  ASG       ref   
N005 (  1,  1) [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1
N004 (  4,  4) [000048] ---XG------                         \--*  IND       ref   
N003 (  2,  2) [000101] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000049] -----------                               +--*  LCL_VAR   ref    V01 loc0         u:1 (last use)
N002 (  1,  1) [000100] -----------                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]

***** BB10
STMT00015 ( 0x02E[E-] ... ??? )
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void  
N005 (  7,  9) [000057] J--X---N---                         \--*  NE        int   
N002 (  3,  6) [000056] #----------                            +--*  IND       long  
N001 (  1,  4) [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
N004 (  3,  2) [000054] #--X-------                            \--*  IND       long  
N003 (  1,  1) [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         u:1

------------ BB11 [???..???) -> BB13 (always), preds={BB10} succs={BB13}

***** BB11
STMT00018 ( ??? ... ??? )
N006 (  8,  7) [000106] -A-X----R--                         *  ASG       long  
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3
N004 (  4,  4) [000105] ---X-------                         \--*  IND       long  
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use)
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle]

------------ BB12 [???..???), preds={BB10} succs={BB13}

***** BB12
STMT00019 ( 0x02E[E-] ... ??? )
N005 ( 26, 17) [000071] -ACXG---R--                         *  ASG       struct (copy)
N004 (  3,  2) [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
N003 ( 22, 14) [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
N001 (  1,  1) [000053] ----------- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use)
N002 (  1,  4) [000107] H---------- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}

***** BB13
STMT00025 ( ??? ... ??? )
N005 (  0,  0) [000119] -A------R--                         *  ASG       long  
N004 (  0,  0) [000117] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:1
N003 (  0,  0) [000118] -----------                         \--*  PHI       long  
N001 (  0,  0) [000121] ----------- pred BB11                  +--*  PHI_ARG   long   V10 tmp7         u:3
N002 (  0,  0) [000120] ----------- pred BB12                  \--*  PHI_ARG   long   V10 tmp7         u:2

***** BB13
STMT00008 ( 0x02E[E-] ... ??? )
N006 ( 10,  8) [000112] -A-X-------                         *  ASG       long  
N004 (  6,  5) [000110] D--X---N---                         +--*  IND       long  
N003 (  4,  3) [000109] -------N---                         |  \--*  ADD       byref 
N001 (  3,  2) [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         u:1 (last use)
N002 (  1,  1) [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle]
N005 (  3,  2) [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         u:1 (last use)

------------ BB14 [048..049) (return), preds={BB03,BB05,BB07,BB09,BB13} succs={}

***** BB14
STMT00009 ( 0x048[E-] ... 0x048 )
N001 (  0,  0) [000038] -----------                         *  RETURN    void  

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}

***** BB15
STMT00011 ( 0x026[E-] ... ??? )
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
N001 (  1,  1) [000042] ----------- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         u:1 (last use)

-------------------------------------------------------------------------------------------------------------------

*************** Finishing PHASE Early Value Propagation

*************** Starting PHASE Do value numbering

*************** In fgValueNumber()
Memory Initial Value in BB01 is: $c0
The SSA definition for ByrefExposed (#1) at start of BB01 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB01 is $c0 {InitVal($41)}

***** BB01, STMT00000(before)
N006 (  4,  4) [000003] -A-XG---R--                         *  ASG       ref   
N005 (  1,  1) [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         d:1
N004 (  4,  4) [000001] ---XG------                         \--*  IND       ref   
N003 (  2,  2) [000097] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000000] -----------                               +--*  LCL_VAR   ref    V00 this         u:1
N002 (  1,  1) [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method]

N001 [000000]   LCL_VAR   V00 this         u:1 => $80 {InitVal($40)}
N002 [000096]   CNS_INT   24 field offset Fseq[m_method] => $100 {LngCns:  24}
N003 [000097]   ADD       => $140 {ADD($80, $100)}
    VNForHandle(m_method) is $180, fieldType is ref, size = 8
    VNForMapSelect($c0, $180):mem returns $1c0 {$c0[$180]}
    VNForMapSelect($1c0, $80):ref returns $200 {$1c0[$80]}
N004 [000001]   IND       => <l:$202 {norm=$200 {$1c0[$80]}, exc=$201 {NullPtrExc($80)}}, c:$203 {norm=$81 {MemOpaque:NotInLoop}, exc=$201 {NullPtrExc($80)}}>
N005 [000002]   LCL_VAR   V01 loc0         d:1 => $VN.Void
Tree [000003] assigned VN to local var V01/1: <l:$200 {$1c0[$80]}, c:$81 {MemOpaque:NotInLoop}>
N006 [000003]   ASG       => $204 {norm=$VN.Void, exc=$201 {NullPtrExc($80)}}

***** BB01, STMT00000(after)
N006 (  4,  4) [000003] -A-XG---R--                         *  ASG       ref    $204
N005 (  1,  1) [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         d:1 $VN.Void
N004 (  4,  4) [000001] ---XG------                         \--*  IND       ref    <l:$202, c:$203>
N003 (  2,  2) [000097] -------N---                            \--*  ADD       byref  $140
N001 (  1,  1) [000000] -----------                               +--*  LCL_VAR   ref    V00 this         u:1 $80
N002 (  1,  1) [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method] $100

---------

***** BB01, STMT00020(before)
N004 (  5,  5) [000078] -----------                         *  JTRUE     void  
N003 (  3,  3) [000077] J------N---                         \--*  EQ        int   
N001 (  1,  1) [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1
N002 (  1,  1) [000076] -----------                            \--*  CNS_INT   ref    null

N001 [000004]   LCL_VAR   V01 loc0         u:1 => <l:$200 {$1c0[$80]}, c:$81 {MemOpaque:NotInLoop}>
N002 [000076]   CNS_INT   null => $VN.Null
N003 [000077]   EQ        => <l:$241 {EQ($200, $0)}, c:$240 {EQ($81, $0)}>
N004 [000078]   JTRUE     => $VN.Void

***** BB01, STMT00020(after)
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void
N003 (  3,  3) [000077] J------N---                         \--*  EQ        int    <l:$241, c:$240>
N001 (  1,  1) [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000076] -----------                            \--*  CNS_INT   ref    null $VN.Null

finish(BB01).
   Succ(BB02).
     Not yet completed.
     All preds complete, adding to allDone.
   Succ(BB04).
     Not yet completed.
     All preds complete, adding to allDone.
The SSA definition for ByrefExposed (#1) at start of BB04 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB04 is $c0 {InitVal($41)}

***** BB04, STMT00021(before)
N003 (  5,  4) [000082] -A------R--                         *  ASG       bool  
N002 (  3,  2) [000081] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:1
N001 (  1,  1) [000080] -----------                         \--*  CNS_INT   int    1

N001 [000080]   CNS_INT   1 => $42 {IntCns 1}
N002 [000081]   LCL_VAR   V09 tmp6         d:1 => $VN.Void
Tree [000082] assigned VN to local var V09/1: $42 {IntCns 1}
N003 [000082]   ASG       => $VN.Void

***** BB04, STMT00021(after)
N003 (  5,  4) [000082] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2) [000081] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:1 $VN.Void
N001 (  1,  1) [000080] -----------                         \--*  CNS_INT   int    1 $42

finish(BB04).
   Succ(BB05).
     Not yet completed.
     All preds complete, adding to allDone.
The SSA definition for ByrefExposed (#1) at start of BB05 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB05 is $c0 {InitVal($41)}

***** BB05, STMT00002(before)
N004 (  8,  7) [000011] -----------                         *  JTRUE     void  
N003 (  6,  5) [000010] J------N---                         \--*  NE        int   
N001 (  4,  3) [000088] -----------                            +--*  LCL_VAR   bool   V09 tmp6         u:1 (last use)
N002 (  1,  1) [000009] -----------                            \--*  CNS_INT   int    0

N001 [000088]   LCL_VAR   V09 tmp6         u:1 (last use) => $42 {IntCns 1}
N002 [000009]   CNS_INT   0 => $40 {IntCns 0}
N003 [000010]   NE        => $42 {IntCns 1}
N004 [000011]   JTRUE     => $VN.Void

***** BB05, STMT00002(after)
N004 (  8,  7) [000011] -----------                         *  JTRUE     void   $VN.Void
N003 (  6,  5) [000010] J------N---                         \--*  NE        int    $42
N001 (  4,  3) [000088] -----------                            +--*  LCL_VAR   bool   V09 tmp6         u:1 (last use) $42
N002 (  1,  1) [000009] -----------                            \--*  CNS_INT   int    0 $40

finish(BB05).
   Succ(BB06).
     Not yet completed.
     Not all preds complete  Adding to notallDone, if necessary...
       Was necessary.
   Succ(BB14).
     Not yet completed.
     Not all preds complete  Adding to notallDone, if necessary...
       Was necessary.
The SSA definition for ByrefExposed (#1) at start of BB02 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB02 is $c0 {InitVal($41)}

***** BB02, STMT00022(before)
N003 (  5,  4) [000087] -A------R--                         *  ASG       bool  
N002 (  3,  2) [000086] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:2
N001 (  1,  1) [000085] -----------                         \--*  CNS_INT   int    0

N001 [000085]   CNS_INT   0 => $40 {IntCns 0}
N002 [000086]   LCL_VAR   V09 tmp6         d:2 => $VN.Void
Tree [000087] assigned VN to local var V09/2: $40 {IntCns 0}
N003 [000087]   ASG       => $VN.Void

***** BB02, STMT00022(after)
N003 (  5,  4) [000087] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2) [000086] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:2 $VN.Void
N001 (  1,  1) [000085] -----------                         \--*  CNS_INT   int    0 $40

---------

***** BB02, STMT00024(before)
N004 (  8,  7) [000113] -----------                         *  JTRUE     void  
N003 (  6,  5) [000114] J------N---                         \--*  EQ        int   
N001 (  4,  3) [000115] -----------                            +--*  LCL_VAR   bool   V09 tmp6         u:2 (last use)
N002 (  1,  1) [000116] -----------                            \--*  CNS_INT   int    0

N001 [000115]   LCL_VAR   V09 tmp6         u:2 (last use) => $40 {IntCns 0}
N002 [000116]   CNS_INT   0 => $40 {IntCns 0}
N003 [000114]   EQ        => $42 {IntCns 1}
N004 [000113]   JTRUE     => $VN.Void

***** BB02, STMT00024(after)
N004 (  8,  7) [000113] -----------                         *  JTRUE     void   $VN.Void
N003 (  6,  5) [000114] J------N---                         \--*  EQ        int    $42
N001 (  4,  3) [000115] -----------                            +--*  LCL_VAR   bool   V09 tmp6         u:2 (last use) $40
N002 (  1,  1) [000116] -----------                            \--*  CNS_INT   int    0 $40

finish(BB02).
   Succ(BB03).
     Not yet completed.
     All preds complete, adding to allDone.
   Succ(BB06).
     Not yet completed.
     All preds complete, adding to allDone.
The SSA definition for ByrefExposed (#1) at start of BB06 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB06 is $c0 {InitVal($41)}

***** BB06, STMT00003(before)
N007 (  8,  8) [000016] ---XG------                         *  JTRUE     void  
N006 (  6,  6) [000015] J--XG--N---                         \--*  NE        int   
N004 (  4,  4) [000013] ---XG------                            +--*  IND       ref   
N003 (  2,  2) [000099] -------N---                            |  \--*  ADD       byref 
N001 (  1,  1) [000012] -----------                            |     +--*  LCL_VAR   ref    V01 loc0         u:1
N002 (  1,  1) [000098] -----------                            |     \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]
N005 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null

N001 [000012]   LCL_VAR   V01 loc0         u:1 => <l:$200 {$1c0[$80]}, c:$81 {MemOpaque:NotInLoop}>
N002 [000098]   CNS_INT   16 field offset Fseq[m_methodHandle] => $101 {LngCns:  16}
N003 [000099]   ADD       => <l:$142 {ADD($101, $200)}, c:$141 {ADD($81, $101)}>
    VNForHandle(m_methodHandle) is $181, fieldType is ref, size = 8
    VNForMapSelect($c0, $181):mem returns $1c1 {$c0[$181]}
    VNForMapSelect($1c1, $200):ref returns $205 {$1c1[$200]}
N004 [000013]   IND       => <l:$208 {norm=$205 {$1c1[$200]}, exc=$206 {NullPtrExc($200)}}, c:$209 {norm=$83 {MemOpaque:NotInLoop}, exc=$207 {NullPtrExc($81)}}>
N005 [000014]   CNS_INT   null => $VN.Null
N006 [000015]   NE        => <l:$245 {norm=$243 {NE($205, $0)}, exc=$206 {NullPtrExc($200)}}, c:$244 {norm=$242 {NE($83, $0)}, exc=$207 {NullPtrExc($81)}}>
N007 [000016]   JTRUE     => <l:$20b {norm=$VN.Void, exc=$206 {NullPtrExc($200)}}, c:$20a {norm=$VN.Void, exc=$207 {NullPtrExc($81)}}>

***** BB06, STMT00003(after)
N007 (  8,  8) [000016] ---XG------                         *  JTRUE     void   <l:$20b, c:$20a>
N006 (  6,  6) [000015] J--XG--N---                         \--*  NE        int    <l:$245, c:$244>
N004 (  4,  4) [000013] ---XG------                            +--*  IND       ref    <l:$208, c:$209>
N003 (  2,  2) [000099] -------N---                            |  \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1) [000012] -----------                            |     +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000098] -----------                            |     \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
N005 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null $VN.Null

finish(BB06).
   Succ(BB07).
     Not yet completed.
     All preds complete, adding to allDone.
   Succ(BB08).
     Not yet completed.
     All preds complete, adding to allDone.
   Succ(BB15).
     Not yet completed.
     Not all preds complete  Adding to notallDone, if necessary...
       Was necessary.
The SSA definition for ByrefExposed (#1) at start of BB08 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB08 is $c0 {InitVal($41)}

***** BB08, STMT00006(before)
N003 ( 18,  8) [000028] -AC-----R--                         *  ASG       ref   
N002 (  3,  2) [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         d:1
N001 ( 14,  5) [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW

N001 [000021]   CALL help r2r_ind => $20c {JitReadyToRunNew($182, $86)}
N002 [000027]   LCL_VAR   V02 loc1         d:1 => $VN.Void
Tree [000028] assigned VN to local var V02/1: $20c {JitReadyToRunNew($182, $86)}
N003 [000028]   ASG       => $VN.Void

***** BB08, STMT00006(after)
N003 ( 18,  8) [000028] -AC-----R--                         *  ASG       ref    $VN.Void
N002 (  3,  2) [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         d:1 $VN.Void
N001 ( 14,  5) [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c

finish(BB08).
   Succ(BB10).
     Not yet completed.
     All preds complete, adding to allDone.
   Succ(BB15).
     Not yet completed.
     All preds complete, adding to allDone.
The SSA definition for ByrefExposed (#1) at start of BB15 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB15 is $c0 {InitVal($41)}

***** BB15, STMT00011(before)
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize
N001 (  1,  1) [000042] ----------- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         u:1 (last use)

N001 [000042]   LCL_VAR   V00 this         u:1 (last use) => $80 {InitVal($40)}
  fgCurMemoryVN[GcHeap] assigned for CALL at [000043] to VN: $c1.
N002 [000043]   CALL r2r_ind => $VN.Void

***** BB15, STMT00011(after)
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void
N001 (  1,  1) [000042] ----------- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         u:1 (last use) $80

finish(BB15).
   Succ(BB09).
     Not yet completed.
     All preds complete, adding to allDone.
The SSA definition for ByrefExposed (#2) at start of BB09 is $c1 {MemOpaque:NotInLoop}
The SSA definition for GcHeap (#2) at start of BB09 is $c1 {MemOpaque:NotInLoop}
finish(BB09).
   Succ(BB14).
     Not yet completed.
     Not all preds complete  Adding to notallDone, if necessary...
The SSA definition for ByrefExposed (#1) at start of BB10 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB10 is $c0 {InitVal($41)}

***** BB10, STMT00014(before)
N006 (  4,  4) [000051] -A-XG---R--                         *  ASG       ref   
N005 (  1,  1) [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1
N004 (  4,  4) [000048] ---XG------                         \--*  IND       ref   
N003 (  2,  2) [000101] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000049] -----------                               +--*  LCL_VAR   ref    V01 loc0         u:1 (last use)
N002 (  1,  1) [000100] -----------                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle]

N001 [000049]   LCL_VAR   V01 loc0         u:1 (last use) => <l:$200 {$1c0[$80]}, c:$81 {MemOpaque:NotInLoop}>
N002 [000100]   CNS_INT   16 field offset Fseq[m_methodHandle] => $101 {LngCns:  16}
N003 [000101]   ADD       => <l:$142 {ADD($101, $200)}, c:$141 {ADD($81, $101)}>
    VNForHandle(m_methodHandle) is $181, fieldType is ref, size = 8
    VNForMapSelect($c0, $181):mem returns $1c1 {$c0[$181]}
    VNForMapSelect($1c1, $200):ref returns $205 {$1c1[$200]}
N004 [000048]   IND       => <l:$208 {norm=$205 {$1c1[$200]}, exc=$206 {NullPtrExc($200)}}, c:$20d {norm=$87 {MemOpaque:NotInLoop}, exc=$207 {NullPtrExc($81)}}>
N005 [000050]   LCL_VAR   V07 tmp4         d:1 => $VN.Void
Tree [000051] assigned VN to local var V07/1: <l:$205 {$1c1[$200]}, c:$87 {MemOpaque:NotInLoop}>
N006 [000051]   ASG       => <l:$20b {norm=$VN.Void, exc=$206 {NullPtrExc($200)}}, c:$20a {norm=$VN.Void, exc=$207 {NullPtrExc($81)}}>

***** BB10, STMT00014(after)
N006 (  4,  4) [000051] -A-XG---R--                         *  ASG       ref    <l:$20b, c:$20a>
N005 (  1,  1) [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1 $VN.Void
N004 (  4,  4) [000048] ---XG------                         \--*  IND       ref    <l:$208, c:$20d>
N003 (  2,  2) [000101] -------N---                            \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1) [000049] -----------                               +--*  LCL_VAR   ref    V01 loc0         u:1 (last use) <l:$200, c:$81>
N002 (  1,  1) [000100] -----------                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101

---------

***** BB10, STMT00015(before)
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void  
N005 (  7,  9) [000057] J--X---N---                         \--*  NE        int   
N002 (  3,  6) [000056] #----------                            +--*  IND       long  
N001 (  1,  4) [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class
N004 (  3,  2) [000054] #--X-------                            \--*  IND       long  
N003 (  1,  1) [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         u:1

N001 [000055]   CNS_INT(h) 0x40000000004258b8 class => $183 {Hnd const: 0x40000000004258B8}
N002 [000056]   IND       => $280 {InvariantLoad($183)}
N003 [000052]   LCL_VAR   V07 tmp4         u:1 => <l:$205 {$1c1[$200]}, c:$87 {MemOpaque:NotInLoop}>
N004 [000054]   IND       => <l:$2c0 {norm=$282 {InvariantLoad($205)}, exc=$20e {NullPtrExc($205)}}, c:$2c1 {norm=$281 {InvariantLoad($87)}, exc=$20f {NullPtrExc($87)}}>
N005 [000057]   NE        => <l:$249 {norm=$247 {NE($280, $282)}, exc=$20e {NullPtrExc($205)}}, c:$248 {norm=$246 {NE($280, $281)}, exc=$20f {NullPtrExc($87)}}>
N006 [000058]   JTRUE     => <l:$211 {norm=$VN.Void, exc=$20e {NullPtrExc($205)}}, c:$210 {norm=$VN.Void, exc=$20f {NullPtrExc($87)}}>

***** BB10, STMT00015(after)
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>
N005 (  7,  9) [000057] J--X---N---                         \--*  NE        int    <l:$249, c:$248>
N002 (  3,  6) [000056] #----------                            +--*  IND       long   $280
N001 (  1,  4) [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class $183
N004 (  3,  2) [000054] #--X-------                            \--*  IND       long   <l:$2c0, c:$2c1>
N003 (  1,  1) [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>

finish(BB10).
   Succ(BB11).
     Not yet completed.
     All preds complete, adding to allDone.
   Succ(BB12).
     Not yet completed.
     All preds complete, adding to allDone.
The SSA definition for ByrefExposed (#1) at start of BB12 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB12 is $c0 {InitVal($41)}

***** BB12, STMT00019(before)
N005 ( 26, 17) [000071] -ACXG---R--                         *  ASG       struct (copy)
N004 (  3,  2) [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7         
N003 ( 22, 14) [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value
N001 (  1,  1) [000053] ----------- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use)
N002 (  1,  4) [000107] H---------- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11

N001 [000053]   LCL_VAR   V07 tmp4         u:1 (last use) => <l:$205 {$1c1[$200]}, c:$87 {MemOpaque:NotInLoop}>
N002 [000107]   CNS_INT(h) 0x4000000000424a90 ftn => $184 {Hnd const: 0x4000000000424A90}
  fgCurMemoryVN[GcHeap] assigned for CALL at [000032] to VN: $c2.
N003 [000032]   CALLV stub => $300 {MemOpaque:NotInLoop}
N004 [000069]   LCL_VAR   V06 tmp3         d:2
                                                                long   V06.m_handle (offs=0x00) -> V10 tmp7          => $VN.Void
Tree [000071] assigned VN to the only field V10/2 of promoted struct V06: new uniq $283 {MemOpaque:NotInLoop}
N005 [000071]   ASG       => $VN.Void

***** BB12, STMT00019(after)
N005 ( 26, 17) [000071] -ACXG---R--                         *  ASG       struct (copy) $VN.Void
N004 (  3,  2) [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7          $VN.Void
N003 ( 22, 14) [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value $300
N001 (  1,  1) [000053] ----------- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  4) [000107] H---------- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184

finish(BB12).
   Succ(BB13).
     Not yet completed.
     Not all preds complete  Adding to notallDone, if necessary...
       Was necessary.
The SSA definition for ByrefExposed (#1) at start of BB11 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB11 is $c0 {InitVal($41)}

***** BB11, STMT00018(before)
N006 (  8,  7) [000106] -A-X----R--                         *  ASG       long  
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3
N004 (  4,  4) [000105] ---X-------                         \--*  IND       long  
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref 
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use)
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle]

N001 [000059]   LCL_VAR   V07 tmp4         u:1 (last use) => <l:$205 {$1c1[$200]}, c:$87 {MemOpaque:NotInLoop}>
N002 [000102]   CNS_INT   80 field offset Fseq[m_value, m_handle] => $102 {LngCns:  80}
N003 [000103]   ADD       => <l:$144 {ADD($102, $205)}, c:$143 {ADD($87, $102)}>
    VNForHandle(m_value) is $185, fieldType is struct, size = 8
    VNForMapSelect($c0, $185):mem returns $1c2 {$c0[$185]}
    VNForMapSelect($1c2, $205):struct returns $340 {$1c2[$205]}
    VNForLoadStoreBitcast returns $2c2 {BitCast<long <- struct>($340)}
N004 [000105]   IND       => <l:$2c3 {norm=$2c2 {BitCast<long <- struct>($340)}, exc=$20e {NullPtrExc($205)}}, c:$2c4 {norm=$284 {MemOpaque:NotInLoop}, exc=$20f {NullPtrExc($87)}}>
N005 [000104]   LCL_VAR   V10 tmp7         d:3 => $VN.Void
Tree [000106] assigned VN to local var V10/3: <l:$2c2 {BitCast<long <- struct>($340)}, c:$284 {MemOpaque:NotInLoop}>
N006 [000106]   ASG       => <l:$211 {norm=$VN.Void, exc=$20e {NullPtrExc($205)}}, c:$210 {norm=$VN.Void, exc=$20f {NullPtrExc($87)}}>

***** BB11, STMT00018(after)
N006 (  8,  7) [000106] -A-X----R--                         *  ASG       long   <l:$211, c:$210>
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3 $VN.Void
N004 (  4,  4) [000105] ---X-------                         \--*  IND       long   <l:$2c3, c:$2c4>
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref  <l:$144, c:$143>
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle] $102

finish(BB11).
   Succ(BB13).
     Not yet completed.
     All preds complete, adding to allDone.
SSA PHI definition: set VN of local 10/1 to $380 {PhiDef($a, $1, $2c5)} .
  Building phi application: $42 = SSA# 1.
  Building phi application: $46 = SSA# 5.
  Building phi application: $3c0 = phi($46, $42).
The SSA definition for GcHeap (#3) at start of BB13 is $3c1 {PhiMemoryDef($186, $3c0)}

***** BB13, STMT00008(before)
N006 ( 10,  8) [000112] -A-X-------                         *  ASG       long  
N004 (  6,  5) [000110] D--X---N---                         +--*  IND       long  
N003 (  4,  3) [000109] -------N---                         |  \--*  ADD       byref 
N001 (  3,  2) [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         u:1 (last use)
N002 (  1,  1) [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle]
N005 (  3,  2) [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         u:1 (last use)

N001 [000029]   LCL_VAR   V02 loc1         u:1 (last use) => $20c {JitReadyToRunNew($182, $86)}
N002 [000108]   CNS_INT   8 field offset Fseq[m_methodHandle, m_handle] => $103 {LngCns:  8}
N003 [000109]   ADD       => $145 {ADD($103, $20c)}
N004 [000110]   IND       => $VN.Void
N005 [000111]   LCL_VAR   V10 tmp7         u:1 (last use) => $380 {PhiDef($a, $1, $2c5)}
    VNForHandle(m_methodHandle) is $187, fieldType is struct, size = 8
    VNForMapSelect($3c1, $187):mem returns $1c5 {$3c1[$187]}
    VNForMapStore($1c5, $20c, $380):mem in BB13 returns $400 {$1c5[$20c := $380]}
    VNForMapStore($3c1, $187, $400):heap in BB13 returns $440 {$3c1[$187 := $400]}
  fgCurMemoryVN[GcHeap] assigned for StoreField at [000112] to VN: $440.
N006 [000112]   ASG       => $VN.Void

***** BB13, STMT00008(after)
N006 ( 10,  8) [000112] -A-X-------                         *  ASG       long   $VN.Void
N004 (  6,  5) [000110] D--X---N---                         +--*  IND       long   $VN.Void
N003 (  4,  3) [000109] -------N---                         |  \--*  ADD       byref  $145
N001 (  3,  2) [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
N002 (  1,  1) [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle] $103
N005 (  3,  2) [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         u:1 (last use) $380

finish(BB13).
   Succ(BB14).
     Not yet completed.
     Not all preds complete  Adding to notallDone, if necessary...
The SSA definition for ByrefExposed (#1) at start of BB07 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB07 is $c0 {InitVal($41)}
finish(BB07).
   Succ(BB14).
     Not yet completed.
     Not all preds complete  Adding to notallDone, if necessary...
The SSA definition for ByrefExposed (#1) at start of BB03 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB03 is $c0 {InitVal($41)}
finish(BB03).
   Succ(BB14).
     Not yet completed.
     All preds complete, adding to allDone.
The SSA definition for ByrefExposed (#1) at start of BB14 is $c0 {InitVal($41)}
The SSA definition for GcHeap (#1) at start of BB14 is $c0 {InitVal($41)}

***** BB14, STMT00009(before)
N001 (  0,  0) [000038] -----------                         *  RETURN    void  

N001 [000038]   RETURN    => $VN.Void

***** BB14, STMT00009(after)
N001 (  0,  0) [000038] -----------                         *  RETURN    void   $VN.Void

finish(BB14).

*************** Finishing PHASE Do value numbering

*************** Starting PHASE Hoist loop code

No loops; no hoisting

*************** Finishing PHASE Hoist loop code

*************** Starting PHASE VN based copy prop
*************** In optVnCopyProp()
Copy Assertion for BB01
  curSsaName stack: { }

							Live vars: {V00} => {V00 V01}
Copy Assertion for BB14
  curSsaName stack: { 0-[000000]:V00 1-[000002]:V01 }

Copy Assertion for BB06
  curSsaName stack: { 0-[000000]:V00 1-[000002]:V01 }

Copy Assertion for BB15
  curSsaName stack: { 0-[000000]:V00 1-[000002]:V01 }

							Live vars: {V00} => {}
Copy Assertion for BB09
  curSsaName stack: { 0-[000000]:V00 1-[000002]:V01 }

Copy Assertion for BB08
  curSsaName stack: { 0-[000000]:V00 1-[000002]:V01 }

							Live vars: {V00 V01} => {V00 V01 V02}
Copy Assertion for BB10
  curSsaName stack: { 0-[000000]:V00 1-[000002]:V01 2-[000027]:V02 }

							Live vars: {V01 V02} => {V02}
							Live vars: {V02} => {V02 V07}
Copy Assertion for BB13
  curSsaName stack: { 0-[000000]:V00 1-[000002]:V01 2-[000027]:V02 7-[000050]:V07 }

							Live vars: {V02 V10} => {V10}
							Live vars: {V10} => {}
Copy Assertion for BB12
  curSsaName stack: { 0-[000000]:V00 1-[000002]:V01 2-[000027]:V02 7-[000050]:V07 }

							Live vars: {V02 V07} => {V02}
							Live vars: {V02} => {V02 V10}
Copy Assertion for BB11
  curSsaName stack: { 0-[000000]:V00 1-[000002]:V01 2-[000027]:V02 7-[000050]:V07 }

							Live vars: {V02 V07} => {V02}
							Live vars: {V02} => {V02 V10}
Copy Assertion for BB07
  curSsaName stack: { 0-[000000]:V00 1-[000002]:V01 }

Copy Assertion for BB04
  curSsaName stack: { 0-[000000]:V00 1-[000002]:V01 }

							Live vars: {V00 V01} => {V00 V01 V09}
Copy Assertion for BB05
  curSsaName stack: { 9-[000081]:V09 0-[000000]:V00 1-[000002]:V01 }

							Live vars: {V00 V01 V09} => {V00 V01}
Copy Assertion for BB02
  curSsaName stack: { 0-[000000]:V00 1-[000002]:V01 }

							Live vars: {V00 V01} => {V00 V01 V09}
							Live vars: {V00 V01 V09} => {V00 V01}
Copy Assertion for BB03
  curSsaName stack: { 9-[000086]:V09 0-[000000]:V00 1-[000002]:V01 }


*************** Finishing PHASE VN based copy prop

*************** Starting PHASE Redundant branch opts

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 ( cond )                     i IBC 
BB03 [0036]  1       BB02                  0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 ( cond )                     keep internal IBC 
BB06 [0002]  2       BB02,BB05             1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

optRedundantRelop in BB10; jump tree is
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>
N005 (  7,  9) [000057] J--X---N---                         \--*  NE        int    <l:$249, c:$248>
N002 (  3,  6) [000056] #----------                            +--*  IND       long   $280
N001 (  1,  4) [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class $183
N004 (  3,  2) [000054] #--X-------                            \--*  IND       long   <l:$2c0, c:$2c1>
N003 (  1,  1) [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>
 ... checking previous tree
N006 (  4,  4) [000051] -A-XG---R--                         *  ASG       ref    <l:$20b, c:$20a>
N005 (  1,  1) [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1 $VN.Void
N004 (  4,  4) [000048] ---XG------                         \--*  IND       ref    <l:$208, c:$20d>
N003 (  2,  2) [000101] -------N---                            \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1) [000049] -----------                               +--*  LCL_VAR   ref    V01 loc0         u:1 (last use) <l:$200, c:$81>
N002 (  1,  1) [000100] -----------                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
 -- prev tree VN is not related
Relop [000010] BB05 has known value true
 
Redundant branch opt in BB05:

removing useless STMT00002 ( 0x007[E-] ... ??? )
N004 (  8,  7) [000011] -----------                         *  JTRUE     void   $VN.Void
N003 (  6,  5) [000010] -----------                         \--*  CNS_INT   int    1
 from BB05

BB05 becomes empty

Conditional folded at BB05
BB05 becomes a BBJ_ALWAYS to BB14
Compiler::optRedundantBranch removed tree:
N004 (  8,  7) [000011] -----------                         *  JTRUE     void   $VN.Void
N003 (  6,  5) [000010] -----------                         \--*  CNS_INT   int    1

 -- no, jump tree cond is constant
Relop [000114] BB02 has known value true
 
Redundant branch opt in BB02:

removing useless STMT00024 ( ??? ... ??? )
N004 (  8,  7) [000113] -----------                         *  JTRUE     void   $VN.Void
N003 (  6,  5) [000114] -----------                         \--*  CNS_INT   int    1
 from BB02

Conditional folded at BB02
BB02 becomes a BBJ_ALWAYS to BB06
Compiler::optRedundantBranch removed tree:
N004 (  8,  7) [000113] -----------                         *  JTRUE     void   $VN.Void
N003 (  6,  5) [000114] -----------                         \--*  CNS_INT   int    1


optRedundantRelop in BB01; jump tree is
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void
N003 (  3,  3) [000077] J------N---                         \--*  EQ        int    <l:$241, c:$240>
N001 (  1,  1) [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000076] -----------                            \--*  CNS_INT   ref    null $VN.Null
 ... checking previous tree
N006 (  4,  4) [000003] -A-XG---R--                         *  ASG       ref    $204
N005 (  1,  1) [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         d:1 $VN.Void
N004 (  4,  4) [000001] ---XG------                         \--*  IND       ref    <l:$202, c:$203>
N003 (  2,  2) [000097] -------N---                            \--*  ADD       byref  $140
N001 (  1,  1) [000000] -----------                               +--*  LCL_VAR   ref    V00 this         u:1 $80
N002 (  1,  1) [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method] $100
 -- prev tree VN is not related

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 (always)                     i IBC 
BB03 [0036]  0                             0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Finishing PHASE Redundant branch opts
Trees before Optimize Valnum CSEs

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 (always)                     i IBC 
BB03 [0036]  0                             0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
N006 (  4,  4) [000003] -A-XG---R--                         *  ASG       ref    $204
N005 (  1,  1) [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         d:1 $VN.Void
N004 (  4,  4) [000001] ---XG------                         \--*  IND       ref    <l:$202, c:$203>
N003 (  2,  2) [000097] -------N---                            \--*  ADD       byref  $140
N001 (  1,  1) [000000] -----------                               +--*  LCL_VAR   ref    V00 this         u:1 $80
N002 (  1,  1) [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method] $100

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void
N003 (  3,  3) [000077] J------N---                         \--*  EQ        int    <l:$241, c:$240>
N001 (  1,  1) [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000076] -----------                            \--*  CNS_INT   ref    null $VN.Null

------------ BB02 [007..008) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000087] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2) [000086] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:2 $VN.Void
N001 (  1,  1) [000085] -----------                         \--*  CNS_INT   int    0 $40

------------ BB03 [???..???) -> BB14 (always), preds={} succs={BB14}

------------ BB04 [007..008), preds={BB01} succs={BB05}

***** BB04
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000082] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2) [000081] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:1 $VN.Void
N001 (  1,  1) [000080] -----------                         \--*  CNS_INT   int    1 $42

------------ BB05 [???..???) -> BB14 (always), preds={BB04} succs={BB14}

------------ BB06 [012..01A) -> BB08 (cond), preds={BB02} succs={BB07,BB08}

***** BB06
STMT00003 ( 0x012[E-] ... 0x018 )
N007 (  8,  8) [000016] ---XG------                         *  JTRUE     void   <l:$20b, c:$20a>
N006 (  6,  6) [000015] J--XG--N---                         \--*  NE        int    <l:$245, c:$244>
N004 (  4,  4) [000013] ---XG------                            +--*  IND       ref    <l:$208, c:$209>
N003 (  2,  2) [000099] -------N---                            |  \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1) [000012] -----------                            |     +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000098] -----------                            |     \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
N005 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null $VN.Null

------------ BB07 [01A..01C) -> BB14 (always), preds={BB06} succs={BB14}

------------ BB08 [01C..025) -> BB10 (always), preds={BB06} succs={BB10}

***** BB08
STMT00006 ( 0x022[--] ... ??? )
N003 ( 18,  8) [000028] -AC-----R--                         *  ASG       ref    $VN.Void
N002 (  3,  2) [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         d:1 $VN.Void
N001 ( 14,  5) [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}

***** BB10
STMT00014 ( 0x02E[E-] ... ??? )
N006 (  4,  4) [000051] -A-XG---R--                         *  ASG       ref    <l:$20b, c:$20a>
N005 (  1,  1) [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1 $VN.Void
N004 (  4,  4) [000048] ---XG------                         \--*  IND       ref    <l:$208, c:$20d>
N003 (  2,  2) [000101] -------N---                            \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1) [000049] -----------                               +--*  LCL_VAR   ref    V01 loc0         u:1 (last use) <l:$200, c:$81>
N002 (  1,  1) [000100] -----------                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101

***** BB10
STMT00015 ( 0x02E[E-] ... ??? )
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>
N005 (  7,  9) [000057] J--X---N---                         \--*  NE        int    <l:$249, c:$248>
N002 (  3,  6) [000056] #----------                            +--*  IND       long   $280
N001 (  1,  4) [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class $183
N004 (  3,  2) [000054] #--X-------                            \--*  IND       long   <l:$2c0, c:$2c1>
N003 (  1,  1) [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>

------------ BB11 [???..???) -> BB13 (always), preds={BB10} succs={BB13}

***** BB11
STMT00018 ( ??? ... ??? )
N006 (  8,  7) [000106] -A-X----R--                         *  ASG       long   <l:$211, c:$210>
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3 $VN.Void
N004 (  4,  4) [000105] ---X-------                         \--*  IND       long   <l:$2c3, c:$2c4>
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref  <l:$144, c:$143>
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle] $102

------------ BB12 [???..???), preds={BB10} succs={BB13}

***** BB12
STMT00019 ( 0x02E[E-] ... ??? )
N005 ( 26, 17) [000071] -ACXG---R--                         *  ASG       struct (copy) $VN.Void
N004 (  3,  2) [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7          $VN.Void
N003 ( 22, 14) [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value $300
N001 (  1,  1) [000053] ----------- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  4) [000107] H---------- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}

***** BB13
STMT00025 ( ??? ... ??? )
N005 (  0,  0) [000119] -A------R--                         *  ASG       long   $VN.Void
N004 (  0,  0) [000117] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:1 $VN.Void
N003 (  0,  0) [000118] -----------                         \--*  PHI       long   $380
N001 (  0,  0) [000121] ----------- pred BB11                  +--*  PHI_ARG   long   V10 tmp7         u:3 <l:$2c2, c:$284>
N002 (  0,  0) [000120] ----------- pred BB12                  \--*  PHI_ARG   long   V10 tmp7         u:2 $283

***** BB13
STMT00008 ( 0x02E[E-] ... ??? )
N006 ( 10,  8) [000112] -A-X-------                         *  ASG       long   $VN.Void
N004 (  6,  5) [000110] D--X---N---                         +--*  IND       long   $VN.Void
N003 (  4,  3) [000109] -------N---                         |  \--*  ADD       byref  $145
N001 (  3,  2) [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
N002 (  1,  1) [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle] $103
N005 (  3,  2) [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         u:1 (last use) $380

------------ BB14 [048..049) (return), preds={BB03,BB05,BB07,BB09,BB13} succs={}

***** BB14
STMT00009 ( 0x048[E-] ... 0x048 )
N001 (  0,  0) [000038] -----------                         *  RETURN    void   $VN.Void

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}

***** BB15
STMT00011 ( 0x026[E-] ... ??? )
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void
N001 (  1,  1) [000042] ----------- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         u:1 (last use) $80

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Optimize Valnum CSEs

CSE candidate #01, key=$205 in BB10, [cost= 4, size= 4]: 
N004 (  4,  4) CSE #01 (use)[000048] ---XG------                         *  IND       ref    <l:$208, c:$20d>
N003 (  2,  2)              [000101] -------N---                         \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1)              [000049] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1 (last use) <l:$200, c:$81>
N002 (  1,  1)              [000100] -----------                            \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101

Blocks that generate CSE def/uses
BB06 cseGen = 0000000000000003 CSE #01.c
BB10 cseGen = 0000000000000003 CSE #01.c

Performing DataFlow for ValnumCSE's

After performing DataFlow for ValnumCSE's
BB01 in gen out
0000000000000000 
0000000000000000 
0000000000000000 
BB02 in gen out
0000000000000000 
0000000000000000 
0000000000000000 
BB03 in gen out
0000000000000007 CSE #01.c
0000000000000000 
0000000000000007 CSE #01.c
BB04 in gen out
0000000000000000 
0000000000000000 
0000000000000000 
BB05 in gen out
0000000000000000 
0000000000000000 
0000000000000000 
BB06 in gen out
0000000000000000 
0000000000000003 CSE #01.c
0000000000000003 CSE #01.c
BB07 in gen out
0000000000000003 CSE #01.c
0000000000000000 
0000000000000003 CSE #01.c
BB08 in gen out
0000000000000003 CSE #01.c
0000000000000000 
0000000000000001 CSE #01
BB09 in gen out
0000000000000000 
0000000000000000 
0000000000000000 
BB10 in gen out
0000000000000001 CSE #01
0000000000000003 CSE #01.c
0000000000000003 CSE #01.c
BB11 in gen out
0000000000000003 CSE #01.c
0000000000000000 
0000000000000003 CSE #01.c
BB12 in gen out
0000000000000003 CSE #01.c
0000000000000000 
0000000000000001 CSE #01
BB13 in gen out
0000000000000001 CSE #01
0000000000000000 
0000000000000001 CSE #01
BB14 in gen out
0000000000000000 
0000000000000000 
0000000000000000 
BB15 in gen out
0000000000000000 
0000000000000000 
0000000000000000 

Labeling the CSEs with Use/Def information
BB06 [000013] Def of CSE #01 [weight=1   ]
BB10 [000048] Use of CSE #01 [weight=1   ] *** Now Live Across Call ***

************ Trees at start of optValnumCSE_Heuristic()

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
N006 (  4,  4)              [000003] -A-XG---R--                         *  ASG       ref    $204
N005 (  1,  1)              [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         d:1 $VN.Void
N004 (  4,  4)              [000001] ---XG------                         \--*  IND       ref    <l:$202, c:$203>
N003 (  2,  2)              [000097] -------N---                            \--*  ADD       byref  $140
N001 (  1,  1)              [000000] -----------                               +--*  LCL_VAR   ref    V00 this         u:1 $80
N002 (  1,  1)              [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method] $100

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
N004 (  5,  5)              [000078] -----------                         *  JTRUE     void   $VN.Void
N003 (  3,  3)              [000077] J------N---                         \--*  EQ        int    <l:$241, c:$240>
N001 (  1,  1)              [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1)              [000076] -----------                            \--*  CNS_INT   ref    null $VN.Null

------------ BB02 [007..008) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4)              [000087] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2)              [000086] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:2 $VN.Void
N001 (  1,  1)              [000085] -----------                         \--*  CNS_INT   int    0 $40

------------ BB03 [???..???) -> BB14 (always), preds={} succs={BB14}

------------ BB04 [007..008), preds={BB01} succs={BB05}

***** BB04
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4)              [000082] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2)              [000081] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:1 $VN.Void
N001 (  1,  1)              [000080] -----------                         \--*  CNS_INT   int    1 $42

------------ BB05 [???..???) -> BB14 (always), preds={BB04} succs={BB14}

------------ BB06 [012..01A) -> BB08 (cond), preds={BB02} succs={BB07,BB08}

***** BB06
STMT00003 ( 0x012[E-] ... 0x018 )
N007 (  8,  8)              [000016] ---XG------                         *  JTRUE     void   <l:$20b, c:$20a>
N006 (  6,  6)              [000015] J--XG--N---                         \--*  NE        int    <l:$245, c:$244>
N004 (  4,  4) CSE #01 (def)[000013] ---XG------                            +--*  IND       ref    <l:$208, c:$209>
N003 (  2,  2)              [000099] -------N---                            |  \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1)              [000012] -----------                            |     +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1)              [000098] -----------                            |     \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
N005 (  1,  1)              [000014] -----------                            \--*  CNS_INT   ref    null $VN.Null

------------ BB07 [01A..01C) -> BB14 (always), preds={BB06} succs={BB14}

------------ BB08 [01C..025) -> BB10 (always), preds={BB06} succs={BB10}

***** BB08
STMT00006 ( 0x022[--] ... ??? )
N003 ( 18,  8)              [000028] -AC-----R--                         *  ASG       ref    $VN.Void
N002 (  3,  2)              [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         d:1 $VN.Void
N001 ( 14,  5)              [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}

***** BB10
STMT00014 ( 0x02E[E-] ... ??? )
N006 (  4,  4)              [000051] -A-XG---R--                         *  ASG       ref    <l:$20b, c:$20a>
N005 (  1,  1)              [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1 $VN.Void
N004 (  4,  4) CSE #01 (use)[000048] ---XG------                         \--*  IND       ref    <l:$208, c:$20d>
N003 (  2,  2)              [000101] -------N---                            \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1)              [000049] -----------                               +--*  LCL_VAR   ref    V01 loc0         u:1 (last use) <l:$200, c:$81>
N002 (  1,  1)              [000100] -----------                               \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101

***** BB10
STMT00015 ( 0x02E[E-] ... ??? )
N006 (  9, 11)              [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>
N005 (  7,  9)              [000057] J--X---N---                         \--*  NE        int    <l:$249, c:$248>
N002 (  3,  6)              [000056] #----------                            +--*  IND       long   $280
N001 (  1,  4)              [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class $183
N004 (  3,  2)              [000054] #--X-------                            \--*  IND       long   <l:$2c0, c:$2c1>
N003 (  1,  1)              [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>

------------ BB11 [???..???) -> BB13 (always), preds={BB10} succs={BB13}

***** BB11
STMT00018 ( ??? ... ??? )
N006 (  8,  7)              [000106] -A-X----R--                         *  ASG       long   <l:$211, c:$210>
N005 (  3,  2)              [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3 $VN.Void
N004 (  4,  4)              [000105] ---X-------                         \--*  IND       long   <l:$2c3, c:$2c4>
N003 (  2,  2)              [000103] -------N---                            \--*  ADD       byref  <l:$144, c:$143>
N001 (  1,  1)              [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  1)              [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle] $102

------------ BB12 [???..???), preds={BB10} succs={BB13}

***** BB12
STMT00019 ( 0x02E[E-] ... ??? )
N005 ( 26, 17)              [000071] -ACXG---R--                         *  ASG       struct (copy) $VN.Void
N004 (  3,  2)              [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7          $VN.Void
N003 ( 22, 14)              [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value $300
N001 (  1,  1)              [000053] ----------- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  4)              [000107] H---------- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}

***** BB13
STMT00025 ( ??? ... ??? )
N005 (  0,  0)              [000119] -A------R--                         *  ASG       long   $VN.Void
N004 (  0,  0)              [000117] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:1 $VN.Void
N003 (  0,  0)              [000118] -----------                         \--*  PHI       long   $380
N001 (  0,  0)              [000121] ----------- pred BB11                  +--*  PHI_ARG   long   V10 tmp7         u:3 <l:$2c2, c:$284>
N002 (  0,  0)              [000120] ----------- pred BB12                  \--*  PHI_ARG   long   V10 tmp7         u:2 $283

***** BB13
STMT00008 ( 0x02E[E-] ... ??? )
N006 ( 10,  8)              [000112] -A-X-------                         *  ASG       long   $VN.Void
N004 (  6,  5)              [000110] D--X---N---                         +--*  IND       long   $VN.Void
N003 (  4,  3)              [000109] -------N---                         |  \--*  ADD       byref  $145
N001 (  3,  2)              [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
N002 (  1,  1)              [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle] $103
N005 (  3,  2)              [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         u:1 (last use) $380

------------ BB14 [048..049) (return), preds={BB03,BB05,BB07,BB09,BB13} succs={}

***** BB14
STMT00009 ( 0x048[E-] ... 0x048 )
N001 (  0,  0)              [000038] -----------                         *  RETURN    void   $VN.Void

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}

***** BB15
STMT00011 ( 0x026[E-] ... ??? )
N002 ( 15,  7)              [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void
N001 (  1,  1)              [000042] ----------- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         u:1 (last use) $80

-------------------------------------------------------------------------------------------------------------------


Aggressive CSE Promotion cutoff is 200.000000
Moderate CSE Promotion cutoff is 100.000000
enregCount is 7
Framesize estimate is 0x0008
We have a small frame

Sorted CSE candidates:
CSE #01, {$205, $206} useCnt=1: [def=100.000000, use=100.000000, cost=  4, call]
        :: N004 (  4,  4) CSE #01 (def)[000013] ---XG------                         *  IND       ref    <l:$208, c:$209>


Considering CSE #01 {$205, $206} [def=100.000000, use=100.000000, cost=  4, call]
CSE Expression : 
N004 (  4,  4) CSE #01 (def)[000013] ---XG------                         *  IND       ref    <l:$208, c:$209>
N003 (  2,  2)              [000099] -------N---                         \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1)              [000012] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1)              [000098] -----------                            \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101

Aggressive CSE Promotion (300.000000 >= 200.000000)
cseRefCnt=300.000000, aggressiveRefCnt=200.000000, moderateRefCnt=100.000000
defCnt=100.000000, useCnt=100.000000, cost=4, size=4, LiveAcrossCall
def_cost=1, use_cost=1, extra_no_cost=6, extra_yes_cost=100
CSE cost savings check (406.000000 >= 300.000000) passes

Promoting CSE:

lvaGrabTemp returning 12 (V12 rat0) (a long lifetime temp) called for CSE - aggressive.
CSE #01 is single-def, so associated CSE temp V12 will be in SSA
New refCnts for V12: refCnt =  2, refCntWtd = 2   
New refCnts for V12: refCnt =  3, refCntWtd = 3   

CSE #01 def at [000013] replaced in BB06 with def of V12
optValnumCSE morphed tree:
N011 (  9,  9)              [000016] -A-XG------                         *  JTRUE     void   <l:$20b, c:$20a>
N010 (  7,  7)              [000015] JA-XG--N---                         \--*  NE        int    <l:$245, c:$244>
N008 (  5,  5)              [000125] -A-XG------                            +--*  COMMA     ref    <l:$208, c:$209>
N006 (  4,  4) CSE #01 (def)[000123] -A-XG---R--                            |  +--*  ASG       ref    $VN.Void
N005 (  1,  1)              [000122] D------N---                            |  |  +--*  LCL_VAR   ref    V12 cse0         d:1 <l:$208, c:$209>
N004 (  4,  4)              [000013] ---XG------                            |  |  \--*  IND       ref    <l:$208, c:$209>
N003 (  2,  2)              [000099] -------N---                            |  |     \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1)              [000012] -----------                            |  |        +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1)              [000098] -----------                            |  |        \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
N007 (  1,  1)              [000124] -----------                            |  \--*  LCL_VAR   ref    V12 cse0         u:1 <l:$208, c:$209>
N009 (  1,  1)              [000014] -----------                            \--*  CNS_INT   ref    null $VN.Null


Working on the replacement of the CSE #01 use at [000048] in BB10
optValnumCSE morphed tree:
N003 (  1,  3)              [000051] -A--G---R--                         *  ASG       ref    <l:$20b, c:$20a>
N002 (  1,  1)              [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1 $VN.Void
N001 (  1,  1)              [000126] -----------                         \--*  LCL_VAR   ref    V12 cse0         u:1 <l:$205, c:$83>


*************** Finishing PHASE Optimize Valnum CSEs

*************** Starting PHASE Assertion prop
*************** In optAssertionPropMain()
Blocks/Trees at start of phase

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 (always)                     i IBC 
BB03 [0036]  0                             0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
N006 (  4,  4) [000003] -A-XG---R--                         *  ASG       ref    $204
N005 (  1,  1) [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         d:1 $VN.Void
N004 (  4,  4) [000001] ---XG------                         \--*  IND       ref    <l:$202, c:$203>
N003 (  2,  2) [000097] -------N---                            \--*  ADD       byref  $140
N001 (  1,  1) [000000] -----------                               +--*  LCL_VAR   ref    V00 this         u:1 $80
N002 (  1,  1) [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method] $100

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void
N003 (  3,  3) [000077] J------N---                         \--*  EQ        int    <l:$241, c:$240>
N001 (  1,  1) [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000076] -----------                            \--*  CNS_INT   ref    null $VN.Null

------------ BB02 [007..008) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000087] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2) [000086] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:2 $VN.Void
N001 (  1,  1) [000085] -----------                         \--*  CNS_INT   int    0 $40

------------ BB03 [???..???) -> BB14 (always), preds={} succs={BB14}

------------ BB04 [007..008), preds={BB01} succs={BB05}

***** BB04
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000082] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2) [000081] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:1 $VN.Void
N001 (  1,  1) [000080] -----------                         \--*  CNS_INT   int    1 $42

------------ BB05 [???..???) -> BB14 (always), preds={BB04} succs={BB14}

------------ BB06 [012..01A) -> BB08 (cond), preds={BB02} succs={BB07,BB08}

***** BB06
STMT00003 ( 0x012[E-] ... 0x018 )
N011 (  9,  9) [000016] -A-XG------                         *  JTRUE     void   <l:$20b, c:$20a>
N010 (  7,  7) [000015] JA-XG--N---                         \--*  NE        int    <l:$245, c:$244>
N008 (  5,  5) [000125] -A-XG------                            +--*  COMMA     ref    <l:$208, c:$209>
N006 (  4,  4) [000123] -A-XG---R--                            |  +--*  ASG       ref    $VN.Void
N005 (  1,  1) [000122] D------N---                            |  |  +--*  LCL_VAR   ref    V12 cse0         d:1 <l:$208, c:$209>
N004 (  4,  4) [000013] ---XG------                            |  |  \--*  IND       ref    <l:$208, c:$209>
N003 (  2,  2) [000099] -------N---                            |  |     \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1) [000012] -----------                            |  |        +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000098] -----------                            |  |        \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
N007 (  1,  1) [000124] -----------                            |  \--*  LCL_VAR   ref    V12 cse0         u:1 <l:$208, c:$209>
N009 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null $VN.Null

------------ BB07 [01A..01C) -> BB14 (always), preds={BB06} succs={BB14}

------------ BB08 [01C..025) -> BB10 (always), preds={BB06} succs={BB10}

***** BB08
STMT00006 ( 0x022[--] ... ??? )
N003 ( 18,  8) [000028] -AC-----R--                         *  ASG       ref    $VN.Void
N002 (  3,  2) [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         d:1 $VN.Void
N001 ( 14,  5) [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}

***** BB10
STMT00014 ( 0x02E[E-] ... ??? )
N003 (  1,  3) [000051] -A--G---R--                         *  ASG       ref    <l:$20b, c:$20a>
N002 (  1,  1) [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1 $VN.Void
N001 (  1,  1) [000126] -----------                         \--*  LCL_VAR   ref    V12 cse0         u:1 <l:$205, c:$83>

***** BB10
STMT00015 ( 0x02E[E-] ... ??? )
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>
N005 (  7,  9) [000057] J--X---N---                         \--*  NE        int    <l:$249, c:$248>
N002 (  3,  6) [000056] #----------                            +--*  IND       long   $280
N001 (  1,  4) [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class $183
N004 (  3,  2) [000054] #--X-------                            \--*  IND       long   <l:$2c0, c:$2c1>
N003 (  1,  1) [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>

------------ BB11 [???..???) -> BB13 (always), preds={BB10} succs={BB13}

***** BB11
STMT00018 ( ??? ... ??? )
N006 (  8,  7) [000106] -A-X----R--                         *  ASG       long   <l:$211, c:$210>
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3 $VN.Void
N004 (  4,  4) [000105] ---X-------                         \--*  IND       long   <l:$2c3, c:$2c4>
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref  <l:$144, c:$143>
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle] $102

------------ BB12 [???..???), preds={BB10} succs={BB13}

***** BB12
STMT00019 ( 0x02E[E-] ... ??? )
N005 ( 26, 17) [000071] -ACXG---R--                         *  ASG       struct (copy) $VN.Void
N004 (  3,  2) [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7          $VN.Void
N003 ( 22, 14) [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value $300
N001 (  1,  1) [000053] ----------- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  4) [000107] H---------- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}

***** BB13
STMT00025 ( ??? ... ??? )
N005 (  0,  0) [000119] -A------R--                         *  ASG       long   $VN.Void
N004 (  0,  0) [000117] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:1 $VN.Void
N003 (  0,  0) [000118] -----------                         \--*  PHI       long   $380
N001 (  0,  0) [000121] ----------- pred BB11                  +--*  PHI_ARG   long   V10 tmp7         u:3 <l:$2c2, c:$284>
N002 (  0,  0) [000120] ----------- pred BB12                  \--*  PHI_ARG   long   V10 tmp7         u:2 $283

***** BB13
STMT00008 ( 0x02E[E-] ... ??? )
N006 ( 10,  8) [000112] -A-X-------                         *  ASG       long   $VN.Void
N004 (  6,  5) [000110] D--X---N---                         +--*  IND       long   $VN.Void
N003 (  4,  3) [000109] -------N---                         |  \--*  ADD       byref  $145
N001 (  3,  2) [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
N002 (  1,  1) [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle] $103
N005 (  3,  2) [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         u:1 (last use) $380

------------ BB14 [048..049) (return), preds={BB03,BB05,BB07,BB09,BB13} succs={}

***** BB14
STMT00009 ( 0x048[E-] ... 0x048 )
N001 (  0,  0) [000038] -----------                         *  RETURN    void   $VN.Void

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}

***** BB15
STMT00011 ( 0x026[E-] ... ??? )
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void
N001 (  1,  1) [000042] ----------- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         u:1 (last use) $80

-------------------------------------------------------------------------------------------------------------------
GenTreeNode creates assertion:
N004 (  4,  4) [000001] ---XG------                         *  IND       ref    <l:$202, c:$203>
In BB01 New Global Constant Assertion: ($80,$0) V00.01 != null, index = #01
GenTreeNode creates assertion:
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void
In BB01 New Global Constant Assertion: ($81,$0) V01.01 == null, index = #02
GenTreeNode creates assertion:
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void
In BB01 New Global Constant Assertion: ($81,$0) V01.01 != null, index = #03
GenTreeNode creates assertion:
N004 (  4,  4) [000013] ---XG------                         *  IND       ref    <l:$208, c:$209>
In BB06 New Global Constant Assertion: ($81,$0) V01.01 != null, index = #04
GenTreeNode creates assertion:
N004 (  3,  2) [000054] #--X-------                         *  IND       long   <l:$2c0, c:$2c1>
In BB10 New Global Constant Assertion: ($87,$0) V07.01 != null, index = #05
GenTreeNode creates assertion:
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>
In BB10 New Global Type     Assertion: ($87,$183) V07.01 is not Exact Type MT(004258B8), index = #06
GenTreeNode creates assertion:
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>
In BB10 New Global Type     Assertion: ($87,$183) V07.01 is Exact Type MT(004258B8), index = #07

VN based non-null prop in BB13:
N004 (  6,  5) [000110] D--X---N---                         *  IND       long   $VN.Void
optVNAssertionPropCurStmt morphed tree:
N006 ( 10,  8) [000112] -A---O-----                         *  ASG       long   $VN.Void
N004 (  6,  5) [000110] n----O-N---                         +--*  IND       long   $VN.Void
N003 (  4,  3) [000109] -------N---                         |  \--*  ADD       byref  $145
N001 (  3,  2) [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
N002 (  1,  1) [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle] $103
N005 (  3,  2) [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         u:1 (last use) $380

GenTreeNode creates assertion:
N006 ( 10,  8) [000112] -A---O-----                         *  ASG       long   $VN.Void
In BB13 New Global Constant Assertion: ($20c,$0) V02.01 != null, index = #08

BB01 valueGen = #01 #03 => BB04 valueGen = #01 #02
BB02 valueGen = #NA
BB03 valueGen = #NA
BB04 valueGen = #NA
BB05 valueGen = #NA
BB06 valueGen = #04 => BB08 valueGen = #04
BB07 valueGen = #NA
BB08 valueGen = #NA
BB09 valueGen = #NA
BB10 valueGen = #05 #07 => BB12 valueGen = #05 #06
BB11 valueGen = #05
BB12 valueGen = #05
BB13 valueGen = #08
BB14 valueGen = #NA
BB15 valueGen = #NA

BB01:
 in   = #NA
 out  = #01 #03
 BB04 = #01 #02
BB02:
 in   = #01 #03
 out  = #01 #03
BB03:
 in   = #01 #02 #03 #04 #05 #06 #07 #08
 out  = #01 #02 #03 #04 #05 #06 #07 #08
BB04:
 in   = #01 #02
 out  = #01 #02
BB05:
 in   = #01 #02
 out  = #01 #02
BB06:
 in   = #01 #03
 out  = #01 #03 #04
 BB08 = #01 #03 #04
BB07:
 in   = #01 #03 #04
 out  = #01 #03 #04
BB08:
 in   = #01 #03 #04
 out  = #01 #03 #04
BB09:
 in   = #01 #03 #04
 out  = #01 #03 #04
BB10:
 in   = #01 #03 #04
 out  = #01 #03 #04 #05 #07
 BB12 = #01 #03 #04 #05 #06
BB11:
 in   = #01 #03 #04 #05 #07
 out  = #01 #03 #04 #05 #07
BB12:
 in   = #01 #03 #04 #05 #06
 out  = #01 #03 #04 #05 #06
BB13:
 in   = #01 #03 #04 #05
 out  = #01 #03 #04 #05 #08
BB14:
 in   = #01
 out  = #01
BB15:
 in   = #01 #03 #04
 out  = #01 #03 #04

Propagating #NA for BB01, stmt STMT00000, tree [000000], tree -> #NA
Propagating #NA for BB01, stmt STMT00000, tree [000096], tree -> #NA
Propagating #NA for BB01, stmt STMT00000, tree [000097], tree -> #NA
Propagating #NA for BB01, stmt STMT00000, tree [000001], tree -> #01
Propagating #01 for BB01, stmt STMT00000, tree [000002], tree -> #NA
Propagating #01 for BB01, stmt STMT00000, tree [000003], tree -> #NA
Propagating #01 for BB01, stmt STMT00020, tree [000004], tree -> #NA
Propagating #01 for BB01, stmt STMT00020, tree [000076], tree -> #NA
Propagating #01 for BB01, stmt STMT00020, tree [000077], tree -> #NA
Propagating #01 for BB01, stmt STMT00020, tree [000078], tree -> #02
Propagating #01 #03 for BB02, stmt STMT00022, tree [000085], tree -> #NA
Propagating #01 #03 for BB02, stmt STMT00022, tree [000086], tree -> #NA
Propagating #01 #03 for BB02, stmt STMT00022, tree [000087], tree -> #NA
Propagating #01 #02 for BB04, stmt STMT00021, tree [000080], tree -> #NA
Propagating #01 #02 for BB04, stmt STMT00021, tree [000081], tree -> #NA
Propagating #01 #02 for BB04, stmt STMT00021, tree [000082], tree -> #NA
Propagating #01 #03 for BB06, stmt STMT00003, tree [000012], tree -> #NA
Propagating #01 #03 for BB06, stmt STMT00003, tree [000098], tree -> #NA
Propagating #01 #03 for BB06, stmt STMT00003, tree [000099], tree -> #NA
Propagating #01 #03 for BB06, stmt STMT00003, tree [000013], tree -> #04

VN based non-null prop in BB06:
N004 (  4,  4) [000013] ---XG------                         *  IND       ref    <l:$208, c:$209>
Propagating #01 #03 #04 for BB06, stmt STMT00003, tree [000122], tree -> #NA
Propagating #01 #03 #04 for BB06, stmt STMT00003, tree [000123], tree -> #NA
Propagating #01 #03 #04 for BB06, stmt STMT00003, tree [000124], tree -> #NA
Propagating #01 #03 #04 for BB06, stmt STMT00003, tree [000125], tree -> #NA
Propagating #01 #03 #04 for BB06, stmt STMT00003, tree [000014], tree -> #NA
Propagating #01 #03 #04 for BB06, stmt STMT00003, tree [000015], tree -> #NA
Propagating #01 #03 #04 for BB06, stmt STMT00003, tree [000016], tree -> #NA
Re-morphing this stmt:
STMT00003 ( 0x012[E-] ... 0x018 )
N011 (  9,  9) [000016] -A-XG------                         *  JTRUE     void   <l:$20b, c:$20a>
N010 (  7,  7) [000015] JA-XG--N---                         \--*  NE        int    <l:$245, c:$244>
N008 (  5,  5) [000125] -A-XG------                            +--*  COMMA     ref    <l:$208, c:$209>
N006 (  4,  4) [000123] -A-XG---R--                            |  +--*  ASG       ref    $VN.Void
N005 (  1,  1) [000122] D------N---                            |  |  +--*  LCL_VAR   ref    V12 cse0         d:1 <l:$208, c:$209>
N004 (  4,  4) [000013] n---GO-----                            |  |  \--*  IND       ref    <l:$208, c:$209>
N003 (  2,  2) [000099] -------N---                            |  |     \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1) [000012] -----------                            |  |        +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000098] -----------                            |  |        \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
N007 (  1,  1) [000124] -----------                            |  \--*  LCL_VAR   ref    V12 cse0         u:1 <l:$208, c:$209>
N009 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null $VN.Null

optAssertionPropMain morphed tree:
N011 (  9,  9) [000016] -A--GO-----                         *  JTRUE     void   <l:$20b, c:$20a>
N010 (  7,  7) [000015] JA--GO-N---                         \--*  NE        int    <l:$245, c:$244>
N008 (  5,  5) [000125] -A--GO-----                            +--*  COMMA     ref    <l:$208, c:$209>
N006 (  4,  4) [000123] -A--GO--R--                            |  +--*  ASG       ref    $VN.Void
N005 (  1,  1) [000122] D------N---                            |  |  +--*  LCL_VAR   ref    V12 cse0         d:1 <l:$208, c:$209>
N004 (  4,  4) [000013] n---GO-----                            |  |  \--*  IND       ref    <l:$208, c:$209>
N003 (  2,  2) [000099] -------N---                            |  |     \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1) [000012] -----------                            |  |        +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000098] -----------                            |  |        \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
N007 (  1,  1) [000124] -----------                            |  \--*  LCL_VAR   ref    V12 cse0         u:1 <l:$208, c:$209>
N009 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null $VN.Null

Propagating #01 #03 #04 for BB08, stmt STMT00006, tree [000021], tree -> #NA
Propagating #01 #03 #04 for BB08, stmt STMT00006, tree [000027], tree -> #NA
Propagating #01 #03 #04 for BB08, stmt STMT00006, tree [000028], tree -> #NA
Propagating #01 #03 #04 for BB10, stmt STMT00014, tree [000126], tree -> #NA
Propagating #01 #03 #04 for BB10, stmt STMT00014, tree [000050], tree -> #NA
Propagating #01 #03 #04 for BB10, stmt STMT00014, tree [000051], tree -> #NA
Propagating #01 #03 #04 for BB10, stmt STMT00015, tree [000055], tree -> #NA
Propagating #01 #03 #04 for BB10, stmt STMT00015, tree [000056], tree -> #NA
Propagating #01 #03 #04 for BB10, stmt STMT00015, tree [000052], tree -> #NA
Propagating #01 #03 #04 for BB10, stmt STMT00015, tree [000054], tree -> #05
Propagating #01 #03 #04 #05 for BB10, stmt STMT00015, tree [000057], tree -> #NA
Propagating #01 #03 #04 #05 for BB10, stmt STMT00015, tree [000058], tree -> #06
Propagating #01 #03 #04 #05 #07 for BB11, stmt STMT00018, tree [000059], tree -> #NA
Propagating #01 #03 #04 #05 #07 for BB11, stmt STMT00018, tree [000102], tree -> #NA
Propagating #01 #03 #04 #05 #07 for BB11, stmt STMT00018, tree [000103], tree -> #NA
Propagating #01 #03 #04 #05 #07 for BB11, stmt STMT00018, tree [000105], tree -> #05

VN based non-null prop in BB11:
N004 (  4,  4) [000105] ---X-------                         *  IND       long   <l:$2c3, c:$2c4>
Propagating #01 #03 #04 #05 #07 for BB11, stmt STMT00018, tree [000104], tree -> #NA
Propagating #01 #03 #04 #05 #07 for BB11, stmt STMT00018, tree [000106], tree -> #NA
Re-morphing this stmt:
STMT00018 ( ??? ... ??? )
N006 (  8,  7) [000106] -A-X----R--                         *  ASG       long   <l:$211, c:$210>
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3 $VN.Void
N004 (  4,  4) [000105] n----O-----                         \--*  IND       long   <l:$2c3, c:$2c4>
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref  <l:$144, c:$143>
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle] $102

optAssertionPropMain morphed tree:
N006 (  8,  7) [000106] -A---O--R--                         *  ASG       long   <l:$211, c:$210>
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3 $VN.Void
N004 (  4,  4) [000105] n----O-----                         \--*  IND       long   <l:$2c3, c:$2c4>
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref  <l:$144, c:$143>
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle] $102

Propagating #01 #03 #04 #05 #06 for BB12, stmt STMT00019, tree [000053], tree -> #NA
Propagating #01 #03 #04 #05 #06 for BB12, stmt STMT00019, tree [000107], tree -> #NA
Propagating #01 #03 #04 #05 #06 for BB12, stmt STMT00019, tree [000032], tree -> #05
Propagating #01 #03 #04 #05 #06 for BB12, stmt STMT00019, tree [000069], tree -> #NA
Propagating #01 #03 #04 #05 #06 for BB12, stmt STMT00019, tree [000071], tree -> #NA
Propagating #01 #03 #04 #05 for BB13, stmt STMT00008, tree [000029], tree -> #NA
Propagating #01 #03 #04 #05 for BB13, stmt STMT00008, tree [000108], tree -> #NA
Propagating #01 #03 #04 #05 for BB13, stmt STMT00008, tree [000109], tree -> #NA
Propagating #01 #03 #04 #05 for BB13, stmt STMT00008, tree [000110], tree -> #NA
Propagating #01 #03 #04 #05 for BB13, stmt STMT00008, tree [000111], tree -> #NA
Propagating #01 #03 #04 #05 for BB13, stmt STMT00008, tree [000112], tree -> #08
Propagating #01 for BB14, stmt STMT00009, tree [000038], tree -> #NA
Propagating #01 #03 #04 for BB15, stmt STMT00011, tree [000042], tree -> #NA
Propagating #01 #03 #04 for BB15, stmt STMT00011, tree [000043], tree -> #NA
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Assertion prop

*************** Starting PHASE Optimize index checks
*************** In OptimizeRangeChecks()
Blocks/trees before phase

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 (always)                     i IBC 
BB03 [0036]  0                             0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
N006 (  4,  4) [000003] -A-XG---R--                         *  ASG       ref    $204
N005 (  1,  1) [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         d:1 $VN.Void
N004 (  4,  4) [000001] ---XG------                         \--*  IND       ref    <l:$202, c:$203>
N003 (  2,  2) [000097] -------N---                            \--*  ADD       byref  $140
N001 (  1,  1) [000000] -----------                               +--*  LCL_VAR   ref    V00 this         u:1 $80
N002 (  1,  1) [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method] $100

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void
N003 (  3,  3) [000077] J------N---                         \--*  EQ        int    <l:$241, c:$240>
N001 (  1,  1) [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000076] -----------                            \--*  CNS_INT   ref    null $VN.Null

------------ BB02 [007..008) -> BB06 (always), preds={BB01} succs={BB06}

***** BB02
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000087] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2) [000086] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:2 $VN.Void
N001 (  1,  1) [000085] -----------                         \--*  CNS_INT   int    0 $40

------------ BB03 [???..???) -> BB14 (always), preds={} succs={BB14}

------------ BB04 [007..008), preds={BB01} succs={BB05}

***** BB04
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000082] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2) [000081] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:1 $VN.Void
N001 (  1,  1) [000080] -----------                         \--*  CNS_INT   int    1 $42

------------ BB05 [???..???) -> BB14 (always), preds={BB04} succs={BB14}

------------ BB06 [012..01A) -> BB08 (cond), preds={BB02} succs={BB07,BB08}

***** BB06
STMT00003 ( 0x012[E-] ... 0x018 )
N011 (  9,  9) [000016] -A--GO-----                         *  JTRUE     void   <l:$20b, c:$20a>
N010 (  7,  7) [000015] JA--GO-N---                         \--*  NE        int    <l:$245, c:$244>
N008 (  5,  5) [000125] -A--GO-----                            +--*  COMMA     ref    <l:$208, c:$209>
N006 (  4,  4) [000123] -A--GO--R--                            |  +--*  ASG       ref    $VN.Void
N005 (  1,  1) [000122] D------N---                            |  |  +--*  LCL_VAR   ref    V12 cse0         d:1 <l:$208, c:$209>
N004 (  4,  4) [000013] n---GO-----                            |  |  \--*  IND       ref    <l:$208, c:$209>
N003 (  2,  2) [000099] -------N---                            |  |     \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1) [000012] -----------                            |  |        +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000098] -----------                            |  |        \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
N007 (  1,  1) [000124] -----------                            |  \--*  LCL_VAR   ref    V12 cse0         u:1 <l:$208, c:$209>
N009 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null $VN.Null

------------ BB07 [01A..01C) -> BB14 (always), preds={BB06} succs={BB14}

------------ BB08 [01C..025) -> BB10 (always), preds={BB06} succs={BB10}

***** BB08
STMT00006 ( 0x022[--] ... ??? )
N003 ( 18,  8) [000028] -AC-----R--                         *  ASG       ref    $VN.Void
N002 (  3,  2) [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         d:1 $VN.Void
N001 ( 14,  5) [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}

***** BB10
STMT00014 ( 0x02E[E-] ... ??? )
N003 (  1,  3) [000051] -A--G---R--                         *  ASG       ref    <l:$20b, c:$20a>
N002 (  1,  1) [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1 $VN.Void
N001 (  1,  1) [000126] -----------                         \--*  LCL_VAR   ref    V12 cse0         u:1 <l:$205, c:$83>

***** BB10
STMT00015 ( 0x02E[E-] ... ??? )
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>
N005 (  7,  9) [000057] J--X---N---                         \--*  NE        int    <l:$249, c:$248>
N002 (  3,  6) [000056] #----------                            +--*  IND       long   $280
N001 (  1,  4) [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class $183
N004 (  3,  2) [000054] #--X-------                            \--*  IND       long   <l:$2c0, c:$2c1>
N003 (  1,  1) [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>

------------ BB11 [???..???) -> BB13 (always), preds={BB10} succs={BB13}

***** BB11
STMT00018 ( ??? ... ??? )
N006 (  8,  7) [000106] -A---O--R--                         *  ASG       long   <l:$211, c:$210>
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3 $VN.Void
N004 (  4,  4) [000105] n----O-----                         \--*  IND       long   <l:$2c3, c:$2c4>
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref  <l:$144, c:$143>
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle] $102

------------ BB12 [???..???), preds={BB10} succs={BB13}

***** BB12
STMT00019 ( 0x02E[E-] ... ??? )
N005 ( 26, 17) [000071] -ACXG---R--                         *  ASG       struct (copy) $VN.Void
N004 (  3,  2) [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7          $VN.Void
N003 ( 22, 14) [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value $300
N001 (  1,  1) [000053] ----------- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  4) [000107] H---------- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}

***** BB13
STMT00025 ( ??? ... ??? )
N005 (  0,  0) [000119] -A------R--                         *  ASG       long   $VN.Void
N004 (  0,  0) [000117] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:1 $VN.Void
N003 (  0,  0) [000118] -----------                         \--*  PHI       long   $380
N001 (  0,  0) [000121] ----------- pred BB11                  +--*  PHI_ARG   long   V10 tmp7         u:3 <l:$2c2, c:$284>
N002 (  0,  0) [000120] ----------- pred BB12                  \--*  PHI_ARG   long   V10 tmp7         u:2 $283

***** BB13
STMT00008 ( 0x02E[E-] ... ??? )
N006 ( 10,  8) [000112] -A---O-----                         *  ASG       long   $VN.Void
N004 (  6,  5) [000110] n----O-N---                         +--*  IND       long   $VN.Void
N003 (  4,  3) [000109] -------N---                         |  \--*  ADD       byref  $145
N001 (  3,  2) [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
N002 (  1,  1) [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle] $103
N005 (  3,  2) [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         u:1 (last use) $380

------------ BB14 [048..049) (return), preds={BB03,BB05,BB07,BB09,BB13} succs={}

***** BB14
STMT00009 ( 0x048[E-] ... 0x048 )
N001 (  0,  0) [000038] -----------                         *  RETURN    void   $VN.Void

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}

***** BB15
STMT00011 ( 0x026[E-] ... ??? )
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void
N001 (  1,  1) [000042] ----------- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         u:1 (last use) $80

-------------------------------------------------------------------------------------------------------------------

*************** Finishing PHASE Optimize index checks

*************** Starting PHASE Update flow graph opt pass

*************** In fgUpdateFlowGraph()
Before updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 (always)                     i IBC 
BB03 [0036]  0                             0.63  54    [???..???)-> BB14 (always)                     internal IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  5       BB03,BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

fgRemoveBlock BB03, unreachable=true

Removing unreachable BB03

After updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 (always)                     i IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  4       BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB08..BB08 [01D..025), Handler at BB15..BB15 [025..02E)
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Update flow graph opt pass

*************** Starting PHASE Compute edge weights (2, false)
Initial weight assignments

Updated min weight of BB04 -> BB05 to [18.46684..18.46684]
Updated max weight of BB04 -> BB05 to [18.46684..18.46684]
Updated min weight of BB02 -> BB06 to [53.76103..3.402823e+38]
Updated max weight of BB02 -> BB06 to [53.76103..53.76103]
Setting edge weights for BB15 -> BB09 to [0 .. 3.402823e+38]
Updated min weight of BB15 -> BB09 to [0..3.402823e+38]
Updated max weight of BB15 -> BB09 to [0..0]
Updated min weight of BB08 -> BB10 to [85..85]
Updated max weight of BB08 -> BB10 to [85..85]
Updated min weight of BB11 -> BB13 to [85..85]
Updated max weight of BB11 -> BB13 to [85..85]
Updated min weight of BB12 -> BB13 to [0..0]
Updated max weight of BB12 -> BB13 to [0..0]
Updated min weight of BB05 -> BB14 to [85..3.402823e+38]
Updated max weight of BB05 -> BB14 to [85..85]
Updated min weight of BB07 -> BB14 to [0..0]
Updated max weight of BB07 -> BB14 to [0..0]
Setting edge weights for BB09 -> BB14 to [0 .. 3.402823e+38]
Updated min weight of BB09 -> BB14 to [0..3.402823e+38]
Updated max weight of BB09 -> BB14 to [0..0]
Updated min weight of BB13 -> BB14 to [85..85]
Updated max weight of BB13 -> BB14 to [85..85]

Solver pass 0

 -- step 1 --
Not adjusting min weight of BB01 -> BB02; new value 66.53316 not in range [0..53.76103] (+/- 2.164062)
Not adjusting min weight of BB01 -> BB04; new value 31.23897 not in range [0..18.46684] (+/- 2.164062)
fgComputeEdgeWeights() found inconsistent profile data, not using the edge weights

*************** Finishing PHASE Compute edge weights (2, false)

*************** Starting PHASE Insert GC Polls

*************** Finishing PHASE Insert GC Polls [no changes]

*************** Starting PHASE Optimize layout

*************** In fgUpdateFlowGraph()
Before updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 (always)                     i IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  4       BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** In fgDebugCheckBBlist

*************** In fgExpandRarelyRunBlocks()
*************** In fgReorderBlocks()

Initial BasicBlocks
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)-> BB06 (always)                     i IBC 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB07 [0003]  1       BB06                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  4       BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

Decided to straighten unconditional branch at block BB02 branch to BB06 because of IBC profile data
Relocated hot block BB06
Relocated block [BB06..BB06] inserted after BB02
Changed an unconditional jump from BB02 to the next block BB06 into a BBJ_NONE block
New Basic Block BB16 [0037] created.
Setting edge weights for BB06 -> BB16 to [0 .. 3.402823e+38]
Added an unconditional jump to BB07 after block BB06

After this change in fgReorderBlocks the BB graph is:
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)                                     i IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB08 ( cond )                     i IBC 
BB16 [0037]  1       BB06                  0           [???..???)-> BB07 (always)                     internal rare 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB07 [0003]  1       BB16                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB06                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  4       BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

Decided to reverse conditional branch at block BB06 branch to BB08 since it falls into a rarely run block
Relocated rarely run block BB16 by reversing conditional jump at BB06
Rethreading STMT00003
Relocated block [BB16..BB16] inserted after BB14
New Basic Block BB17 [0038] created.
Setting edge weights for BB06 -> BB17 to [0 .. 3.402823e+38]
Added an unconditional jump to BB08 after block BB06

After this change in fgReorderBlocks the BB graph is:
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)                                     i IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB16 ( cond )                     i IBC 
BB17 [0038]  1       BB06                  1           [???..???)-> BB08 (always)                     internal 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB07 [0003]  1       BB16                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  4       BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
BB16 [0037]  1       BB06                  0           [???..???)-> BB07 (always)                     internal rare 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

Decided to relocate block(s) after block BB05 since they are rarely run block(s)
Relocated rarely run block BB07
Relocated block [BB07..BB07] inserted after BB16
Changed an unconditional jump from BB16 to the next block BB07 into a BBJ_NONE block

After this change in fgReorderBlocks the BB graph is:
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)                                     i IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB16 ( cond )                     i IBC 
BB17 [0038]  1       BB06                  1           [???..???)-> BB08 (always)                     internal 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)-> BB10 (always) T0      try { }     keep i try hascall newobj IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  4       BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
BB16 [0037]  1       BB06                  0           [???..???)                                     internal rare 
BB07 [0003]  1       BB16                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

Decided to straighten unconditional branch at block BB08 branch to BB10 since it is succeeded by a rarely run block
Relocated rarely run block BB09
Relocated block [BB09..BB09] inserted after BB07
Changed an unconditional jump from BB08 to the next block BB10 into a BBJ_NONE block

After this change in fgReorderBlocks the BB graph is:
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)                                     i IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB16 ( cond )                     i IBC 
BB17 [0038]  1       BB06                  1           [???..???)-> BB08 (always)                     internal 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)-> BB13 (always)                     i internal IBC 
BB12 [0021]  1       BB10                  0      0    [???..???)                                     i internal rare hascall gcsafe IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  4       BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
BB16 [0037]  1       BB06                  0           [???..???)                                     internal rare 
BB07 [0003]  1       BB16                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

Decided to straighten unconditional branch at block BB11 branch to BB13 because of IBC profile data
Relocated rarely run block BB12
Relocated block [BB12..BB12] inserted after BB09
Changed an unconditional jump from BB11 to the next block BB13 into a BBJ_NONE block
Block BB12 ended with a BBJ_NONE, Changed to an unconditional jump to BB13

After this change in fgReorderBlocks the BB graph is:
-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)                                     i IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB16 ( cond )                     i IBC 
BB17 [0038]  1       BB06                  1           [???..???)-> BB08 (always)                     internal 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  4       BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
BB16 [0037]  1       BB06                  0           [???..???)                                     internal rare 
BB07 [0003]  1       BB16                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------


*************** In fgUpdateFlowGraph()
Before updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  0.63  54    [007..008)                                     i IBC 
BB06 [0002]  1       BB02                  1     85    [012..01A)-> BB16 ( cond )                     i IBC 
BB17 [0038]  1       BB06                  1           [???..???)-> BB08 (always)                     internal 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  4       BB05,BB07,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
BB16 [0037]  1       BB06                  0           [???..???)                                     internal rare 
BB07 [0003]  1       BB16                  0      0    [01A..01C)-> BB14 (always)                     i rare IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------


Compacting blocks BB02 and BB06:
*************** In fgDebugCheckBBlist

Compacting blocks BB16 and BB07:
*************** In fgDebugCheckBBlist

Optimizing a jump to an unconditional jump (BB02 -> BB16 -> BB14)
Setting edge weights for BB02 -> BB14 to [0 .. 3.402823e+38]
fgRemoveBlock BB16, unreachable=true

Removing unreachable BB16

After updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  4       BB02,BB05,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB08..BB08 [01D..025), Handler at BB15..BB15 [025..02E)
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Optimize layout
Trees after Optimize layout

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  4       BB02,BB05,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
N006 (  4,  4) [000003] -A-XG---R--                         *  ASG       ref    $204
N005 (  1,  1) [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         d:1 $VN.Void
N004 (  4,  4) [000001] ---XG------                         \--*  IND       ref    <l:$202, c:$203>
N003 (  2,  2) [000097] -------N---                            \--*  ADD       byref  $140
N001 (  1,  1) [000000] -----------                               +--*  LCL_VAR   ref    V00 this         u:1 $80
N002 (  1,  1) [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method] $100

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void
N003 (  3,  3) [000077] J------N---                         \--*  EQ        int    <l:$241, c:$240>
N001 (  1,  1) [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000076] -----------                            \--*  CNS_INT   ref    null $VN.Null

------------ BB02 [007..01A) -> BB14 (cond), preds={BB01} succs={BB17,BB14}

***** BB02
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000087] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2) [000086] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:2 $VN.Void
N001 (  1,  1) [000085] -----------                         \--*  CNS_INT   int    0 $40

***** BB02
STMT00003 ( 0x012[E-] ... 0x018 )
N011 (  9,  9) [000016] -A--GO-----                         *  JTRUE     void   <l:$20b, c:$20a>
N010 (  7,  7) [000015] JA--GO-N---                         \--*  EQ        int   
N008 (  5,  5) [000125] -A--GO-----                            +--*  COMMA     ref    <l:$208, c:$209>
N006 (  4,  4) [000123] -A--GO--R--                            |  +--*  ASG       ref    $VN.Void
N005 (  1,  1) [000122] D------N---                            |  |  +--*  LCL_VAR   ref    V12 cse0         d:1 <l:$208, c:$209>
N004 (  4,  4) [000013] n---GO-----                            |  |  \--*  IND       ref    <l:$208, c:$209>
N003 (  2,  2) [000099] -------N---                            |  |     \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1) [000012] -----------                            |  |        +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000098] -----------                            |  |        \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
N007 (  1,  1) [000124] -----------                            |  \--*  LCL_VAR   ref    V12 cse0         u:1 <l:$208, c:$209>
N009 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null $VN.Null

------------ BB17 [???..???) -> BB08 (always), preds={BB02} succs={BB08}

------------ BB04 [007..008), preds={BB01} succs={BB05}

***** BB04
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000082] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2) [000081] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:1 $VN.Void
N001 (  1,  1) [000080] -----------                         \--*  CNS_INT   int    1 $42

------------ BB05 [???..???) -> BB14 (always), preds={BB04} succs={BB14}

------------ BB08 [01C..025), preds={BB17} succs={BB10}

***** BB08
STMT00006 ( 0x022[--] ... ??? )
N003 ( 18,  8) [000028] -AC-----R--                         *  ASG       ref    $VN.Void
N002 (  3,  2) [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         d:1 $VN.Void
N001 ( 14,  5) [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}

***** BB10
STMT00014 ( 0x02E[E-] ... ??? )
N003 (  1,  3) [000051] -A--G---R--                         *  ASG       ref    <l:$20b, c:$20a>
N002 (  1,  1) [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1 $VN.Void
N001 (  1,  1) [000126] -----------                         \--*  LCL_VAR   ref    V12 cse0         u:1 <l:$205, c:$83>

***** BB10
STMT00015 ( 0x02E[E-] ... ??? )
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>
N005 (  7,  9) [000057] J--X---N---                         \--*  NE        int    <l:$249, c:$248>
N002 (  3,  6) [000056] #----------                            +--*  IND       long   $280
N001 (  1,  4) [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class $183
N004 (  3,  2) [000054] #--X-------                            \--*  IND       long   <l:$2c0, c:$2c1>
N003 (  1,  1) [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>

------------ BB11 [???..???), preds={BB10} succs={BB13}

***** BB11
STMT00018 ( ??? ... ??? )
N006 (  8,  7) [000106] -A---O--R--                         *  ASG       long   <l:$211, c:$210>
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3 $VN.Void
N004 (  4,  4) [000105] n----O-----                         \--*  IND       long   <l:$2c3, c:$2c4>
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref  <l:$144, c:$143>
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle] $102

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}

***** BB13
STMT00025 ( ??? ... ??? )
N005 (  0,  0) [000119] -A------R--                         *  ASG       long   $VN.Void
N004 (  0,  0) [000117] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:1 $VN.Void
N003 (  0,  0) [000118] -----------                         \--*  PHI       long   $380
N001 (  0,  0) [000121] ----------- pred BB11                  +--*  PHI_ARG   long   V10 tmp7         u:3 <l:$2c2, c:$284>
N002 (  0,  0) [000120] ----------- pred BB12                  \--*  PHI_ARG   long   V10 tmp7         u:2 $283

***** BB13
STMT00008 ( 0x02E[E-] ... ??? )
N006 ( 10,  8) [000112] -A---O-----                         *  ASG       long   $VN.Void
N004 (  6,  5) [000110] n----O-N---                         +--*  IND       long   $VN.Void
N003 (  4,  3) [000109] -------N---                         |  \--*  ADD       byref  $145
N001 (  3,  2) [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
N002 (  1,  1) [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle] $103
N005 (  3,  2) [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         u:1 (last use) $380

------------ BB14 [048..049) (return), preds={BB02,BB05,BB09,BB13} succs={}

***** BB14
STMT00009 ( 0x048[E-] ... 0x048 )
N001 (  0,  0) [000038] -----------                         *  RETURN    void   $VN.Void

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB12 [???..???) -> BB13 (always), preds={BB10} succs={BB13}

***** BB12
STMT00019 ( 0x02E[E-] ... ??? )
N005 ( 26, 17) [000071] -ACXG---R--                         *  ASG       struct (copy) $VN.Void
N004 (  3,  2) [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7          $VN.Void
N003 ( 22, 14) [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value $300
N001 (  1,  1) [000053] ----------- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  4) [000107] H---------- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}

***** BB15
STMT00011 ( 0x026[E-] ... ??? )
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void
N001 (  1,  1) [000042] ----------- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         u:1 (last use) $80

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE Determine first cold block

*************** In fgDetermineFirstColdBlock()
No procedure splitting will be done for this method

*************** Finishing PHASE Determine first cold block [no changes]
Trees before Rationalize IR

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC 
BB14 [0017]  4       BB02,BB05,BB09,BB13   1     85    [048..049)        (return)                     i IBC 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}

***** BB01
STMT00000 ( 0x000[E-] ... 0x006 )
N006 (  4,  4) [000003] -A-XG---R--                         *  ASG       ref    $204
N005 (  1,  1) [000002] D------N---                         +--*  LCL_VAR   ref    V01 loc0         d:1 $VN.Void
N004 (  4,  4) [000001] ---XG------                         \--*  IND       ref    <l:$202, c:$203>
N003 (  2,  2) [000097] -------N---                            \--*  ADD       byref  $140
N001 (  1,  1) [000000] -----------                               +--*  LCL_VAR   ref    V00 this         u:1 $80
N002 (  1,  1) [000096] -----------                               \--*  CNS_INT   long   24 field offset Fseq[m_method] $100

***** BB01
STMT00020 ( INL01 @ 0x003[E-] ... ??? ) <- INLRT @ 0x007[E-]
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void
N003 (  3,  3) [000077] J------N---                         \--*  EQ        int    <l:$241, c:$240>
N001 (  1,  1) [000004] -----------                            +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000076] -----------                            \--*  CNS_INT   ref    null $VN.Null

------------ BB02 [007..01A) -> BB14 (cond), preds={BB01} succs={BB17,BB14}

***** BB02
STMT00022 ( INL01 @ 0x006[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000087] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2) [000086] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:2 $VN.Void
N001 (  1,  1) [000085] -----------                         \--*  CNS_INT   int    0 $40

***** BB02
STMT00003 ( 0x012[E-] ... 0x018 )
N011 (  9,  9) [000016] -A--GO-----                         *  JTRUE     void   <l:$20b, c:$20a>
N010 (  7,  7) [000015] JA--GO-N---                         \--*  EQ        int   
N008 (  5,  5) [000125] -A--GO-----                            +--*  COMMA     ref    <l:$208, c:$209>
N006 (  4,  4) [000123] -A--GO--R--                            |  +--*  ASG       ref    $VN.Void
N005 (  1,  1) [000122] D------N---                            |  |  +--*  LCL_VAR   ref    V12 cse0         d:1 <l:$208, c:$209>
N004 (  4,  4) [000013] n---GO-----                            |  |  \--*  IND       ref    <l:$208, c:$209>
N003 (  2,  2) [000099] -------N---                            |  |     \--*  ADD       byref  <l:$142, c:$141>
N001 (  1,  1) [000012] -----------                            |  |        +--*  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000098] -----------                            |  |        \--*  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
N007 (  1,  1) [000124] -----------                            |  \--*  LCL_VAR   ref    V12 cse0         u:1 <l:$208, c:$209>
N009 (  1,  1) [000014] -----------                            \--*  CNS_INT   ref    null $VN.Null

------------ BB17 [???..???) -> BB08 (always), preds={BB02} succs={BB08}

------------ BB04 [007..008), preds={BB01} succs={BB05}

***** BB04
STMT00021 ( INL01 @ 0x008[E-] ... ??? ) <- INLRT @ 0x007[E-]
N003 (  5,  4) [000082] -A------R--                         *  ASG       bool   $VN.Void
N002 (  3,  2) [000081] D------N---                         +--*  LCL_VAR   int    V09 tmp6         d:1 $VN.Void
N001 (  1,  1) [000080] -----------                         \--*  CNS_INT   int    1 $42

------------ BB05 [???..???) -> BB14 (always), preds={BB04} succs={BB14}

------------ BB08 [01C..025), preds={BB17} succs={BB10}

***** BB08
STMT00006 ( 0x022[--] ... ??? )
N003 ( 18,  8) [000028] -AC-----R--                         *  ASG       ref    $VN.Void
N002 (  3,  2) [000027] D------N---                         +--*  LCL_VAR   ref    V02 loc1         d:1 $VN.Void
N001 ( 14,  5) [000021] --C--------                         \--*  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}

***** BB10
STMT00014 ( 0x02E[E-] ... ??? )
N003 (  1,  3) [000051] -A--G---R--                         *  ASG       ref    <l:$20b, c:$20a>
N002 (  1,  1) [000050] D------N---                         +--*  LCL_VAR   ref    V07 tmp4         d:1 $VN.Void
N001 (  1,  1) [000126] -----------                         \--*  LCL_VAR   ref    V12 cse0         u:1 <l:$205, c:$83>

***** BB10
STMT00015 ( 0x02E[E-] ... ??? )
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>
N005 (  7,  9) [000057] J--X---N---                         \--*  NE        int    <l:$249, c:$248>
N002 (  3,  6) [000056] #----------                            +--*  IND       long   $280
N001 (  1,  4) [000055] H----------                            |  \--*  CNS_INT(h) long   0x40000000004258b8 class $183
N004 (  3,  2) [000054] #--X-------                            \--*  IND       long   <l:$2c0, c:$2c1>
N003 (  1,  1) [000052] -----------                               \--*  LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>

------------ BB11 [???..???), preds={BB10} succs={BB13}

***** BB11
STMT00018 ( ??? ... ??? )
N006 (  8,  7) [000106] -A---O--R--                         *  ASG       long   <l:$211, c:$210>
N005 (  3,  2) [000104] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:3 $VN.Void
N004 (  4,  4) [000105] n----O-----                         \--*  IND       long   <l:$2c3, c:$2c4>
N003 (  2,  2) [000103] -------N---                            \--*  ADD       byref  <l:$144, c:$143>
N001 (  1,  1) [000059] -----------                               +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  1) [000102] -----------                               \--*  CNS_INT   long   80 field offset Fseq[m_value, m_handle] $102

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}

***** BB13
STMT00025 ( ??? ... ??? )
N005 (  0,  0) [000119] -A------R--                         *  ASG       long   $VN.Void
N004 (  0,  0) [000117] D------N---                         +--*  LCL_VAR   long   V10 tmp7         d:1 $VN.Void
N003 (  0,  0) [000118] -----------                         \--*  PHI       long   $380
N001 (  0,  0) [000121] ----------- pred BB11                  +--*  PHI_ARG   long   V10 tmp7         u:3 <l:$2c2, c:$284>
N002 (  0,  0) [000120] ----------- pred BB12                  \--*  PHI_ARG   long   V10 tmp7         u:2 $283

***** BB13
STMT00008 ( 0x02E[E-] ... ??? )
N006 ( 10,  8) [000112] -A---O-----                         *  ASG       long   $VN.Void
N004 (  6,  5) [000110] n----O-N---                         +--*  IND       long   $VN.Void
N003 (  4,  3) [000109] -------N---                         |  \--*  ADD       byref  $145
N001 (  3,  2) [000029] -----------                         |     +--*  LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
N002 (  1,  1) [000108] -----------                         |     \--*  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle] $103
N005 (  3,  2) [000111] -----------                         \--*  LCL_VAR   long   V10 tmp7         u:1 (last use) $380

------------ BB14 [048..049) (return), preds={BB02,BB05,BB09,BB13} succs={}

***** BB14
STMT00009 ( 0x048[E-] ... 0x048 )
N001 (  0,  0) [000038] -----------                         *  RETURN    void   $VN.Void

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB12 [???..???) -> BB13 (always), preds={BB10} succs={BB13}

***** BB12
STMT00019 ( 0x02E[E-] ... ??? )
N005 ( 26, 17) [000071] -ACXG---R--                         *  ASG       struct (copy) $VN.Void
N004 (  3,  2) [000069] D------N---                         +--*  LCL_VAR   struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            +--*    long   V06.m_handle (offs=0x00) -> V10 tmp7          $VN.Void
N003 ( 22, 14) [000032] --CXG--N---                         \--*  CALLV stub struct System.IRuntimeMethodInfo.get_Value $300
N001 (  1,  1) [000053] ----------- this in rcx                +--*  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  4) [000107] H---------- vsd cell in r11            \--*  CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}

***** BB15
STMT00011 ( 0x026[E-] ... ??? )
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void
N001 (  1,  1) [000042] ----------- arg0 in rcx             \--*  LCL_VAR   ref    V00 this         u:1 (last use) $80

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Rationalize IR
rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N006 (  4,  4) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V01 loc0         d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  5,  4) [000087] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:2

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N006 (  4,  4) [000123] DA--GO-----                         *  STORE_LCL_VAR ref    V12 cse0         d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  5,  4) [000082] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 ( 18,  8) [000028] DAC--------                         *  STORE_LCL_VAR ref    V02 loc1         d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N003 (  1,  3) [000051] DA--G------                         *  STORE_LCL_VAR ref    V07 tmp4         d:1

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N006 (  8,  7) [000106] DA---O-----                         *  STORE_LCL_VAR long   V10 tmp7         d:3

rewriting asg(LCL_VAR, X) to STORE_LCL_VAR(X)
N005 ( 26, 17) [000071] DACXG------                         *  STORE_LCL_VAR struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            *    long   V06.m_handle (offs=0x00) -> V10 tmp7         


*************** Finishing PHASE Rationalize IR
Trees after Rationalize IR

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC LIR 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC LIR 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal LIR 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC LIR 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC LIR 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC LIR 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC LIR 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC LIR 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC LIR 
BB14 [0017]  4       BB02,BB05,BB09,BB13   1     85    [048..049)        (return)                     i IBC LIR 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe LIR 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC LIR 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}
               [000127] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 (  1,  1) [000000] -----------                    t0 =    LCL_VAR   ref    V00 this         u:1 $80
N002 (  1,  1) [000096] -----------                   t96 =    CNS_INT   long   24 field offset Fseq[m_method] $100
                                                            /--*  t0     ref    
                                                            +--*  t96    long   
N003 (  2,  2) [000097] -------N---                   t97 = *  ADD       byref  $140
                                                            /--*  t97    byref  
N004 (  4,  4) [000001] ---XG------                    t1 = *  IND       ref    <l:$202, c:$203>
                                                            /--*  t1     ref    
N006 (  4,  4) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V01 loc0         d:1
               [000128] -----------                            IL_OFFSET void   INL01 @ 0x003[E-] <- INLRT @ 0x007[E-]
N001 (  1,  1) [000004] -----------                    t4 =    LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000076] -----------                   t76 =    CNS_INT   ref    null $VN.Null
                                                            /--*  t4     ref    
                                                            +--*  t76    ref    
N003 (  3,  3) [000077] J------N---                   t77 = *  EQ        int    <l:$241, c:$240>
                                                            /--*  t77    int    
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void

------------ BB02 [007..01A) -> BB14 (cond), preds={BB01} succs={BB17,BB14}
               [000129] -----------                            IL_OFFSET void   INL01 @ 0x006[E-] <- INLRT @ 0x007[E-]
N001 (  1,  1) [000085] -----------                   t85 =    CNS_INT   int    0 $40
                                                            /--*  t85    int    
N003 (  5,  4) [000087] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:2
               [000130] -----------                            IL_OFFSET void   INLRT @ 0x012[E-]
N001 (  1,  1) [000012] -----------                   t12 =    LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000098] -----------                   t98 =    CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
                                                            /--*  t12    ref    
                                                            +--*  t98    long   
N003 (  2,  2) [000099] -------N---                   t99 = *  ADD       byref  <l:$142, c:$141>
                                                            /--*  t99    byref  
N004 (  4,  4) [000013] n---GO-----                   t13 = *  IND       ref    <l:$208, c:$209>
                                                            /--*  t13    ref    
N006 (  4,  4) [000123] DA--GO-----                         *  STORE_LCL_VAR ref    V12 cse0         d:1
N007 (  1,  1) [000124] -----------                  t124 =    LCL_VAR   ref    V12 cse0         u:1 <l:$208, c:$209>
N009 (  1,  1) [000014] -----------                   t14 =    CNS_INT   ref    null $VN.Null
                                                            /--*  t124   ref    
                                                            +--*  t14    ref    
N010 (  7,  7) [000015] J---GO-N---                   t15 = *  EQ        int   
                                                            /--*  t15    int    
N011 (  9,  9) [000016] ----GO-----                         *  JTRUE     void   <l:$20b, c:$20a>

------------ BB17 [???..???) -> BB08 (always), preds={BB02} succs={BB08}

------------ BB04 [007..008), preds={BB01} succs={BB05}
               [000131] -----------                            IL_OFFSET void   INL01 @ 0x008[E-] <- INLRT @ 0x007[E-]
N001 (  1,  1) [000080] -----------                   t80 =    CNS_INT   int    1 $42
                                                            /--*  t80    int    
N003 (  5,  4) [000082] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:1

------------ BB05 [???..???) -> BB14 (always), preds={BB04} succs={BB14}

------------ BB08 [01C..025), preds={BB17} succs={BB10}
               [000132] -----------                            IL_OFFSET void   INLRT @ 0x022[--]
N001 ( 14,  5) [000021] --C--------                   t21 =    CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c
                                                            /--*  t21    ref    
N003 ( 18,  8) [000028] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         d:1

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}
               [000133] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  1) [000126] -----------                  t126 =    LCL_VAR   ref    V12 cse0         u:1 <l:$205, c:$83>
                                                            /--*  t126   ref    
N003 (  1,  3) [000051] DA--G------                         *  STORE_LCL_VAR ref    V07 tmp4         d:1
               [000134] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  4) [000055] H----------                   t55 =    CNS_INT(h) long   0x40000000004258b8 class $183
                                                            /--*  t55    long   
N002 (  3,  6) [000056] #----------                   t56 = *  IND       long   $280
N003 (  1,  1) [000052] -----------                   t52 =    LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>
                                                            /--*  t52    ref    
N004 (  3,  2) [000054] #--X-------                   t54 = *  IND       long   <l:$2c0, c:$2c1>
                                                            /--*  t56    long   
                                                            +--*  t54    long   
N005 (  7,  9) [000057] J--X---N---                   t57 = *  NE        int    <l:$249, c:$248>
                                                            /--*  t57    int    
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>

------------ BB11 [???..???), preds={BB10} succs={BB13}
N001 (  1,  1) [000059] -----------                   t59 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  1) [000102] -----------                  t102 =    CNS_INT   long   80 field offset Fseq[m_value, m_handle] $102
                                                            /--*  t59    ref    
                                                            +--*  t102   long   
N003 (  2,  2) [000103] -------N---                  t103 = *  ADD       byref  <l:$144, c:$143>
                                                            /--*  t103   byref  
N004 (  4,  4) [000105] n----O-----                  t105 = *  IND       long   <l:$2c3, c:$2c4>
                                                            /--*  t105   long   
N006 (  8,  7) [000106] DA---O-----                         *  STORE_LCL_VAR long   V10 tmp7         d:3

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}
               [000135] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  3,  2) [000029] -----------                   t29 =    LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
N002 (  1,  1) [000108] -----------                  t108 =    CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle] $103
                                                            /--*  t29    ref    
                                                            +--*  t108   long   
N003 (  4,  3) [000109] -------N---                  t109 = *  ADD       byref  $145
N005 (  3,  2) [000111] -----------                  t111 =    LCL_VAR   long   V10 tmp7         u:1 (last use) $380
                                                            /--*  t109   byref  
                                                            +--*  t111   long   
               [000136] -A---O-----                         *  STOREIND  long  

------------ BB14 [048..049) (return), preds={BB02,BB05,BB09,BB13} succs={}
               [000137] -----------                            IL_OFFSET void   INLRT @ 0x048[E-]
N001 (  0,  0) [000038] -----------                            RETURN    void   $VN.Void

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB12 [???..???) -> BB13 (always), preds={BB10} succs={BB13}
               [000138] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  1) [000053] -----------                   t53 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  4) [000107] H----------                  t107 =    CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
                                                            /--*  t53    ref    this in rcx
                                                            +--*  t107   long   vsd cell in r11
N003 ( 22, 14) [000032] --CXG--N---                   t32 = *  CALLV stub struct System.IRuntimeMethodInfo.get_Value $300
                                                            /--*  t32    struct 
N005 ( 26, 17) [000071] DA-XG------                         *  STORE_LCL_VAR struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            *    long   V06.m_handle (offs=0x00) -> V10 tmp7         

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}
               [000139] -----------                            IL_OFFSET void   INLRT @ 0x026[E-]
N001 (  1,  1) [000042] -----------                   t42 =    LCL_VAR   ref    V00 this         u:1 (last use) $80
                                                            /--*  t42    ref    arg0 in rcx
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE Do 'simple' lowering
Bumping outgoingArgSpaceSize from 0 to 32 for call [000021]
outgoingArgSpaceSize 32 sufficient for call [000032], which needs 32
outgoingArgSpaceSize 32 sufficient for call [000043], which needs 32
*************** In fgDebugCheckBBlist

*************** Finishing PHASE Do 'simple' lowering
Trees before Lowering nodeinfo

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC LIR 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC LIR 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal LIR 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC LIR 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC LIR 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC LIR 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC LIR 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC LIR 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC LIR 
BB14 [0017]  4       BB02,BB05,BB09,BB13   1     85    [048..049)        (return)                     i IBC LIR 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe LIR 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC LIR 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}
               [000127] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 (  1,  1) [000000] -----------                    t0 =    LCL_VAR   ref    V00 this         u:1 $80
N002 (  1,  1) [000096] -----------                   t96 =    CNS_INT   long   24 field offset Fseq[m_method] $100
                                                            /--*  t0     ref    
                                                            +--*  t96    long   
N003 (  2,  2) [000097] -------N---                   t97 = *  ADD       byref  $140
                                                            /--*  t97    byref  
N004 (  4,  4) [000001] ---XG------                    t1 = *  IND       ref    <l:$202, c:$203>
                                                            /--*  t1     ref    
N006 (  4,  4) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V01 loc0         d:1
               [000128] -----------                            IL_OFFSET void   INL01 @ 0x003[E-] <- INLRT @ 0x007[E-]
N001 (  1,  1) [000004] -----------                    t4 =    LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000076] -----------                   t76 =    CNS_INT   ref    null $VN.Null
                                                            /--*  t4     ref    
                                                            +--*  t76    ref    
N003 (  3,  3) [000077] J------N---                   t77 = *  EQ        int    <l:$241, c:$240>
                                                            /--*  t77    int    
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void

------------ BB02 [007..01A) -> BB14 (cond), preds={BB01} succs={BB17,BB14}
               [000129] -----------                            IL_OFFSET void   INL01 @ 0x006[E-] <- INLRT @ 0x007[E-]
N001 (  1,  1) [000085] -----------                   t85 =    CNS_INT   int    0 $40
                                                            /--*  t85    int    
N003 (  5,  4) [000087] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:2
               [000130] -----------                            IL_OFFSET void   INLRT @ 0x012[E-]
N001 (  1,  1) [000012] -----------                   t12 =    LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000098] -----------                   t98 =    CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
                                                            /--*  t12    ref    
                                                            +--*  t98    long   
N003 (  2,  2) [000099] -------N---                   t99 = *  ADD       byref  <l:$142, c:$141>
                                                            /--*  t99    byref  
N004 (  4,  4) [000013] n---GO-----                   t13 = *  IND       ref    <l:$208, c:$209>
                                                            /--*  t13    ref    
N006 (  4,  4) [000123] DA--GO-----                         *  STORE_LCL_VAR ref    V12 cse0         d:1
N007 (  1,  1) [000124] -----------                  t124 =    LCL_VAR   ref    V12 cse0         u:1 <l:$208, c:$209>
N009 (  1,  1) [000014] -----------                   t14 =    CNS_INT   ref    null $VN.Null
                                                            /--*  t124   ref    
                                                            +--*  t14    ref    
N010 (  7,  7) [000015] J---GO-N---                   t15 = *  EQ        int   
                                                            /--*  t15    int    
N011 (  9,  9) [000016] ----GO-----                         *  JTRUE     void   <l:$20b, c:$20a>

------------ BB17 [???..???) -> BB08 (always), preds={BB02} succs={BB08}

------------ BB04 [007..008), preds={BB01} succs={BB05}
               [000131] -----------                            IL_OFFSET void   INL01 @ 0x008[E-] <- INLRT @ 0x007[E-]
N001 (  1,  1) [000080] -----------                   t80 =    CNS_INT   int    1 $42
                                                            /--*  t80    int    
N003 (  5,  4) [000082] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:1

------------ BB05 [???..???) -> BB14 (always), preds={BB04} succs={BB14}

------------ BB08 [01C..025), preds={BB17} succs={BB10}
               [000132] -----------                            IL_OFFSET void   INLRT @ 0x022[--]
N001 ( 14,  5) [000021] --C--------                   t21 =    CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c
                                                            /--*  t21    ref    
N003 ( 18,  8) [000028] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         d:1

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}
               [000133] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  1) [000126] -----------                  t126 =    LCL_VAR   ref    V12 cse0         u:1 <l:$205, c:$83>
                                                            /--*  t126   ref    
N003 (  1,  3) [000051] DA--G------                         *  STORE_LCL_VAR ref    V07 tmp4         d:1
               [000134] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  4) [000055] H----------                   t55 =    CNS_INT(h) long   0x40000000004258b8 class $183
                                                            /--*  t55    long   
N002 (  3,  6) [000056] #----------                   t56 = *  IND       long   $280
N003 (  1,  1) [000052] -----------                   t52 =    LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>
                                                            /--*  t52    ref    
N004 (  3,  2) [000054] #--X-------                   t54 = *  IND       long   <l:$2c0, c:$2c1>
                                                            /--*  t56    long   
                                                            +--*  t54    long   
N005 (  7,  9) [000057] J--X---N---                   t57 = *  NE        int    <l:$249, c:$248>
                                                            /--*  t57    int    
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>

------------ BB11 [???..???), preds={BB10} succs={BB13}
N001 (  1,  1) [000059] -----------                   t59 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  1) [000102] -----------                  t102 =    CNS_INT   long   80 field offset Fseq[m_value, m_handle] $102
                                                            /--*  t59    ref    
                                                            +--*  t102   long   
N003 (  2,  2) [000103] -------N---                  t103 = *  ADD       byref  <l:$144, c:$143>
                                                            /--*  t103   byref  
N004 (  4,  4) [000105] n----O-----                  t105 = *  IND       long   <l:$2c3, c:$2c4>
                                                            /--*  t105   long   
N006 (  8,  7) [000106] DA---O-----                         *  STORE_LCL_VAR long   V10 tmp7         d:3

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}
               [000135] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  3,  2) [000029] -----------                   t29 =    LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
N002 (  1,  1) [000108] -----------                  t108 =    CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle] $103
                                                            /--*  t29    ref    
                                                            +--*  t108   long   
N003 (  4,  3) [000109] -------N---                  t109 = *  ADD       byref  $145
N005 (  3,  2) [000111] -----------                  t111 =    LCL_VAR   long   V10 tmp7         u:1 (last use) $380
                                                            /--*  t109   byref  
                                                            +--*  t111   long   
               [000136] -A---O-----                         *  STOREIND  long  

------------ BB14 [048..049) (return), preds={BB02,BB05,BB09,BB13} succs={}
               [000137] -----------                            IL_OFFSET void   INLRT @ 0x048[E-]
N001 (  0,  0) [000038] -----------                            RETURN    void   $VN.Void

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB12 [???..???) -> BB13 (always), preds={BB10} succs={BB13}
               [000138] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  1) [000053] -----------                   t53 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  4) [000107] H----------                  t107 =    CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
                                                            /--*  t53    ref    this in rcx
                                                            +--*  t107   long   vsd cell in r11
N003 ( 22, 14) [000032] --CXG--N---                   t32 = *  CALLV stub struct System.IRuntimeMethodInfo.get_Value $300
                                                            /--*  t32    struct 
N005 ( 26, 17) [000071] DA-XG------                         *  STORE_LCL_VAR struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            *    long   V06.m_handle (offs=0x00) -> V10 tmp7         

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}
               [000139] -----------                            IL_OFFSET void   INLRT @ 0x026[E-]
N001 (  1,  1) [000042] -----------                   t42 =    LCL_VAR   ref    V00 this         u:1 (last use) $80
                                                            /--*  t42    ref    arg0 in rcx
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Lowering nodeinfo
Addressing mode:
  Base
    N001 (  1,  1) [000000] -----------                         *  LCL_VAR   ref    V00 this         u:1 $80
  + 24
Removing unused node:
  N002 (  1,  1) [000096] -c---------                         *  CNS_INT   long   24 field offset Fseq[m_method] $100
New addressing mode node:
  N003 (  2,  2) [000097] -----------                         *  LEA(b+24) byref 

lowering store lcl var/field (before):
N001 (  1,  1) [000000] -----------                    t0 =    LCL_VAR   ref    V00 this         u:1 $80
                                                            /--*  t0     ref    
N003 (  2,  2) [000097] -c---------                   t97 = *  LEA(b+24) byref 
                                                            /--*  t97    byref  
N004 (  4,  4) [000001] ---XG------                    t1 = *  IND       ref    <l:$202, c:$203>
                                                            /--*  t1     ref    
N006 (  4,  4) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V01 loc0         d:1

lowering store lcl var/field (after):
N001 (  1,  1) [000000] -----------                    t0 =    LCL_VAR   ref    V00 this         u:1 $80
                                                            /--*  t0     ref    
N003 (  2,  2) [000097] -c---------                   t97 = *  LEA(b+24) byref 
                                                            /--*  t97    byref  
N004 (  4,  4) [000001] ---XG------                    t1 = *  IND       ref    <l:$202, c:$203>
                                                            /--*  t1     ref    
N006 (  4,  4) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V01 loc0         d:1

lowering store lcl var/field (before):
N001 (  1,  1) [000085] -----------                   t85 =    CNS_INT   int    0 $40
                                                            /--*  t85    int    
N003 (  5,  4) [000087] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:2

lowering store lcl var/field (after):
N001 (  1,  1) [000085] -----------                   t85 =    CNS_INT   int    0 $40
                                                            /--*  t85    int    
N003 (  5,  4) [000087] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:2

Addressing mode:
  Base
    N001 (  1,  1) [000012] -----------                         *  LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
  + 16
Removing unused node:
  N002 (  1,  1) [000098] -c---------                         *  CNS_INT   long   16 field offset Fseq[m_methodHandle] $101
New addressing mode node:
  N003 (  2,  2) [000099] -----------                         *  LEA(b+16) byref 

lowering store lcl var/field (before):
N001 (  1,  1) [000012] -----------                   t12 =    LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
                                                            /--*  t12    ref    
N003 (  2,  2) [000099] -c---------                   t99 = *  LEA(b+16) byref 
                                                            /--*  t99    byref  
N004 (  4,  4) [000013] n---GO-----                   t13 = *  IND       ref    <l:$208, c:$209>
                                                            /--*  t13    ref    
N006 (  4,  4) [000123] DA--GO-----                         *  STORE_LCL_VAR ref    V12 cse0         d:1

lowering store lcl var/field (after):
N001 (  1,  1) [000012] -----------                   t12 =    LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
                                                            /--*  t12    ref    
N003 (  2,  2) [000099] -c---------                   t99 = *  LEA(b+16) byref 
                                                            /--*  t99    byref  
N004 (  4,  4) [000013] n---GO-----                   t13 = *  IND       ref    <l:$208, c:$209>
                                                            /--*  t13    ref    
N006 (  4,  4) [000123] DA--GO-----                         *  STORE_LCL_VAR ref    V12 cse0         d:1

lowering store lcl var/field (before):
N001 (  1,  1) [000080] -----------                   t80 =    CNS_INT   int    1 $42
                                                            /--*  t80    int    
N003 (  5,  4) [000082] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:1

lowering store lcl var/field (after):
N001 (  1,  1) [000080] -c---------                   t80 =    CNS_INT   int    1 $42
                                                            /--*  t80    int    
N003 (  5,  4) [000082] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:1

lowering call (before):
N001 ( 14,  5) [000021] --C--------                   t21 =    CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c

args:
======

late:
======
results of lowering call:
N001 (  1,  4) [000140] H----------                  t140 =    CNS_INT(h) long   0x4000000000426c78 ftn
                                                            /--*  t140   long   
N002 (  3,  6) [000141] -----------                  t141 = *  IND       long  
lowering call (after):
N001 (  1,  4) [000140] Hc---------                  t140 =    CNS_INT(h) long   0x4000000000426c78 ftn
                                                            /--*  t140   long   
N002 (  3,  6) [000141] -c---------                  t141 = *  IND       long   REG NA
                                                            /--*  t141   long   control expr
N001 ( 14,  5) [000021] --C--------                   t21 = *  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c

lowering store lcl var/field (before):
N001 (  1,  4) [000140] Hc---------                  t140 =    CNS_INT(h) long   0x4000000000426c78 ftn
                                                            /--*  t140   long   
N002 (  3,  6) [000141] -c---------                  t141 = *  IND       long   REG NA
                                                            /--*  t141   long   control expr
N001 ( 14,  5) [000021] --C--------                   t21 = *  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c
                                                            /--*  t21    ref    
N003 ( 18,  8) [000028] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         d:1

lowering store lcl var/field (after):
N001 (  1,  4) [000140] Hc---------                  t140 =    CNS_INT(h) long   0x4000000000426c78 ftn
                                                            /--*  t140   long   
N002 (  3,  6) [000141] -c---------                  t141 = *  IND       long   REG NA
                                                            /--*  t141   long   control expr
N001 ( 14,  5) [000021] --C--------                   t21 = *  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c
                                                            /--*  t21    ref    
N003 ( 18,  8) [000028] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         d:1

lowering store lcl var/field (before):
N001 (  1,  1) [000126] -----------                  t126 =    LCL_VAR   ref    V12 cse0         u:1 <l:$205, c:$83>
                                                            /--*  t126   ref    
N003 (  1,  3) [000051] DA--G------                         *  STORE_LCL_VAR ref    V07 tmp4         d:1

lowering store lcl var/field (after):
N001 (  1,  1) [000126] -----------                  t126 =    LCL_VAR   ref    V12 cse0         u:1 <l:$205, c:$83>
                                                            /--*  t126   ref    
N003 (  1,  3) [000051] DA--G------                         *  STORE_LCL_VAR ref    V07 tmp4         d:1

Addressing mode:
  Base
    N001 (  1,  1) [000059] -----------                         *  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
  + 80
Removing unused node:
  N002 (  1,  1) [000102] -c---------                         *  CNS_INT   long   80 field offset Fseq[m_value, m_handle] $102
New addressing mode node:
  N003 (  2,  2) [000103] -----------                         *  LEA(b+80) byref 

lowering store lcl var/field (before):
N001 (  1,  1) [000059] -----------                   t59 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
                                                            /--*  t59    ref    
N003 (  2,  2) [000103] -c---------                  t103 = *  LEA(b+80) byref 
                                                            /--*  t103   byref  
N004 (  4,  4) [000105] n----O-----                  t105 = *  IND       long   <l:$2c3, c:$2c4>
                                                            /--*  t105   long   
N006 (  8,  7) [000106] DA---O-----                         *  STORE_LCL_VAR long   V10 tmp7         d:3

lowering store lcl var/field (after):
N001 (  1,  1) [000059] -----------                   t59 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
                                                            /--*  t59    ref    
N003 (  2,  2) [000103] -c---------                  t103 = *  LEA(b+80) byref 
                                                            /--*  t103   byref  
N004 (  4,  4) [000105] n----O-----                  t105 = *  IND       long   <l:$2c3, c:$2c4>
                                                            /--*  t105   long   
N006 (  8,  7) [000106] DA---O-----                         *  STORE_LCL_VAR long   V10 tmp7         d:3

Addressing mode:
  Base
    N001 (  3,  2) [000029] -----------                         *  LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
  + 8
Removing unused node:
  N002 (  1,  1) [000108] -c---------                         *  CNS_INT   long   8 field offset Fseq[m_methodHandle, m_handle] $103
New addressing mode node:
  N003 (  4,  3) [000109] -----------                         *  LEA(b+8)  byref 

Lower of StoreInd didn't mark the node as self contained for reason: oper is not supported
N001 (  3,  2) [000029] -----------                   t29 =    LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
                                                            /--*  t29    ref    
N003 (  4,  3) [000109] -----------                  t109 = *  LEA(b+8)  byref 
N005 (  3,  2) [000111] -----------                  t111 =    LCL_VAR   long   V10 tmp7         u:1 (last use) $380
                                                            /--*  t109   byref  
                                                            +--*  t111   long   
               [000136] -A---O-----                         *  STOREIND  long  
lowering GT_RETURN
N001 (  0,  0) [000038] -----------                         *  RETURN    void   $VN.Void
============lowering call (before):
N001 (  1,  1) [000053] -----------                   t53 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
N002 (  1,  4) [000107] H----------                  t107 =    CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
                                                            /--*  t53    ref    this in rcx
                                                            +--*  t107   long   vsd cell in r11
N003 ( 22, 14) [000032] --CXG--N---                   t32 = *  CALLV stub struct System.IRuntimeMethodInfo.get_Value $300

args:
======

late:
======
lowering arg : N001 (  1,  1) [000053] -----------                         *  LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
new node is :                [000142] -----------                         *  PUTARG_REG ref    REG rcx

lowering arg : N002 (  1,  4) [000107] H----------                         *  CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
new node is :                [000143] -----------                         *  PUTARG_REG long   REG r11

lowering call (after):
N001 (  1,  1) [000053] -----------                   t53 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
                                                            /--*  t53    ref    
               [000142] -----------                  t142 = *  PUTARG_REG ref    REG rcx
N002 (  1,  4) [000107] H----------                  t107 =    CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
                                                            /--*  t107   long   
               [000143] -----------                  t143 = *  PUTARG_REG long   REG r11
                                                            /--*  t142   ref    this in rcx
                                                            +--*  t143   long   vsd cell in r11
N003 ( 22, 14) [000032] --CXG--N---                   t32 = *  CALLV stub long   System.IRuntimeMethodInfo.get_Value $300

lowering store lcl var/field (before):
N001 (  1,  1) [000053] -----------                   t53 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
                                                            /--*  t53    ref    
               [000142] -----------                  t142 = *  PUTARG_REG ref    REG rcx
N002 (  1,  4) [000107] H----------                  t107 =    CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
                                                            /--*  t107   long   
               [000143] -----------                  t143 = *  PUTARG_REG long   REG r11
                                                            /--*  t142   ref    this in rcx
                                                            +--*  t143   long   vsd cell in r11
N003 ( 22, 14) [000032] --CXG--N---                   t32 = *  CALLV stub long   System.IRuntimeMethodInfo.get_Value $300
                                                            /--*  t32    long   
N005 ( 26, 17) [000071] DA-XG------                         *  STORE_LCL_VAR struct<System.RuntimeMethodHandleInternal, 8>(P) V06 tmp3         d:2
                                                            *    long   V06.m_handle (offs=0x00) -> V10 tmp7         

Replacing an independently promoted local var V06 with its only field V10 for the store from a call [000071]
lowering store lcl var/field (after):
N001 (  1,  1) [000053] -----------                   t53 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
                                                            /--*  t53    ref    
               [000142] -----------                  t142 = *  PUTARG_REG ref    REG rcx
N002 (  1,  4) [000107] H----------                  t107 =    CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
                                                            /--*  t107   long   
               [000143] -----------                  t143 = *  PUTARG_REG long   REG r11
                                                            /--*  t142   ref    this in rcx
                                                            +--*  t143   long   vsd cell in r11
N003 ( 22, 14) [000032] --CXG--N---                   t32 = *  CALLV stub long   System.IRuntimeMethodInfo.get_Value $300
                                                            /--*  t32    long   
N005 ( 26, 17) [000071] DA-XG------                         *  STORE_LCL_VAR long   V10 tmp7         

lowering call (before):
N001 (  1,  1) [000042] -----------                   t42 =    LCL_VAR   ref    V00 this         u:1 (last use) $80
                                                            /--*  t42    ref    arg0 in rcx
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void

args:
======

late:
======
lowering arg : N001 (  1,  1) [000042] -----------                         *  LCL_VAR   ref    V00 this         u:1 (last use) $80
new node is :                [000145] -----------                         *  PUTARG_REG ref    REG rcx

results of lowering call:
N001 (  1,  4) [000146] H----------                  t146 =    CNS_INT(h) long   0x4000000000426868 ftn
                                                            /--*  t146   long   
N002 (  3,  6) [000147] -----------                  t147 = *  IND       long  
lowering call (after):
N001 (  1,  1) [000042] -----------                   t42 =    LCL_VAR   ref    V00 this         u:1 (last use) $80
                                                            /--*  t42    ref    
               [000145] -----------                  t145 = *  PUTARG_REG ref    REG rcx
N001 (  1,  4) [000146] Hc---------                  t146 =    CNS_INT(h) long   0x4000000000426868 ftn
                                                            /--*  t146   long   
N002 (  3,  6) [000147] -c---------                  t147 = *  IND       long   REG NA
                                                            /--*  t145   ref    arg0 in rcx
                                                            +--*  t147   long   control expr
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void

Lower has completed modifying nodes.

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC LIR 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC LIR 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal LIR 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC LIR 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC LIR 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC LIR 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC LIR 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC LIR 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC LIR 
BB14 [0017]  4       BB02,BB05,BB09,BB13   1     85    [048..049)        (return)                     i IBC LIR 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe LIR 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC LIR 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB04 (cond), preds={} succs={BB02,BB04}
               [000127] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 (  1,  1) [000000] -----------                    t0 =    LCL_VAR   ref    V00 this         u:1 $80
                                                            /--*  t0     ref    
N003 (  2,  2) [000097] -c---------                   t97 = *  LEA(b+24) byref 
                                                            /--*  t97    byref  
N004 (  4,  4) [000001] ---XG------                    t1 = *  IND       ref    <l:$202, c:$203>
                                                            /--*  t1     ref    
N006 (  4,  4) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V01 loc0         d:1
               [000128] -----------                            IL_OFFSET void   INL01 @ 0x003[E-] <- INLRT @ 0x007[E-]
N001 (  1,  1) [000004] -----------                    t4 =    LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000076] -c---------                   t76 =    CNS_INT   ref    null $VN.Null
                                                            /--*  t4     ref    
                                                            +--*  t76    ref    
N003 (  3,  3) [000077] J------N---                         *  EQ        void   <l:$241, c:$240>
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void

------------ BB02 [007..01A) -> BB14 (cond), preds={BB01} succs={BB17,BB14}
               [000129] -----------                            IL_OFFSET void   INL01 @ 0x006[E-] <- INLRT @ 0x007[E-]
N001 (  1,  1) [000085] -----------                   t85 =    CNS_INT   int    0 $40
                                                            /--*  t85    int    
N003 (  5,  4) [000087] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:2
               [000130] -----------                            IL_OFFSET void   INLRT @ 0x012[E-]
N001 (  1,  1) [000012] -----------                   t12 =    LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
                                                            /--*  t12    ref    
N003 (  2,  2) [000099] -c---------                   t99 = *  LEA(b+16) byref 
                                                            /--*  t99    byref  
N004 (  4,  4) [000013] n---GO-----                   t13 = *  IND       ref    <l:$208, c:$209>
                                                            /--*  t13    ref    
N006 (  4,  4) [000123] DA--GO-----                         *  STORE_LCL_VAR ref    V12 cse0         d:1
N007 (  1,  1) [000124] -----------                  t124 =    LCL_VAR   ref    V12 cse0         u:1 <l:$208, c:$209>
N009 (  1,  1) [000014] -c---------                   t14 =    CNS_INT   ref    null $VN.Null
                                                            /--*  t124   ref    
                                                            +--*  t14    ref    
N010 (  7,  7) [000015] J---GO-N---                         *  EQ        void  
N011 (  9,  9) [000016] ----GO-----                         *  JTRUE     void   <l:$20b, c:$20a>

------------ BB17 [???..???) -> BB08 (always), preds={BB02} succs={BB08}

------------ BB04 [007..008), preds={BB01} succs={BB05}
               [000131] -----------                            IL_OFFSET void   INL01 @ 0x008[E-] <- INLRT @ 0x007[E-]
N001 (  1,  1) [000080] -c---------                   t80 =    CNS_INT   int    1 $42
                                                            /--*  t80    int    
N003 (  5,  4) [000082] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:1

------------ BB05 [???..???) -> BB14 (always), preds={BB04} succs={BB14}

------------ BB08 [01C..025), preds={BB17} succs={BB10}
               [000132] -----------                            IL_OFFSET void   INLRT @ 0x022[--]
N001 (  1,  4) [000140] Hc---------                  t140 =    CNS_INT(h) long   0x4000000000426c78 ftn
                                                            /--*  t140   long   
N002 (  3,  6) [000141] -c---------                  t141 = *  IND       long   REG NA
                                                            /--*  t141   long   control expr
N001 ( 14,  5) [000021] --C--------                   t21 = *  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c
                                                            /--*  t21    ref    
N003 ( 18,  8) [000028] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         d:1

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}
               [000133] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  1) [000126] -----------                  t126 =    LCL_VAR   ref    V12 cse0         u:1 <l:$205, c:$83>
                                                            /--*  t126   ref    
N003 (  1,  3) [000051] DA--G------                         *  STORE_LCL_VAR ref    V07 tmp4         d:1
               [000134] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  4) [000055] Hc---------                   t55 =    CNS_INT(h) long   0x40000000004258b8 class $183
                                                            /--*  t55    long   
N002 (  3,  6) [000056] #----------                   t56 = *  IND       long   $280
N003 (  1,  1) [000052] -----------                   t52 =    LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>
                                                            /--*  t52    ref    
N004 (  3,  2) [000054] #c-X-------                   t54 = *  IND       long   <l:$2c0, c:$2c1>
                                                            /--*  t56    long   
                                                            +--*  t54    long   
N005 (  7,  9) [000057] J--X---N---                         *  NE        void   <l:$249, c:$248>
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>

------------ BB11 [???..???), preds={BB10} succs={BB13}
N001 (  1,  1) [000059] -----------                   t59 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
                                                            /--*  t59    ref    
N003 (  2,  2) [000103] -c---------                  t103 = *  LEA(b+80) byref 
                                                            /--*  t103   byref  
N004 (  4,  4) [000105] n----O-----                  t105 = *  IND       long   <l:$2c3, c:$2c4>
                                                            /--*  t105   long   
N006 (  8,  7) [000106] DA---O-----                         *  STORE_LCL_VAR long   V10 tmp7         d:3

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}
               [000135] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  3,  2) [000029] -----------                   t29 =    LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
                                                            /--*  t29    ref    
N003 (  4,  3) [000109] -c---------                  t109 = *  LEA(b+8)  byref 
N005 (  3,  2) [000111] -----------                  t111 =    LCL_VAR   long   V10 tmp7         u:1 (last use) $380
                                                            /--*  t109   byref  
                                                            +--*  t111   long   
               [000136] -A---O-----                         *  STOREIND  long  

------------ BB14 [048..049) (return), preds={BB02,BB05,BB09,BB13} succs={}
               [000137] -----------                            IL_OFFSET void   INLRT @ 0x048[E-]
N001 (  0,  0) [000038] -----------                            RETURN    void   $VN.Void

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB12 [???..???) -> BB13 (always), preds={BB10} succs={BB13}
               [000138] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  1) [000053] -----------                   t53 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
                                                            /--*  t53    ref    
               [000142] -----------                  t142 = *  PUTARG_REG ref    REG rcx
N002 (  1,  4) [000107] H----------                  t107 =    CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
                                                            /--*  t107   long   
               [000143] -----------                  t143 = *  PUTARG_REG long   REG r11
                                                            /--*  t142   ref    this in rcx
                                                            +--*  t143   long   vsd cell in r11
N003 ( 22, 14) [000032] --CXG--N---                   t32 = *  CALLV stub long   System.IRuntimeMethodInfo.get_Value $300
                                                            /--*  t32    long   
N005 ( 26, 17) [000071] DA-XG------                         *  STORE_LCL_VAR long   V10 tmp7         

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}
               [000139] -----------                            IL_OFFSET void   INLRT @ 0x026[E-]
N001 (  1,  1) [000042] -----------                   t42 =    LCL_VAR   ref    V00 this         u:1 (last use) $80
                                                            /--*  t42    ref    
               [000145] -----------                  t145 = *  PUTARG_REG ref    REG rcx
N001 (  1,  4) [000146] Hc---------                  t146 =    CNS_INT(h) long   0x4000000000426868 ftn
                                                            /--*  t146   long   
N002 (  3,  6) [000147] -c---------                  t147 = *  IND       long   REG NA
                                                            /--*  t145   ref    arg0 in rcx
                                                            +--*  t147   long   control expr
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void

-------------------------------------------------------------------------------------------------------------------

*** lvaComputeRefCounts ***

*** lvaComputeRefCounts -- explicit counts ***
New refCnts for V00: refCnt =  1, refCntWtd = 1   
New refCnts for V01: refCnt =  1, refCntWtd = 1   
New refCnts for V01: refCnt =  2, refCntWtd = 2   
New refCnts for V09: refCnt =  1, refCntWtd = 1   
New refCnts for V01: refCnt =  3, refCntWtd = 3   
New refCnts for V12: refCnt =  1, refCntWtd = 1   
New refCnts for V12: refCnt =  2, refCntWtd = 2   
New refCnts for V09: refCnt =  2, refCntWtd = 1.22
New refCnts for V02: refCnt =  1, refCntWtd = 1   
New refCnts for V12: refCnt =  3, refCntWtd = 3   
New refCnts for V07: refCnt =  1, refCntWtd = 2   
New refCnts for V07: refCnt =  2, refCntWtd = 4   
New refCnts for V07: refCnt =  3, refCntWtd = 6   
New refCnts for V10: refCnt =  1, refCntWtd = 1   
New refCnts for V02: refCnt =  2, refCntWtd = 2   
New refCnts for V10: refCnt =  2, refCntWtd = 2   
New refCnts for V07: refCnt =  4, refCntWtd = 6   
New refCnts for V10: refCnt =  3, refCntWtd = 2   
New refCnts for V00: refCnt =  2, refCntWtd = 1   

*** lvaComputeRefCounts -- implicit counts ***
New refCnts for V00: refCnt =  3, refCntWtd = 2   
New refCnts for V00: refCnt =  4, refCntWtd = 3   
*************** In fgLocalVarLiveness()
; Initial local variable assignments
;
;  V00 this              ref  this class-hnd EH-live single-def
;  V01 loc0              ref  class-hnd single-def
;  V02 loc1              ref  class-hnd exact single-def
;  V03 OutArgs        lclBlk <32>  "OutgoingArgSpace"
;  V04 tmp1              ref  class-hnd exact "NewObj constructor temp"
;  V05 tmp2              ref  class-hnd single-def "impSpillSpecialSideEff"
;  V06 tmp3           struct <System.RuntimeMethodHandleInternal, 8> "guarded devirt return temp"
;  V07 tmp4              ref  single-def "guarded devirt this temp"
;  V08 tmp5              ref  class-hnd exact "guarded devirt this exact temp"
;  V09 tmp6             bool  "Inline return value spill temp"
;  V10 tmp7             long  V06.m_handle(offs=0x00) P-INDEP "field V06.m_handle (fldOffset=0x0)"
;  V11 PSPSym           long  do-not-enreg[V] "PSPSym"
;  V12 cse0              ref  "CSE - aggressive"
In fgLocalVarLivenessInit
Tracked variable (8 out of 13) table:
V07 tmp4          [   ref]: refCnt =    4, refCntWtd =   6   
V00 this          [   ref]: refCnt =    4, refCntWtd =   3   
V01 loc0          [   ref]: refCnt =    3, refCntWtd =   3   
V12 cse0          [   ref]: refCnt =    3, refCntWtd =   3   
V10 tmp7          [  long]: refCnt =    3, refCntWtd =   2   
V02 loc1          [   ref]: refCnt =    2, refCntWtd =   2   
V09 tmp6          [  bool]: refCnt =    2, refCntWtd =   1.22
V11 PSPSym        [  long]: refCnt =    1, refCntWtd =   1   

*************** In fgPerBlockLocalVarLiveness()
BB01 USE(1)={V00    } + ByrefExposed + GcHeap
     DEF(1)={    V01}

BB02 USE(1)={V01        } + ByrefExposed + GcHeap
     DEF(2)={    V12 V09}

BB17 USE(0)={}
     DEF(0)={}

BB04 USE(0)={   }
     DEF(1)={V09}

BB05 USE(0)={}
     DEF(0)={}

BB08 USE(0)={   } + ByrefExposed + GcHeap
     DEF(1)={V02}

BB10 USE(1)={    V12} + ByrefExposed + GcHeap
     DEF(1)={V07    }

BB11 USE(1)={V07    } + ByrefExposed + GcHeap
     DEF(1)={    V10}

BB13 USE(2)={V10 V02}
     DEF(0)={       }

BB14 USE(0)={}
     DEF(0)={}

BB09 USE(0)={}
     DEF(0)={}

BB12 USE(1)={V07    } + ByrefExposed + GcHeap
     DEF(1)={    V10} + ByrefExposed* + GcHeap*

BB15 USE(1)={V00} + ByrefExposed + GcHeap
     DEF(0)={   } + ByrefExposed* + GcHeap*

** Memory liveness computed, GcHeap states and ByrefExposed states match
*************** In fgInterBlockLocalVarLiveness()

BB liveness after fgLiveVarAnalysis():

BB01 IN (1)={V00    } + ByrefExposed + GcHeap
     OUT(2)={V00 V01} + ByrefExposed + GcHeap

BB02 IN (2)={V00 V01    } + ByrefExposed + GcHeap
     OUT(2)={V00     V12} + ByrefExposed + GcHeap

BB17 IN (2)={V00 V12} + ByrefExposed + GcHeap
     OUT(2)={V00 V12} + ByrefExposed + GcHeap

BB04 IN (0)={}
     OUT(0)={}

BB05 IN (0)={}
     OUT(0)={}

BB08 IN (2)={V00 V12    } + ByrefExposed + GcHeap
     OUT(3)={V00 V12 V02} + ByrefExposed + GcHeap

BB10 IN (2)={    V12 V02} + ByrefExposed + GcHeap
     OUT(2)={V07     V02} + ByrefExposed + GcHeap

BB11 IN (2)={V07     V02} + ByrefExposed + GcHeap
     OUT(2)={    V10 V02}

BB13 IN (2)={V10 V02}
     OUT(0)={       }

BB14 IN (0)={}
     OUT(0)={}

BB09 IN (0)={}
     OUT(0)={}

BB12 IN (2)={V07     V02} + ByrefExposed + GcHeap
     OUT(2)={    V10 V02}

BB15 IN (1)={V00} + ByrefExposed + GcHeap
     OUT(0)={   }

Removing dead local store:
N003 (  5,  4) [000087] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:2 (last use)
Removing dead node:
N001 (  1,  1) [000085] -----------                         *  CNS_INT   int    0 $40
Removing dead local store:
N003 (  5,  4) [000082] DA---------                         *  STORE_LCL_VAR int    V09 tmp6         d:1 (last use)
Removing dead node:
N001 (  1,  1) [000080] -----------                         *  CNS_INT   int    1 $42

*************** In fgUpdateFlowGraph()
Before updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB04 ( cond )                     keep i IBC LIR 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC LIR 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal LIR 
BB04 [0025]  1       BB01                  0.22  18    [007..008)                                     i IBC LIR 
BB05 [0031]  1       BB04                  1     85    [???..???)-> BB14 (always)                     keep internal IBC LIR 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC LIR 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC LIR 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC LIR 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC LIR 
BB14 [0017]  4       BB02,BB05,BB09,BB13   1     85    [048..049)        (return)                     i IBC LIR 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe LIR 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC LIR 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

fgRemoveBlock BB04, unreachable=false
Removing empty BB04
Setting edge weights for BB01 -> BB05 to [0 .. 3.402823e+38]

Optimizing a jump to an unconditional jump (BB01 -> BB05 -> BB14)
Setting edge weights for BB01 -> BB14 to [0 .. 3.402823e+38]

After updating the flow graph:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB14 ( cond )                     keep i IBC LIR 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC LIR 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal LIR 
BB05 [0031]  0                             1     85    [???..???)-> BB14 (always)                     keep internal IBC LIR 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC LIR 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC LIR 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC LIR 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC LIR 
BB14 [0017]  5       BB01,BB02,BB05,BB09,BB13   1     85    [048..049)        (return)                     i IBC LIR 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe LIR 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC LIR 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table
index  eTry, eHnd
  0  ::            - Try at BB08..BB08 [01D..025), Handler at BB15..BB15 [025..02E)
*************** In fgDebugCheckBBlist

*************** In fgRemoveDeadBlocks()
New BlockSet epoch 6, # of blocks (including unused BB00): 18, bitset array size: 1 (short)

Removing unreachable BB05

After dead block removal:

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB14 ( cond )                     keep i IBC LIR 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC LIR 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal LIR 
BB05 [0031]  0                             0      0    [???..???)        (throw )                     keep i rare IBC LIR 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC LIR 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC LIR 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC LIR 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC LIR 
BB14 [0017]  4       BB01,BB02,BB09,BB13   1     85    [048..049)        (return)                     i IBC LIR 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe LIR 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC LIR 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** In fgDebugCheckBBlist
had to run another liveness pass:
*************** In fgLocalVarLiveness()
; Initial local variable assignments
;
;  V00 this              ref  this class-hnd EH-live single-def
;  V01 loc0              ref  class-hnd single-def
;  V02 loc1              ref  class-hnd exact single-def
;  V03 OutArgs        lclBlk <32>  "OutgoingArgSpace"
;  V04 tmp1              ref  class-hnd exact "NewObj constructor temp"
;  V05 tmp2              ref  class-hnd single-def "impSpillSpecialSideEff"
;  V06 tmp3           struct <System.RuntimeMethodHandleInternal, 8> "guarded devirt return temp"
;  V07 tmp4              ref  single-def "guarded devirt this temp"
;  V08 tmp5              ref  class-hnd exact "guarded devirt this exact temp"
;  V09 tmp6             bool  "Inline return value spill temp"
;  V10 tmp7             long  V06.m_handle(offs=0x00) P-INDEP "field V06.m_handle (fldOffset=0x0)"
;  V11 PSPSym           long  do-not-enreg[V] "PSPSym"
;  V12 cse0              ref  "CSE - aggressive"
In fgLocalVarLivenessInit
Tracked variable (8 out of 13) table:
V07 tmp4          [   ref]: refCnt =    4, refCntWtd =   6   
V00 this          [   ref]: refCnt =    4, refCntWtd =   3   
V01 loc0          [   ref]: refCnt =    3, refCntWtd =   3   
V12 cse0          [   ref]: refCnt =    3, refCntWtd =   3   
V10 tmp7          [  long]: refCnt =    3, refCntWtd =   2   
V02 loc1          [   ref]: refCnt =    2, refCntWtd =   2   
V09 tmp6          [  bool]: refCnt =    2, refCntWtd =   1.22
V11 PSPSym        [  long]: refCnt =    1, refCntWtd =   1   

*************** In fgPerBlockLocalVarLiveness()
BB01 USE(1)={V00    } + ByrefExposed + GcHeap
     DEF(1)={    V01}

BB02 USE(1)={V01    } + ByrefExposed + GcHeap
     DEF(1)={    V12}

BB17 USE(0)={}
     DEF(0)={}

BB05 USE(0)={}
     DEF(0)={}

BB08 USE(0)={   } + ByrefExposed + GcHeap
     DEF(1)={V02}

BB10 USE(1)={    V12} + ByrefExposed + GcHeap
     DEF(1)={V07    }

BB11 USE(1)={V07    } + ByrefExposed + GcHeap
     DEF(1)={    V10}

BB13 USE(2)={V10 V02}
     DEF(0)={       }

BB14 USE(0)={}
     DEF(0)={}

BB09 USE(0)={}
     DEF(0)={}

BB12 USE(1)={V07    } + ByrefExposed + GcHeap
     DEF(1)={    V10} + ByrefExposed* + GcHeap*

BB15 USE(1)={V00} + ByrefExposed + GcHeap
     DEF(0)={   } + ByrefExposed* + GcHeap*

** Memory liveness computed, GcHeap states and ByrefExposed states match
*************** In fgInterBlockLocalVarLiveness()

BB liveness after fgLiveVarAnalysis():

BB01 IN (1)={V00    } + ByrefExposed + GcHeap
     OUT(2)={V00 V01} + ByrefExposed + GcHeap

BB02 IN (2)={V00 V01    } + ByrefExposed + GcHeap
     OUT(2)={V00     V12} + ByrefExposed + GcHeap

BB17 IN (2)={V00 V12} + ByrefExposed + GcHeap
     OUT(2)={V00 V12} + ByrefExposed + GcHeap

BB05 IN (0)={}
     OUT(0)={}

BB08 IN (2)={V00 V12    } + ByrefExposed + GcHeap
     OUT(3)={V00 V12 V02} + ByrefExposed + GcHeap

BB10 IN (2)={    V12 V02} + ByrefExposed + GcHeap
     OUT(2)={V07     V02} + ByrefExposed + GcHeap

BB11 IN (2)={V07     V02} + ByrefExposed + GcHeap
     OUT(2)={    V10 V02}

BB13 IN (2)={V10 V02}
     OUT(0)={       }

BB14 IN (0)={}
     OUT(0)={}

BB09 IN (0)={}
     OUT(0)={}

BB12 IN (2)={V07     V02} + ByrefExposed + GcHeap
     OUT(2)={    V10 V02}

BB15 IN (1)={V00} + ByrefExposed + GcHeap
     OUT(0)={   }


*** lvaComputeRefCounts ***

*** lvaComputeRefCounts -- explicit counts ***
New refCnts for V00: refCnt =  1, refCntWtd = 1   
New refCnts for V01: refCnt =  1, refCntWtd = 1   
New refCnts for V01: refCnt =  2, refCntWtd = 2   
New refCnts for V01: refCnt =  3, refCntWtd = 3   
New refCnts for V12: refCnt =  1, refCntWtd = 1   
New refCnts for V12: refCnt =  2, refCntWtd = 2   
New refCnts for V02: refCnt =  1, refCntWtd = 1   
New refCnts for V12: refCnt =  3, refCntWtd = 3   
New refCnts for V07: refCnt =  1, refCntWtd = 2   
New refCnts for V07: refCnt =  2, refCntWtd = 4   
New refCnts for V07: refCnt =  3, refCntWtd = 6   
New refCnts for V10: refCnt =  1, refCntWtd = 1   
New refCnts for V02: refCnt =  2, refCntWtd = 2   
New refCnts for V10: refCnt =  2, refCntWtd = 2   
New refCnts for V07: refCnt =  4, refCntWtd = 6   
New refCnts for V10: refCnt =  3, refCntWtd = 2   
New refCnts for V00: refCnt =  2, refCntWtd = 1   

*** lvaComputeRefCounts -- implicit counts ***
New refCnts for V00: refCnt =  3, refCntWtd = 2   
New refCnts for V00: refCnt =  4, refCntWtd = 3   

*************** Finishing PHASE Lowering nodeinfo
Trees after Lowering nodeinfo

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB14 ( cond )                     keep i IBC LIR 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC LIR 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal LIR 
BB05 [0031]  0                             0      0    [???..???)        (throw )                     keep i rare IBC LIR 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC LIR 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC LIR 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC LIR 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC LIR 
BB14 [0017]  4       BB01,BB02,BB09,BB13   1     85    [048..049)        (return)                     i IBC LIR 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe LIR 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC LIR 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB14 (cond), preds={} succs={BB02,BB14}
               [000127] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 (  1,  1) [000000] -----------                    t0 =    LCL_VAR   ref    V00 this         u:1 $80
                                                            /--*  t0     ref    
N003 (  2,  2) [000097] -c---------                   t97 = *  LEA(b+24) byref 
                                                            /--*  t97    byref  
N004 (  4,  4) [000001] ---XG------                    t1 = *  IND       ref    <l:$202, c:$203>
                                                            /--*  t1     ref    
N006 (  4,  4) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V01 loc0         d:1
               [000128] -----------                            IL_OFFSET void   INL01 @ 0x003[E-] <- INLRT @ 0x007[E-]
N001 (  1,  1) [000004] -----------                    t4 =    LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000076] -c---------                   t76 =    CNS_INT   ref    null $VN.Null
                                                            /--*  t4     ref    
                                                            +--*  t76    ref    
N003 (  3,  3) [000077] J------N---                         *  EQ        void   <l:$241, c:$240>
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void

------------ BB02 [007..01A) -> BB14 (cond), preds={BB01} succs={BB17,BB14}
               [000129] -----------                            IL_OFFSET void   INL01 @ 0x006[E-] <- INLRT @ 0x007[E-]
               [000130] -----------                            IL_OFFSET void   INLRT @ 0x012[E-]
N001 (  1,  1) [000012] -----------                   t12 =    LCL_VAR   ref    V01 loc0         u:1 (last use) <l:$200, c:$81>
                                                            /--*  t12    ref    
N003 (  2,  2) [000099] -c---------                   t99 = *  LEA(b+16) byref 
                                                            /--*  t99    byref  
N004 (  4,  4) [000013] n---GO-----                   t13 = *  IND       ref    <l:$208, c:$209>
                                                            /--*  t13    ref    
N006 (  4,  4) [000123] DA--GO-----                         *  STORE_LCL_VAR ref    V12 cse0         d:1
N007 (  1,  1) [000124] -----------                  t124 =    LCL_VAR   ref    V12 cse0         u:1 <l:$208, c:$209>
N009 (  1,  1) [000014] -c---------                   t14 =    CNS_INT   ref    null $VN.Null
                                                            /--*  t124   ref    
                                                            +--*  t14    ref    
N010 (  7,  7) [000015] J---GO-N---                         *  EQ        void  
N011 (  9,  9) [000016] ----GO-----                         *  JTRUE     void   <l:$20b, c:$20a>

------------ BB17 [???..???) -> BB08 (always), preds={BB02} succs={BB08}

------------ BB05 [???..???) (throw), preds={} succs={}

------------ BB08 [01C..025), preds={BB17} succs={BB10}
               [000132] -----------                            IL_OFFSET void   INLRT @ 0x022[--]
N001 (  1,  4) [000140] Hc---------                  t140 =    CNS_INT(h) long   0x4000000000426c78 ftn
                                                            /--*  t140   long   
N002 (  3,  6) [000141] -c---------                  t141 = *  IND       long   REG NA
                                                            /--*  t141   long   control expr
N001 ( 14,  5) [000021] --C--------                   t21 = *  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c
                                                            /--*  t21    ref    
N003 ( 18,  8) [000028] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         d:1

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}
               [000133] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  1) [000126] -----------                  t126 =    LCL_VAR   ref    V12 cse0         u:1 (last use) <l:$205, c:$83>
                                                            /--*  t126   ref    
N003 (  1,  3) [000051] DA--G------                         *  STORE_LCL_VAR ref    V07 tmp4         d:1
               [000134] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  4) [000055] Hc---------                   t55 =    CNS_INT(h) long   0x40000000004258b8 class $183
                                                            /--*  t55    long   
N002 (  3,  6) [000056] #----------                   t56 = *  IND       long   $280
N003 (  1,  1) [000052] -----------                   t52 =    LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>
                                                            /--*  t52    ref    
N004 (  3,  2) [000054] #c-X-------                   t54 = *  IND       long   <l:$2c0, c:$2c1>
                                                            /--*  t56    long   
                                                            +--*  t54    long   
N005 (  7,  9) [000057] J--X---N---                         *  NE        void   <l:$249, c:$248>
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>

------------ BB11 [???..???), preds={BB10} succs={BB13}
N001 (  1,  1) [000059] -----------                   t59 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
                                                            /--*  t59    ref    
N003 (  2,  2) [000103] -c---------                  t103 = *  LEA(b+80) byref 
                                                            /--*  t103   byref  
N004 (  4,  4) [000105] n----O-----                  t105 = *  IND       long   <l:$2c3, c:$2c4>
                                                            /--*  t105   long   
N006 (  8,  7) [000106] DA---O-----                         *  STORE_LCL_VAR long   V10 tmp7         d:3

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}
               [000135] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  3,  2) [000029] -----------                   t29 =    LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
                                                            /--*  t29    ref    
N003 (  4,  3) [000109] -c---------                  t109 = *  LEA(b+8)  byref 
N005 (  3,  2) [000111] -----------                  t111 =    LCL_VAR   long   V10 tmp7         u:1 (last use) $380
                                                            /--*  t109   byref  
                                                            +--*  t111   long   
               [000136] -A---O-----                         *  STOREIND  long  

------------ BB14 [048..049) (return), preds={BB01,BB02,BB09,BB13} succs={}
               [000137] -----------                            IL_OFFSET void   INLRT @ 0x048[E-]
N001 (  0,  0) [000038] -----------                            RETURN    void   $VN.Void

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB12 [???..???) -> BB13 (always), preds={BB10} succs={BB13}
               [000138] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  1) [000053] -----------                   t53 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
                                                            /--*  t53    ref    
               [000142] -----------                  t142 = *  PUTARG_REG ref    REG rcx
N002 (  1,  4) [000107] H----------                  t107 =    CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
                                                            /--*  t107   long   
               [000143] -----------                  t143 = *  PUTARG_REG long   REG r11
                                                            /--*  t142   ref    this in rcx
                                                            +--*  t143   long   vsd cell in r11
N003 ( 22, 14) [000032] --CXG--N---                   t32 = *  CALLV stub long   System.IRuntimeMethodInfo.get_Value $300
                                                            /--*  t32    long   
N005 ( 26, 17) [000071] DA-XG------                         *  STORE_LCL_VAR long   V10 tmp7         

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}
               [000139] -----------                            IL_OFFSET void   INLRT @ 0x026[E-]
N001 (  1,  1) [000042] -----------                   t42 =    LCL_VAR   ref    V00 this         u:1 (last use) $80
                                                            /--*  t42    ref    
               [000145] -----------                  t145 = *  PUTARG_REG ref    REG rcx
N001 (  1,  4) [000146] Hc---------                  t146 =    CNS_INT(h) long   0x4000000000426868 ftn
                                                            /--*  t146   long   
N002 (  3,  6) [000147] -c---------                  t147 = *  IND       long   REG NA
                                                            /--*  t145   ref    arg0 in rcx
                                                            +--*  t147   long   control expr
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist
Trees before Calculate stack level slots

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB14 ( cond )                     keep i IBC LIR 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC LIR 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal LIR 
BB05 [0031]  0                             0      0    [???..???)        (throw )                     keep i rare IBC LIR 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC LIR 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC LIR 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC LIR 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC LIR 
BB14 [0017]  4       BB01,BB02,BB09,BB13   1     85    [048..049)        (return)                     i IBC LIR 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe LIR 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC LIR 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB14 (cond), preds={} succs={BB02,BB14}
               [000127] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 (  1,  1) [000000] -----------                    t0 =    LCL_VAR   ref    V00 this         u:1 $80
                                                            /--*  t0     ref    
N003 (  2,  2) [000097] -c---------                   t97 = *  LEA(b+24) byref 
                                                            /--*  t97    byref  
N004 (  4,  4) [000001] ---XG------                    t1 = *  IND       ref    <l:$202, c:$203>
                                                            /--*  t1     ref    
N006 (  4,  4) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V01 loc0         d:1
               [000128] -----------                            IL_OFFSET void   INL01 @ 0x003[E-] <- INLRT @ 0x007[E-]
N001 (  1,  1) [000004] -----------                    t4 =    LCL_VAR   ref    V01 loc0         u:1 <l:$200, c:$81>
N002 (  1,  1) [000076] -c---------                   t76 =    CNS_INT   ref    null $VN.Null
                                                            /--*  t4     ref    
                                                            +--*  t76    ref    
N003 (  3,  3) [000077] J------N---                         *  EQ        void   <l:$241, c:$240>
N004 (  5,  5) [000078] -----------                         *  JTRUE     void   $VN.Void

------------ BB02 [007..01A) -> BB14 (cond), preds={BB01} succs={BB17,BB14}
               [000129] -----------                            IL_OFFSET void   INL01 @ 0x006[E-] <- INLRT @ 0x007[E-]
               [000130] -----------                            IL_OFFSET void   INLRT @ 0x012[E-]
N001 (  1,  1) [000012] -----------                   t12 =    LCL_VAR   ref    V01 loc0         u:1 (last use) <l:$200, c:$81>
                                                            /--*  t12    ref    
N003 (  2,  2) [000099] -c---------                   t99 = *  LEA(b+16) byref 
                                                            /--*  t99    byref  
N004 (  4,  4) [000013] n---GO-----                   t13 = *  IND       ref    <l:$208, c:$209>
                                                            /--*  t13    ref    
N006 (  4,  4) [000123] DA--GO-----                         *  STORE_LCL_VAR ref    V12 cse0         d:1
N007 (  1,  1) [000124] -----------                  t124 =    LCL_VAR   ref    V12 cse0         u:1 <l:$208, c:$209>
N009 (  1,  1) [000014] -c---------                   t14 =    CNS_INT   ref    null $VN.Null
                                                            /--*  t124   ref    
                                                            +--*  t14    ref    
N010 (  7,  7) [000015] J---GO-N---                         *  EQ        void  
N011 (  9,  9) [000016] ----GO-----                         *  JTRUE     void   <l:$20b, c:$20a>

------------ BB17 [???..???) -> BB08 (always), preds={BB02} succs={BB08}

------------ BB05 [???..???) (throw), preds={} succs={}

------------ BB08 [01C..025), preds={BB17} succs={BB10}
               [000132] -----------                            IL_OFFSET void   INLRT @ 0x022[--]
N001 (  1,  4) [000140] Hc---------                  t140 =    CNS_INT(h) long   0x4000000000426c78 ftn
                                                            /--*  t140   long   
N002 (  3,  6) [000141] -c---------                  t141 = *  IND       long   REG NA
                                                            /--*  t141   long   control expr
N001 ( 14,  5) [000021] --C--------                   t21 = *  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW $20c
                                                            /--*  t21    ref    
N003 ( 18,  8) [000028] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         d:1

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}
               [000133] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  1) [000126] -----------                  t126 =    LCL_VAR   ref    V12 cse0         u:1 (last use) <l:$205, c:$83>
                                                            /--*  t126   ref    
N003 (  1,  3) [000051] DA--G------                         *  STORE_LCL_VAR ref    V07 tmp4         d:1
               [000134] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  4) [000055] Hc---------                   t55 =    CNS_INT(h) long   0x40000000004258b8 class $183
                                                            /--*  t55    long   
N002 (  3,  6) [000056] #----------                   t56 = *  IND       long   $280
N003 (  1,  1) [000052] -----------                   t52 =    LCL_VAR   ref    V07 tmp4         u:1 <l:$205, c:$87>
                                                            /--*  t52    ref    
N004 (  3,  2) [000054] #c-X-------                   t54 = *  IND       long   <l:$2c0, c:$2c1>
                                                            /--*  t56    long   
                                                            +--*  t54    long   
N005 (  7,  9) [000057] J--X---N---                         *  NE        void   <l:$249, c:$248>
N006 (  9, 11) [000058] ---X-------                         *  JTRUE     void   <l:$211, c:$210>

------------ BB11 [???..???), preds={BB10} succs={BB13}
N001 (  1,  1) [000059] -----------                   t59 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
                                                            /--*  t59    ref    
N003 (  2,  2) [000103] -c---------                  t103 = *  LEA(b+80) byref 
                                                            /--*  t103   byref  
N004 (  4,  4) [000105] n----O-----                  t105 = *  IND       long   <l:$2c3, c:$2c4>
                                                            /--*  t105   long   
N006 (  8,  7) [000106] DA---O-----                         *  STORE_LCL_VAR long   V10 tmp7         d:3

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}
               [000135] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  3,  2) [000029] -----------                   t29 =    LCL_VAR   ref    V02 loc1         u:1 (last use) $20c
                                                            /--*  t29    ref    
N003 (  4,  3) [000109] -c---------                  t109 = *  LEA(b+8)  byref 
N005 (  3,  2) [000111] -----------                  t111 =    LCL_VAR   long   V10 tmp7         u:1 (last use) $380
                                                            /--*  t109   byref  
                                                            +--*  t111   long   
               [000136] -A---O-----                         *  STOREIND  long  

------------ BB14 [048..049) (return), preds={BB01,BB02,BB09,BB13} succs={}
               [000137] -----------                            IL_OFFSET void   INLRT @ 0x048[E-]
N001 (  0,  0) [000038] -----------                            RETURN    void   $VN.Void

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB12 [???..???) -> BB13 (always), preds={BB10} succs={BB13}
               [000138] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-]
N001 (  1,  1) [000053] -----------                   t53 =    LCL_VAR   ref    V07 tmp4         u:1 (last use) <l:$205, c:$87>
                                                            /--*  t53    ref    
               [000142] -----------                  t142 = *  PUTARG_REG ref    REG rcx
N002 (  1,  4) [000107] H----------                  t107 =    CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
                                                            /--*  t107   long   
               [000143] -----------                  t143 = *  PUTARG_REG long   REG r11
                                                            /--*  t142   ref    this in rcx
                                                            +--*  t143   long   vsd cell in r11
N003 ( 22, 14) [000032] --CXG--N---                   t32 = *  CALLV stub long   System.IRuntimeMethodInfo.get_Value $300
                                                            /--*  t32    long   
N005 ( 26, 17) [000071] DA-XG------                         *  STORE_LCL_VAR long   V10 tmp7         

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}
               [000139] -----------                            IL_OFFSET void   INLRT @ 0x026[E-]
N001 (  1,  1) [000042] -----------                   t42 =    LCL_VAR   ref    V00 this         u:1 (last use) $80
                                                            /--*  t42    ref    
               [000145] -----------                  t145 = *  PUTARG_REG ref    REG rcx
N001 (  1,  4) [000146] Hc---------                  t146 =    CNS_INT(h) long   0x4000000000426868 ftn
                                                            /--*  t146   long   
N002 (  3,  6) [000147] -c---------                  t147 = *  IND       long   REG NA
                                                            /--*  t145   ref    arg0 in rcx
                                                            +--*  t147   long   control expr
N002 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize $VN.Void

-------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Calculate stack level slots

*************** Finishing PHASE Calculate stack level slots [no changes]

*************** Starting PHASE Linear scan register alloc
Clearing modified regs.

buildIntervals ========

-----------------
LIVENESS:
-----------------
BB01 use def in out
{V00}
{V01}
{V00}
{V00 V01}
BB02 use def in out
{V01}
{V12}
{V00 V01}
{V00 V12}
BB17 use def in out
{}
{}
{V00 V12}
{V00 V12}
BB05 use def in out
{}
{}
{}
{}
BB08 use def in out
{}
{V02}
{V00 V12}
{V00 V02 V12}
BB10 use def in out
{V12}
{V07}
{V02 V12}
{V02 V07}
BB11 use def in out
{V07}
{V10}
{V02 V07}
{V02 V10}
BB13 use def in out
{V02 V10}
{}
{V02 V10}
{}
BB14 use def in out
{}
{}
{}
{}
BB09 use def in out
{}
{}
{}
{}
BB12 use def in out
{V07}
{V10}
{V02 V07}
{V02 V10}
BB15 use def in out
{V00}
{}
{V00}
{}
EH Vars: {V00}
Finally Vars: {}

Interval  0: ref RefPositions {} physReg:NA Preferences=[allInt]
  Interval  0: (V00) ref (SPILLED) (writeThru) RefPositions {} physReg:NA Preferences=[allInt]
Interval  1: ref RefPositions {} physReg:NA Preferences=[allInt]
  Interval  1: (V01) ref RefPositions {} physReg:NA Preferences=[allInt]
Interval  2: ref RefPositions {} physReg:NA Preferences=[allInt]
  Interval  2: (V02) ref RefPositions {} physReg:NA Preferences=[allInt]
Interval  3: ref RefPositions {} physReg:NA Preferences=[allInt]
  Interval  3: (V07) ref RefPositions {} physReg:NA Preferences=[allInt]
Interval  4: long RefPositions {} physReg:NA Preferences=[allInt]
  Interval  4: (V10) long (field) RefPositions {} physReg:NA Preferences=[allInt]
Interval  5: ref RefPositions {} physReg:NA Preferences=[allInt]
  Interval  5: (V12) ref RefPositions {} physReg:NA Preferences=[allInt]

FP callee save candidate vars: None

floatVarCount = 0; hasLoops = false, singleExit = true
TUPLE STYLE DUMP BEFORE LSRA
Start LSRA Block Sequence: 
Current block: BB01
	Succ block: BB02, Criteria: weight, Worklist: [BB02 ]
	Succ block: BB14, Criteria: weight, Worklist: [BB02 BB14 ]
Current block: BB02
	Succ block: BB17, Criteria: bbNum, Worklist: [BB14 BB17 ]
Current block: BB14
Current block: BB17
	Succ block: BB08, Criteria: bbNum, Worklist: [BB08 ]
Current block: BB08
	Succ block: BB10, Criteria: bbNum, Worklist: [BB10 ]
Current block: BB10
	Succ block: BB11, Criteria: bbNum, Worklist: [BB11 ]
	Succ block: BB12, Criteria: weight, Worklist: [BB11 BB12 ]
Current block: BB11
	Succ block: BB13, Criteria: bbNum, Worklist: [BB13 BB12 ]
Current block: BB13
Current block: BB12
	Unvisited block: BB05, Criteria: weight, Worklist: [BB05 ]
	Unvisited block: BB09, Criteria: weight, Worklist: [BB05 BB09 ]
	Unvisited block: BB15, Criteria: weight, Worklist: [BB05 BB09 BB15 ]
Current block: BB05
Current block: BB09
Current block: BB15
Final LSRA Block Sequence: 
BB01(  1   ) 
BB02(  1   ) 
BB14(  1   ) 
BB17(  1   ) 
BB08(  1   ) 
BB10(  1   ) 
BB11(  1   ) 
BB13(  1   ) 
BB12(  0   ) 
BB05(  0   ) 
BB09(  0   )  EH-in
BB15(  0   )  EH-in EH-out

BB01 [000..010) -> BB14 (cond), preds={} succs={BB02,BB14}
=====
  N000.                    IL_OFFSET INLRT @ 0x000[E-]
  N001.                    V00(t0)
  N003. t97             =  LEA(b+24); t0
  N004. t1              =  IND      ; t97
  N006.                    V01(t3); t1
  N000.                    IL_OFFSET INL01 @ 0x003[E-] <- INLRT @ 0x007[E-]
  N001.                    V01(t4)
  N002.                    CNS_INT   null
  N003.                    EQ       ; t4
  N004.                    JTRUE    

BB02 [007..01A) -> BB14 (cond), preds={BB01} succs={BB17,BB14}
=====
  N000.                    IL_OFFSET INL01 @ 0x006[E-] <- INLRT @ 0x007[E-]
  N000.                    IL_OFFSET INLRT @ 0x012[E-]
  N001.                    V01(t12*)
  N003. t99             =  LEA(b+16); t12*
  N004. t13             =  IND      ; t99
  N006.                    V12(t123); t13
  N007.                    V12(t124)
  N009.                    CNS_INT   null
  N010.                    EQ       ; t124
  N011.                    JTRUE    

BB14 [048..049) (return), preds={BB01,BB02,BB09,BB13} succs={}
=====
  N000.                    IL_OFFSET INLRT @ 0x048[E-]
  N001.                    RETURN   

BB17 [???..???) -> BB08 (always), preds={BB02} succs={BB08}
=====

BB08 [01C..025), preds={BB17} succs={BB10}
=====
  N000.                    IL_OFFSET INLRT @ 0x022[--]
  N001.                    CNS_INT(h) 0x4000000000426c78 ftn
  N002.                    IND      
  N001. t21             =  CALL help r2r_ind
  N003.                    V02(t28); t21

BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}
=====
  N000.                    IL_OFFSET INLRT @ 0x02E[E-]
  N001.                    V12(t126*)
  N003.                    V07(t51); t126*
  N000.                    IL_OFFSET INLRT @ 0x02E[E-]
  N001.                    CNS_INT(h) 0x40000000004258b8 class
  N002. t56             =  IND      
  N003.                    V07(t52)
  N004. t54             =  IND      ; t52
  N005.                    NE       ; t56,t54
  N006.                    JTRUE    

BB11 [???..???), preds={BB10} succs={BB13}
=====
  N001.                    V07(t59*)
  N003. t103            =  LEA(b+80); t59*
  N004. t105            =  IND      ; t103
  N006.                    V10(t106); t105

BB13 [02E..041), preds={BB11,BB12} succs={BB14}
=====
  N000.                    IL_OFFSET INLRT @ 0x02E[E-]
  N001.                    V02(t29*)
  N003. t109            =  LEA(b+8) ; t29*
  N005.                    V10(t111*)
  N000.                    STOREIND ; t109,t111*

BB12 [???..???) -> BB13 (always), preds={BB10} succs={BB13}
=====
  N000.                    IL_OFFSET INLRT @ 0x02E[E-]
  N001.                    V07(t53*)
  N000. t142            =  PUTARG_REG; t53*
  N002. t107            =  CNS_INT(h) 0x4000000000424a90 ftn
  N000. t143            =  PUTARG_REG; t107
  N003. t32             =  CALLV stub; t142,t143
  N005.                    V10(t71); t32

BB05 [???..???) (throw), preds={} succs={}
=====

BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}
=====

BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}
=====
  N000.                    IL_OFFSET INLRT @ 0x026[E-]
  N001.                    V00(t42*)
  N000. t145            =  PUTARG_REG; t42*
  N001.                    CNS_INT(h) 0x4000000000426868 ftn
  N002.                    IND      
  N002.                    CALL r2r_ind; t145




buildIntervals second part ========
Int arg V00 in reg rcx
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rcx] minReg=1 fixed wt=100.00>

NEW BLOCK BB01
<RefPosition #1   @1   RefTypeBB  BB01 regmask=[] minReg=1 wt=100.00>

DefList: {  }
N003 (???,???) [000127] -----------                         *  IL_OFFSET void   INLRT @ 0x000[E-] REG NA

DefList: {  }
N005 (  1,  1) [000000] -----------                         *  LCL_VAR   ref    V00 this         u:1 NA REG NA $80

DefList: {  }
N007 (  2,  2) [000097] -c---------                         *  LEA(b+24) byref  REG NA
Contained
DefList: {  }
N009 (  4,  4) [000001] ---XG------                         *  IND       ref    REG NA <l:$202, c:$203>
<RefPosition #2   @9   RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[allIntButFP] minReg=1 last wt=150.00>
Interval  6: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #3   @10  RefTypeDef <Ivl:6> IND BB01 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N009.t1. IND }
N011 (  4,  4) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V01 loc0         d:1 NA REG NA
<RefPosition #4   @11  RefTypeUse <Ivl:6>  BB01 regmask=[allIntButFP] minReg=1 last wt=100.00>
Assigning related <V01/L1> to <I6>
<RefPosition #5   @12  RefTypeDef <Ivl:1 V01> STORE_LCL_VAR BB01 regmask=[allIntButFP] minReg=1 last wt=300.00>

DefList: {  }
N013 (???,???) [000128] -----------                         *  IL_OFFSET void   INL01 @ 0x003[E-] <- INLRT @ 0x007[E-] REG NA

DefList: {  }
N015 (  1,  1) [000004] -----------                         *  LCL_VAR   ref    V01 loc0         u:1 NA REG NA <l:$200, c:$81>

DefList: {  }
N017 (  1,  1) [000076] -c---------                         *  CNS_INT   ref    null REG NA $VN.Null
Contained
DefList: {  }
N019 (  3,  3) [000077] J------N---                         *  EQ        void   REG NA <l:$241, c:$240>
<RefPosition #6   @19  RefTypeUse <Ivl:1 V01> LCL_VAR BB01 regmask=[allIntButFP] minReg=1 last wt=300.00>

DefList: {  }
N021 (  5,  5) [000078] -----------                         *  JTRUE     void   REG NA $VN.Void



CHECKING LAST USES for BB01, liveout={V00 V01}
==============================
use: {V00}
def: {V01}

NEW BLOCK BB02


Setting BB01 as the predecessor for determining incoming variable registers of BB02
<RefPosition #7   @23  RefTypeBB  BB02 regmask=[] minReg=1 wt=100.00>

DefList: {  }
N025 (???,???) [000129] -----------                         *  IL_OFFSET void   INL01 @ 0x006[E-] <- INLRT @ 0x007[E-] REG NA

DefList: {  }
N027 (???,???) [000130] -----------                         *  IL_OFFSET void   INLRT @ 0x012[E-] REG NA

DefList: {  }
N029 (  1,  1) [000012] -----------                         *  LCL_VAR   ref    V01 loc0         u:1 NA (last use) REG NA <l:$200, c:$81>

DefList: {  }
N031 (  2,  2) [000099] -c---------                         *  LEA(b+16) byref  REG NA
Contained
DefList: {  }
N033 (  4,  4) [000013] n---GO-----                         *  IND       ref    REG NA <l:$208, c:$209>
<RefPosition #8   @33  RefTypeUse <Ivl:1 V01> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 last wt=300.00>
Interval  7: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #9   @34  RefTypeDef <Ivl:7> IND BB02 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N033.t13. IND }
N035 (  4,  4) [000123] DA--GO-----                         *  STORE_LCL_VAR ref    V12 cse0         d:1 NA REG NA
<RefPosition #10  @35  RefTypeUse <Ivl:7>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
Assigning related <V12/L5> to <I7>
<RefPosition #11  @36  RefTypeDef <Ivl:5 V12> STORE_LCL_VAR BB02 regmask=[allIntButFP] minReg=1 last wt=300.00>

DefList: {  }
N037 (  1,  1) [000124] -----------                         *  LCL_VAR   ref    V12 cse0         u:1 NA REG NA <l:$208, c:$209>

DefList: {  }
N039 (  1,  1) [000014] -c---------                         *  CNS_INT   ref    null REG NA $VN.Null
Contained
DefList: {  }
N041 (  7,  7) [000015] J---GO-N---                         *  EQ        void   REG NA
<RefPosition #12  @41  RefTypeUse <Ivl:5 V12> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 last wt=300.00>

DefList: {  }
N043 (  9,  9) [000016] ----GO-----                         *  JTRUE     void   REG NA <l:$20b, c:$20a>



CHECKING LAST USES for BB02, liveout={V00 V12}
==============================
use: {V01}
def: {V12}

NEW BLOCK BB14


Setting BB01 as the predecessor for determining incoming variable registers of BB14
<RefPosition #13  @45  RefTypeBB  BB14 regmask=[] minReg=1 wt=100.00>

DefList: {  }
N047 (???,???) [000137] -----------                         *  IL_OFFSET void   INLRT @ 0x048[E-] REG NA

DefList: {  }
N049 (  0,  0) [000038] -----------                         *  RETURN    void   REG NA $VN.Void



CHECKING LAST USES for BB14, liveout={}
==============================
use: {}
def: {}

NEW BLOCK BB17


Setting BB01 as the predecessor for determining incoming variable registers of BB17
Creating dummy definitions
<RefPosition #14  @51  RefTypeDummyDef <Ivl:5 V12>  BB17 regmask=[allIntButFP] minReg=1 last wt=100.00>
Finished creating dummy definitions

<RefPosition #15  @51  RefTypeBB  BB17 regmask=[] minReg=1 wt=100.00>



CHECKING LAST USES for BB17, liveout={V00 V12}
==============================
use: {}
def: {}

NEW BLOCK BB08


Setting BB17 as the predecessor for determining incoming variable registers of BB08
<RefPosition #16  @53  RefTypeBB  BB08 regmask=[] minReg=1 wt=100.00>

DefList: {  }
N055 (???,???) [000132] -----------                         *  IL_OFFSET void   INLRT @ 0x022[--] REG NA

DefList: {  }
N057 (  1,  4) [000140] Hc---------                         *  CNS_INT(h) long   0x4000000000426c78 ftn REG NA
Contained
DefList: {  }
N059 (  3,  6) [000141] -c---------                         *  IND       long   REG NA
Contained
DefList: {  }
N061 ( 14,  5) [000021] --C--------                         *  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW REG NA $20c
<RefPosition #17  @62  RefTypeKill <Reg:rax>  BB08 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #18  @62  RefTypeKill <Reg:rcx>  BB08 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #19  @62  RefTypeKill <Reg:rdx>  BB08 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #20  @62  RefTypeKill <Reg:r8 >  BB08 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #21  @62  RefTypeKill <Reg:r9 >  BB08 regmask=[r9] minReg=1 wt=100.00>
<RefPosition #22  @62  RefTypeKill <Reg:r10>  BB08 regmask=[r10] minReg=1 wt=100.00>
<RefPosition #23  @62  RefTypeKill <Reg:r11>  BB08 regmask=[r11] minReg=1 wt=100.00>
Interval  8: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #24  @62  RefTypeFixedReg <Reg:rax>  BB08 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #25  @62  RefTypeDef <Ivl:8> CALL BB08 regmask=[rax] minReg=1 fixed wt=400.00>

DefList: { N061.t21. CALL }
N063 ( 18,  8) [000028] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         d:1 NA REG NA
<RefPosition #26  @63  RefTypeUse <Ivl:8>  BB08 regmask=[allIntButFP] minReg=1 last wt=100.00>
Assigning related <V02/L2> to <I8>
<RefPosition #27  @64  RefTypeDef <Ivl:2 V02> STORE_LCL_VAR BB08 regmask=[allIntButFP] minReg=1 last wt=200.00>



CHECKING LAST USES for BB08, liveout={V00 V02 V12}
==============================
use: {}
def: {V02}

NEW BLOCK BB10


Setting BB08 as the predecessor for determining incoming variable registers of BB10
<RefPosition #28  @65  RefTypeBB  BB10 regmask=[] minReg=1 wt=100.00>

DefList: {  }
N067 (???,???) [000133] -----------                         *  IL_OFFSET void   INLRT @ 0x02E[E-] REG NA

DefList: {  }
N069 (  1,  1) [000126] -----------                         *  LCL_VAR   ref    V12 cse0         u:1 NA (last use) REG NA <l:$205, c:$83>

DefList: {  }
N071 (  1,  3) [000051] DA--G------                         *  STORE_LCL_VAR ref    V07 tmp4         d:1 NA REG NA
<RefPosition #29  @71  RefTypeUse <Ivl:5 V12> LCL_VAR BB10 regmask=[allIntButFP] minReg=1 last wt=300.00>
Assigning related <V07/L3> to <V12/L5>
<RefPosition #30  @72  RefTypeDef <Ivl:3 V07> STORE_LCL_VAR BB10 regmask=[allIntButFP] minReg=1 last wt=600.00>

DefList: {  }
N073 (???,???) [000134] -----------                         *  IL_OFFSET void   INLRT @ 0x02E[E-] REG NA

DefList: {  }
N075 (  1,  4) [000055] Hc---------                         *  CNS_INT(h) long   0x40000000004258b8 class REG NA $183
Contained
DefList: {  }
N077 (  3,  6) [000056] #----------                         *  IND       long   REG NA $280
Interval  9: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #31  @78  RefTypeDef <Ivl:9> IND BB10 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N077.t56. IND }
N079 (  1,  1) [000052] -----------                         *  LCL_VAR   ref    V07 tmp4         u:1 NA REG NA <l:$205, c:$87>

DefList: { N077.t56. IND }
N081 (  3,  2) [000054] #c-X-------                         *  IND       long   REG NA <l:$2c0, c:$2c1>
Contained
DefList: { N077.t56. IND }
N083 (  7,  9) [000057] J--X---N---                         *  NE        void   REG NA <l:$249, c:$248>
<RefPosition #32  @83  RefTypeUse <Ivl:9>  BB10 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #33  @83  RefTypeUse <Ivl:3 V07> LCL_VAR BB10 regmask=[allIntButFP] minReg=1 last wt=600.00>

DefList: {  }
N085 (  9, 11) [000058] ---X-------                         *  JTRUE     void   REG NA <l:$211, c:$210>



CHECKING LAST USES for BB10, liveout={V02 V07}
==============================
use: {V12}
def: {V07}

NEW BLOCK BB11


Setting BB10 as the predecessor for determining incoming variable registers of BB11
<RefPosition #34  @87  RefTypeBB  BB11 regmask=[] minReg=1 wt=100.00>

DefList: {  }
N089 (  1,  1) [000059] -----------                         *  LCL_VAR   ref    V07 tmp4         u:1 NA (last use) REG NA <l:$205, c:$87>

DefList: {  }
N091 (  2,  2) [000103] -c---------                         *  LEA(b+80) byref  REG NA
Contained
DefList: {  }
N093 (  4,  4) [000105] n----O-----                         *  IND       long   REG NA <l:$2c3, c:$2c4>
<RefPosition #35  @93  RefTypeUse <Ivl:3 V07> LCL_VAR BB11 regmask=[allIntButFP] minReg=1 last wt=600.00>
Interval 10: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #36  @94  RefTypeDef <Ivl:10> IND BB11 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N093.t105. IND }
N095 (  8,  7) [000106] DA---O-----                         *  STORE_LCL_VAR long   V10 tmp7         d:3 NA REG NA
<RefPosition #37  @95  RefTypeUse <Ivl:10>  BB11 regmask=[allIntButFP] minReg=1 last wt=100.00>
Assigning related <V10/L4> to <I10>
<RefPosition #38  @96  RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB11 regmask=[allIntButFP] minReg=1 last wt=200.00>



CHECKING LAST USES for BB11, liveout={V02 V10}
==============================
use: {V07}
def: {V10}

NEW BLOCK BB13


Setting BB11 as the predecessor for determining incoming variable registers of BB13
<RefPosition #39  @97  RefTypeBB  BB13 regmask=[] minReg=1 wt=100.00>

DefList: {  }
N099 (???,???) [000135] -----------                         *  IL_OFFSET void   INLRT @ 0x02E[E-] REG NA

DefList: {  }
N101 (  3,  2) [000029] -----------                         *  LCL_VAR   ref    V02 loc1         u:1 NA (last use) REG NA $20c

DefList: {  }
N103 (  4,  3) [000109] -c---------                         *  LEA(b+8)  byref  REG NA
Contained
DefList: {  }
N105 (  3,  2) [000111] -----------                         *  LCL_VAR   long   V10 tmp7         u:1 NA (last use) REG NA $380

DefList: {  }
N107 (???,???) [000136] -A---O-----                         *  STOREIND  long   REG NA
<RefPosition #40  @107 RefTypeUse <Ivl:2 V02> LCL_VAR BB13 regmask=[allIntButFP] minReg=1 last wt=200.00>
<RefPosition #41  @107 RefTypeUse <Ivl:4 V10> LCL_VAR BB13 regmask=[allIntButFP] minReg=1 last wt=200.00>



CHECKING LAST USES for BB13, liveout={}
==============================
use: {V02 V10}
def: {}

NEW BLOCK BB12


Setting BB10 as the predecessor for determining incoming variable registers of BB12
<RefPosition #42  @109 RefTypeBB  BB12 regmask=[] minReg=1 wt=0.00>

firstColdLoc = 111
DefList: {  }
N111 (???,???) [000138] -----------                         *  IL_OFFSET void   INLRT @ 0x02E[E-] REG NA

DefList: {  }
N113 (  1,  1) [000053] -----------                         *  LCL_VAR   ref    V07 tmp4         u:1 NA (last use) REG NA <l:$205, c:$87>

DefList: {  }
N115 (???,???) [000142] -----------                         *  PUTARG_REG ref    REG rcx
<RefPosition #43  @115 RefTypeFixedReg <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #44  @115 RefTypeUse <Ivl:3 V07> LCL_VAR BB12 regmask=[rcx] minReg=1 last fixed wt=600.00>
Interval 11: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #45  @116 RefTypeFixedReg <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #46  @116 RefTypeDef <Ivl:11> PUTARG_REG BB12 regmask=[rcx] minReg=1 fixed wt=0.00>

DefList: { N115.t142. PUTARG_REG }
N117 (  1,  4) [000107] H----------                         *  CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
Interval 12: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #47  @118 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #48  @118 RefTypeDef <Ivl:12> CNS_INT BB12 regmask=[r11] minReg=1 fixed wt=0.00>

DefList: { N115.t142. PUTARG_REG; N117.t107. CNS_INT }
N119 (???,???) [000143] -----------                         *  PUTARG_REG long   REG r11
<RefPosition #49  @119 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #50  @119 RefTypeUse <Ivl:12>  BB12 regmask=[r11] minReg=1 last fixed wt=0.00>
Interval 13: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #51  @120 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #52  @120 RefTypeDef <Ivl:13> PUTARG_REG BB12 regmask=[r11] minReg=1 fixed wt=0.00>

DefList: { N115.t142. PUTARG_REG; N119.t143. PUTARG_REG }
N121 ( 22, 14) [000032] --CXG--N---                         *  CALLV stub long   System.IRuntimeMethodInfo.get_Value REG NA $300
<RefPosition #53  @121 RefTypeFixedReg <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #54  @121 RefTypeUse <Ivl:11>  BB12 regmask=[rcx] minReg=1 last fixed wt=0.00>
<RefPosition #55  @121 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #56  @121 RefTypeUse <Ivl:13>  BB12 regmask=[r11] minReg=1 last fixed wt=0.00>
<RefPosition #57  @122 RefTypeKill <Reg:rax>  BB12 regmask=[rax] minReg=1 wt=0.00>
<RefPosition #58  @122 RefTypeKill <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #59  @122 RefTypeKill <Reg:rdx>  BB12 regmask=[rdx] minReg=1 wt=0.00>
<RefPosition #60  @122 RefTypeKill <Reg:r8 >  BB12 regmask=[r8] minReg=1 wt=0.00>
<RefPosition #61  @122 RefTypeKill <Reg:r9 >  BB12 regmask=[r9] minReg=1 wt=0.00>
<RefPosition #62  @122 RefTypeKill <Reg:r10>  BB12 regmask=[r10] minReg=1 wt=0.00>
<RefPosition #63  @122 RefTypeKill <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
Interval 14: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #64  @122 RefTypeFixedReg <Reg:rax>  BB12 regmask=[rax] minReg=1 wt=0.00>
<RefPosition #65  @122 RefTypeDef <Ivl:14> CALL BB12 regmask=[rax] minReg=1 fixed wt=0.00>

DefList: { N121.t32. CALL }
N123 ( 26, 17) [000071] DA-XG------                         *  STORE_LCL_VAR long   V10 tmp7          NA REG NA
<RefPosition #66  @123 RefTypeUse <Ivl:14>  BB12 regmask=[allIntButFP] minReg=1 last wt=0.00>
Assigning related <V10/L4> to <I14>
<RefPosition #67  @124 RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB12 regmask=[allIntButFP] minReg=1 last wt=200.00>

Exposed uses:<RefPosition #68  @125 RefTypeExpUse <Ivl:4 V10>  BB12 regmask=[allIntButFP] minReg=1 wt=0.00>
 V10<RefPosition #69  @125 RefTypeExpUse <Ivl:2 V02>  BB12 regmask=[allIntButFP] minReg=1 wt=0.00>
 V02


CHECKING LAST USES for BB12, liveout={V02 V10}
==============================
use: {V07}
def: {V10}

NEW BLOCK BB05


No predecessor;  - throw block; <RefPosition #70  @125 RefTypeBB  BB05 regmask=[] minReg=1 wt=0.00>



CHECKING LAST USES for BB05, liveout={}
==============================
use: {}
def: {}

NEW BLOCK BB09


Incoming EH boundary; <RefPosition #71  @127 RefTypeBB  BB09 regmask=[] minReg=1 wt=0.00>



CHECKING LAST USES for BB09, liveout={}
==============================
use: {}
def: {}

NEW BLOCK BB15


Incoming EH boundary; <RefPosition #72  @129 RefTypeBB  BB15 regmask=[] minReg=1 wt=0.00>

DefList: {  }
N131 (???,???) [000139] -----------                         *  IL_OFFSET void   INLRT @ 0x026[E-] REG NA

DefList: {  }
N133 (  1,  1) [000042] -----------                         *  LCL_VAR   ref    V00 this         u:1 NA (last use) REG NA $80

DefList: {  }
N135 (???,???) [000145] -----------                         *  PUTARG_REG ref    REG rcx
<RefPosition #73  @135 RefTypeFixedReg <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #74  @135 RefTypeUse <Ivl:0 V00> LCL_VAR BB15 regmask=[rcx] minReg=1 last fixed wt=150.00>
Interval 15: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #75  @136 RefTypeFixedReg <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #76  @136 RefTypeDef <Ivl:15> PUTARG_REG BB15 regmask=[rcx] minReg=1 fixed wt=0.00>

DefList: { N135.t145. PUTARG_REG }
N137 (  1,  4) [000146] Hc---------                         *  CNS_INT(h) long   0x4000000000426868 ftn REG NA
Contained
DefList: { N135.t145. PUTARG_REG }
N139 (  3,  6) [000147] -c---------                         *  IND       long   REG NA
Contained
DefList: { N135.t145. PUTARG_REG }
N141 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize REG NA $VN.Void
<RefPosition #77  @141 RefTypeFixedReg <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #78  @141 RefTypeUse <Ivl:15>  BB15 regmask=[rcx] minReg=1 last fixed wt=0.00>
<RefPosition #79  @142 RefTypeKill <Reg:rax>  BB15 regmask=[rax] minReg=1 wt=0.00>
<RefPosition #80  @142 RefTypeKill <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #81  @142 RefTypeKill <Reg:rdx>  BB15 regmask=[rdx] minReg=1 wt=0.00>
<RefPosition #82  @142 RefTypeKill <Reg:r8 >  BB15 regmask=[r8] minReg=1 wt=0.00>
<RefPosition #83  @142 RefTypeKill <Reg:r9 >  BB15 regmask=[r9] minReg=1 wt=0.00>
<RefPosition #84  @142 RefTypeKill <Reg:r10>  BB15 regmask=[r10] minReg=1 wt=0.00>
<RefPosition #85  @142 RefTypeKill <Reg:r11>  BB15 regmask=[r11] minReg=1 wt=0.00>



CHECKING LAST USES for BB15, liveout={}
==============================
use: {V00}
def: {}
<RefPosition #86  @143 RefTypeBB  BB15 regmask=[] minReg=1 wt=0.00>

Linear scan intervals BEFORE VALIDATING INTERVALS:
Interval  0: (V00) ref (SPILLED) (writeThru) RefPositions {#0@0 #2@9 #74@135} physReg:rcx Preferences=[rcx]
Interval  1: (V01) ref RefPositions {#5@12 #6@19 #8@33} physReg:NA Preferences=[allIntButFP]
Interval  2: (V02) ref RefPositions {#27@64 #40@107 #69@125} physReg:NA Preferences=[rbx rsi rdi r12-r15]
Interval  3: (V07) ref RefPositions {#30@72 #33@83 #35@93 #44@115} physReg:NA Preferences=[rcx]
Interval  4: (V10) long (field) RefPositions {#38@96 #41@107 #67@124 #68@125} physReg:NA Preferences=[allIntButFP]
Interval  5: (V12) ref RefPositions {#11@36 #12@41 #14@51 #29@71} physReg:NA Preferences=[rbx rsi rdi r12-r15] RelatedInterval <V07/L3>
Interval  6: ref RefPositions {#3@10 #4@11} physReg:NA Preferences=[allIntButFP] RelatedInterval <V01/L1>
Interval  7: ref RefPositions {#9@34 #10@35} physReg:NA Preferences=[allIntButFP] RelatedInterval <V12/L5>
Interval  8: ref RefPositions {#25@62 #26@63} physReg:NA Preferences=[rax] RelatedInterval <V02/L2>
Interval  9: long RefPositions {#31@78 #32@83} physReg:NA Preferences=[allIntButFP]
Interval 10: long RefPositions {#36@94 #37@95} physReg:NA Preferences=[allIntButFP] RelatedInterval <V10/L4>
Interval 11: ref RefPositions {#46@116 #54@121} physReg:NA Preferences=[rcx]
Interval 12: long (constant) RefPositions {#48@118 #50@119} physReg:NA Preferences=[r11]
Interval 13: long RefPositions {#52@120 #56@121} physReg:NA Preferences=[r11]
Interval 14: long RefPositions {#65@122 #66@123} physReg:NA Preferences=[rax] RelatedInterval <V10/L4>
Interval 15: ref RefPositions {#76@136 #78@141} physReg:NA Preferences=[rcx]

------------
REFPOSITIONS BEFORE VALIDATING INTERVALS: 
------------
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rcx] minReg=1 fixed regOptional wt=100.00>
<RefPosition #1   @1   RefTypeBB  BB01 regmask=[] minReg=1 wt=100.00>
<RefPosition #2   @9   RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[allIntButFP] minReg=1 wt=150.00>
<RefPosition #3   @10  RefTypeDef <Ivl:6> IND BB01 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #4   @11  RefTypeUse <Ivl:6>  BB01 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #5   @12  RefTypeDef <Ivl:1 V01> STORE_LCL_VAR BB01 regmask=[allIntButFP] minReg=1 wt=300.00>
<RefPosition #6   @19  RefTypeUse <Ivl:1 V01> LCL_VAR BB01 regmask=[allIntButFP] minReg=1 regOptional wt=300.00>
<RefPosition #7   @23  RefTypeBB  BB02 regmask=[] minReg=1 wt=100.00>
<RefPosition #8   @33  RefTypeUse <Ivl:1 V01> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 last wt=300.00>
<RefPosition #9   @34  RefTypeDef <Ivl:7> IND BB02 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #10  @35  RefTypeUse <Ivl:7>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #11  @36  RefTypeDef <Ivl:5 V12> STORE_LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=300.00>
<RefPosition #12  @41  RefTypeUse <Ivl:5 V12> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 regOptional wt=300.00>
<RefPosition #13  @45  RefTypeBB  BB14 regmask=[] minReg=1 wt=100.00>
<RefPosition #14  @51  RefTypeDummyDef <Ivl:5 V12>  BB17 regmask=[allIntButFP] minReg=1 regOptional wt=100.00>
<RefPosition #15  @51  RefTypeBB  BB17 regmask=[] minReg=1 wt=100.00>
<RefPosition #16  @53  RefTypeBB  BB08 regmask=[] minReg=1 wt=100.00>
<RefPosition #17  @62  RefTypeKill <Reg:rax>  BB08 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #18  @62  RefTypeKill <Reg:rcx>  BB08 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #19  @62  RefTypeKill <Reg:rdx>  BB08 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #20  @62  RefTypeKill <Reg:r8 >  BB08 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #21  @62  RefTypeKill <Reg:r9 >  BB08 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #22  @62  RefTypeKill <Reg:r10>  BB08 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #23  @62  RefTypeKill <Reg:r11>  BB08 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #24  @62  RefTypeFixedReg <Reg:rax>  BB08 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #25  @62  RefTypeDef <Ivl:8> CALL BB08 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #26  @63  RefTypeUse <Ivl:8>  BB08 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #27  @64  RefTypeDef <Ivl:2 V02> STORE_LCL_VAR BB08 regmask=[allIntButFP] minReg=1 wt=200.00>
<RefPosition #28  @65  RefTypeBB  BB10 regmask=[] minReg=1 wt=100.00>
<RefPosition #29  @71  RefTypeUse <Ivl:5 V12> LCL_VAR BB10 regmask=[allIntButFP] minReg=1 last wt=300.00>
<RefPosition #30  @72  RefTypeDef <Ivl:3 V07> STORE_LCL_VAR BB10 regmask=[allIntButFP] minReg=1 wt=600.00>
<RefPosition #31  @78  RefTypeDef <Ivl:9> IND BB10 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #32  @83  RefTypeUse <Ivl:9>  BB10 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #33  @83  RefTypeUse <Ivl:3 V07> LCL_VAR BB10 regmask=[allIntButFP] minReg=1 wt=600.00>
<RefPosition #34  @87  RefTypeBB  BB11 regmask=[] minReg=1 wt=100.00>
<RefPosition #35  @93  RefTypeUse <Ivl:3 V07> LCL_VAR BB11 regmask=[allIntButFP] minReg=1 last wt=600.00>
<RefPosition #36  @94  RefTypeDef <Ivl:10> IND BB11 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #37  @95  RefTypeUse <Ivl:10>  BB11 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #38  @96  RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB11 regmask=[allIntButFP] minReg=1 wt=200.00>
<RefPosition #39  @97  RefTypeBB  BB13 regmask=[] minReg=1 wt=100.00>
<RefPosition #40  @107 RefTypeUse <Ivl:2 V02> LCL_VAR BB13 regmask=[allIntButFP] minReg=1 last wt=200.00>
<RefPosition #41  @107 RefTypeUse <Ivl:4 V10> LCL_VAR BB13 regmask=[allIntButFP] minReg=1 last wt=200.00>
<RefPosition #42  @109 RefTypeBB  BB12 regmask=[] minReg=1 wt=0.00>
<RefPosition #43  @115 RefTypeFixedReg <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #44  @115 RefTypeUse <Ivl:3 V07> LCL_VAR BB12 regmask=[rcx] minReg=1 last fixed wt=600.00>
<RefPosition #45  @116 RefTypeFixedReg <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #46  @116 RefTypeDef <Ivl:11> PUTARG_REG BB12 regmask=[rcx] minReg=1 fixed wt=0.00>
<RefPosition #47  @118 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #48  @118 RefTypeDef <Ivl:12> CNS_INT BB12 regmask=[r11] minReg=1 fixed wt=0.00>
<RefPosition #49  @119 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #50  @119 RefTypeUse <Ivl:12>  BB12 regmask=[r11] minReg=1 last fixed wt=0.00>
<RefPosition #51  @120 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #52  @120 RefTypeDef <Ivl:13> PUTARG_REG BB12 regmask=[r11] minReg=1 fixed wt=0.00>
<RefPosition #53  @121 RefTypeFixedReg <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #54  @121 RefTypeUse <Ivl:11>  BB12 regmask=[rcx] minReg=1 last fixed wt=0.00>
<RefPosition #55  @121 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #56  @121 RefTypeUse <Ivl:13>  BB12 regmask=[r11] minReg=1 last fixed wt=0.00>
<RefPosition #57  @122 RefTypeKill <Reg:rax>  BB12 regmask=[rax] minReg=1 last wt=0.00>
<RefPosition #58  @122 RefTypeKill <Reg:rcx>  BB12 regmask=[rcx] minReg=1 last wt=0.00>
<RefPosition #59  @122 RefTypeKill <Reg:rdx>  BB12 regmask=[rdx] minReg=1 last wt=0.00>
<RefPosition #60  @122 RefTypeKill <Reg:r8 >  BB12 regmask=[r8] minReg=1 last wt=0.00>
<RefPosition #61  @122 RefTypeKill <Reg:r9 >  BB12 regmask=[r9] minReg=1 last wt=0.00>
<RefPosition #62  @122 RefTypeKill <Reg:r10>  BB12 regmask=[r10] minReg=1 last wt=0.00>
<RefPosition #63  @122 RefTypeKill <Reg:r11>  BB12 regmask=[r11] minReg=1 last wt=0.00>
<RefPosition #64  @122 RefTypeFixedReg <Reg:rax>  BB12 regmask=[rax] minReg=1 wt=0.00>
<RefPosition #65  @122 RefTypeDef <Ivl:14> CALL BB12 regmask=[rax] minReg=1 fixed wt=0.00>
<RefPosition #66  @123 RefTypeUse <Ivl:14>  BB12 regmask=[allIntButFP] minReg=1 last wt=0.00>
<RefPosition #67  @124 RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB12 regmask=[allIntButFP] minReg=1 wt=200.00>
<RefPosition #68  @125 RefTypeExpUse <Ivl:4 V10>  BB12 regmask=[allIntButFP] minReg=1 regOptional wt=0.00>
<RefPosition #69  @125 RefTypeExpUse <Ivl:2 V02>  BB12 regmask=[allIntButFP] minReg=1 regOptional wt=0.00>
<RefPosition #70  @125 RefTypeBB  BB05 regmask=[] minReg=1 wt=0.00>
<RefPosition #71  @127 RefTypeBB  BB09 regmask=[] minReg=1 wt=0.00>
<RefPosition #72  @129 RefTypeBB  BB15 regmask=[] minReg=1 wt=0.00>
<RefPosition #73  @135 RefTypeFixedReg <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #74  @135 RefTypeUse <Ivl:0 V00> LCL_VAR BB15 regmask=[rcx] minReg=1 last fixed wt=150.00>
<RefPosition #75  @136 RefTypeFixedReg <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #76  @136 RefTypeDef <Ivl:15> PUTARG_REG BB15 regmask=[rcx] minReg=1 fixed wt=0.00>
<RefPosition #77  @141 RefTypeFixedReg <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #78  @141 RefTypeUse <Ivl:15>  BB15 regmask=[rcx] minReg=1 last fixed wt=0.00>
<RefPosition #79  @142 RefTypeKill <Reg:rax>  BB15 regmask=[rax] minReg=1 last wt=0.00>
<RefPosition #80  @142 RefTypeKill <Reg:rcx>  BB15 regmask=[rcx] minReg=1 last wt=0.00>
<RefPosition #81  @142 RefTypeKill <Reg:rdx>  BB15 regmask=[rdx] minReg=1 last wt=0.00>
<RefPosition #82  @142 RefTypeKill <Reg:r8 >  BB15 regmask=[r8] minReg=1 last wt=0.00>
<RefPosition #83  @142 RefTypeKill <Reg:r9 >  BB15 regmask=[r9] minReg=1 last wt=0.00>
<RefPosition #84  @142 RefTypeKill <Reg:r10>  BB15 regmask=[r10] minReg=1 last wt=0.00>
<RefPosition #85  @142 RefTypeKill <Reg:r11>  BB15 regmask=[r11] minReg=1 last wt=0.00>
<RefPosition #86  @143 RefTypeBB  BB15 regmask=[] minReg=1 wt=0.00>
-----------------
<RefPosition #30  @72  RefTypeDef <Ivl:3 V07> STORE_LCL_VAR BB10 regmask=[allIntButFP] minReg=1 wt=600.00>
<RefPosition #33  @83  RefTypeUse <Ivl:3 V07> LCL_VAR BB10 regmask=[allIntButFP] minReg=1 wt=600.00>
<RefPosition #35  @93  RefTypeUse <Ivl:3 V07> LCL_VAR BB11 regmask=[allIntButFP] minReg=1 last wt=600.00>
<RefPosition #44  @115 RefTypeUse <Ivl:3 V07> LCL_VAR BB12 regmask=[rcx] minReg=1 last fixed wt=600.00>
-----------------
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rcx] minReg=1 fixed regOptional wt=100.00>
<RefPosition #2   @9   RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[allIntButFP] minReg=1 wt=150.00>
<RefPosition #74  @135 RefTypeUse <Ivl:0 V00> LCL_VAR BB15 regmask=[rcx] minReg=1 last fixed wt=150.00>
-----------------
<RefPosition #5   @12  RefTypeDef <Ivl:1 V01> STORE_LCL_VAR BB01 regmask=[allIntButFP] minReg=1 wt=300.00>
<RefPosition #6   @19  RefTypeUse <Ivl:1 V01> LCL_VAR BB01 regmask=[allIntButFP] minReg=1 regOptional wt=300.00>
<RefPosition #8   @33  RefTypeUse <Ivl:1 V01> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 last wt=300.00>
-----------------
<RefPosition #11  @36  RefTypeDef <Ivl:5 V12> STORE_LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=300.00>
<RefPosition #12  @41  RefTypeUse <Ivl:5 V12> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 regOptional wt=300.00>
<RefPosition #14  @51  RefTypeDummyDef <Ivl:5 V12>  BB17 regmask=[allIntButFP] minReg=1 regOptional wt=100.00>
<RefPosition #29  @71  RefTypeUse <Ivl:5 V12> LCL_VAR BB10 regmask=[allIntButFP] minReg=1 last wt=300.00>
-----------------
<RefPosition #38  @96  RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB11 regmask=[allIntButFP] minReg=1 wt=200.00>
<RefPosition #41  @107 RefTypeUse <Ivl:4 V10> LCL_VAR BB13 regmask=[allIntButFP] minReg=1 last wt=200.00>
<RefPosition #67  @124 RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB12 regmask=[allIntButFP] minReg=1 wt=200.00>
<RefPosition #68  @125 RefTypeExpUse <Ivl:4 V10>  BB12 regmask=[allIntButFP] minReg=1 regOptional wt=0.00>
-----------------
<RefPosition #27  @64  RefTypeDef <Ivl:2 V02> STORE_LCL_VAR BB08 regmask=[allIntButFP] minReg=1 wt=200.00>
<RefPosition #40  @107 RefTypeUse <Ivl:2 V02> LCL_VAR BB13 regmask=[allIntButFP] minReg=1 last wt=200.00>
<RefPosition #69  @125 RefTypeExpUse <Ivl:2 V02>  BB12 regmask=[allIntButFP] minReg=1 regOptional wt=0.00>
TUPLE STYLE DUMP WITH REF POSITIONS
Incoming Parameters:  V00
BB01 [000..010) -> BB14 (cond), preds={} succs={BB02,BB14}
=====
  N003.                    IL_OFFSET INLRT @ 0x000[E-]
  N005.                    V00(L0)
  N007.                    LEA(b+24)
  N009.                    IND      
                               Use:<V00/L0>(#2)
        Def:<I6>(#3) Pref:<V01/L1>
  N011.                    V01(L1)
                               Use:<I6>(#4) *
        Def:<V01/L1>(#5)
  N013.                    IL_OFFSET INL01 @ 0x003[E-] <- INLRT @ 0x007[E-]
  N015.                    V01(L1)
  N017.                    CNS_INT   null
  N019.                    EQ       
                               Use:<V01/L1>(#6)
  N021.                    JTRUE    

BB02 [007..01A) -> BB14 (cond), preds={BB01} succs={BB17,BB14}
=====
  N025.                    IL_OFFSET INL01 @ 0x006[E-] <- INLRT @ 0x007[E-]
  N027.                    IL_OFFSET INLRT @ 0x012[E-]
  N029.                    V01(L1)
  N031.                    LEA(b+16)
  N033.                    IND      
                               Use:<V01/L1>(#8) *
        Def:<I7>(#9) Pref:<V12/L5>
  N035.                    V12(L5)
                               Use:<I7>(#10) *
        Def:<V12/L5>(#11) Pref:<V07/L3>
  N037.                    V12(L5)
  N039.                    CNS_INT   null
  N041.                    EQ       
                               Use:<V12/L5>(#12)
  N043.                    JTRUE    

BB14 [048..049) (return), preds={BB01,BB02,BB09,BB13} succs={}
=====
  Dummy def of V12 at #14
  N047.                    IL_OFFSET INLRT @ 0x048[E-]
  N049.                    RETURN   

BB17 [???..???) -> BB08 (always), preds={BB02} succs={BB08}
=====

BB08 [01C..025), preds={BB17} succs={BB10}
=====
  N055.                    IL_OFFSET INLRT @ 0x022[--]
  N057.                    CNS_INT(h) 0x4000000000426c78 ftn
  N059.                    IND      
  N061.                    CALL help r2r_ind
        Kill: rax rcx rdx r8 r9 r10 r11 
        Def:<I8>(#25) rax Pref:<V02/L2>
  N063.                    V02(L2)
                               Use:<I8>(#26) *
        Def:<V02/L2>(#27)

BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}
=====
  N067.                    IL_OFFSET INLRT @ 0x02E[E-]
  N069.                    V12(L5)
  N071.                    V07(L3)
                               Use:<V12/L5>(#29) *
        Def:<V07/L3>(#30)
  N073.                    IL_OFFSET INLRT @ 0x02E[E-]
  N075.                    CNS_INT(h) 0x40000000004258b8 class
  N077.                    IND      
        Def:<I9>(#31)
  N079.                    V07(L3)
  N081.                    IND      
  N083.                    NE       
                               Use:<I9>(#32) *
                               Use:<V07/L3>(#33)
  N085.                    JTRUE    

BB11 [???..???), preds={BB10} succs={BB13}
=====
  N089.                    V07(L3)
  N091.                    LEA(b+80)
  N093.                    IND      
                               Use:<V07/L3>(#35) *
        Def:<I10>(#36) Pref:<V10/L4>
  N095.                    V10(L4)
                               Use:<I10>(#37) *
        Def:<V10/L4>(#38)

BB13 [02E..041), preds={BB11,BB12} succs={BB14}
=====
  N099.                    IL_OFFSET INLRT @ 0x02E[E-]
  N101.                    V02(L2)
  N103.                    LEA(b+8) 
  N105.                    V10(L4)
  N107.                    STOREIND 
                               Use:<V02/L2>(#40) *
                               Use:<V10/L4>(#41) *

BB12 [???..???) -> BB13 (always), preds={BB10} succs={BB13}
=====
  N111.                    IL_OFFSET INLRT @ 0x02E[E-]
  N113.                    V07(L3)
  N115.                    PUTARG_REG
                               Use:<V07/L3>(#44) Fixed:rcx(#43) *
        Def:<I11>(#46) rcx
  N117.                    CNS_INT(h) 0x4000000000424a90 ftn
        Def:<I12>(#48) r11
  N119.                    PUTARG_REG
                               Use:<I12>(#50) Fixed:r11(#49) *
        Def:<I13>(#52) r11
  N121.                    CALLV stub
                               Use:<I11>(#54) Fixed:rcx(#53) *
                               Use:<I13>(#56) Fixed:r11(#55) *
        Kill: rax rcx rdx r8 r9 r10 r11 
        Def:<I14>(#65) rax Pref:<V10/L4>
  N123.                    V10(L4)
                               Use:<I14>(#66) *
        Def:<V10/L4>(#67)

  Exposed use of V10 at #68
  Exposed use of V02 at #69
BB05 [???..???) (throw), preds={} succs={}
=====

BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}
=====

BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}
=====
  N131.                    IL_OFFSET INLRT @ 0x026[E-]
  N133.                    V00(L0)
  N135.                    PUTARG_REG
                               Use:<V00/L0>(#74) Fixed:rcx(#73) *
        Def:<I15>(#76) rcx
  N137.                    CNS_INT(h) 0x4000000000426868 ftn
  N139.                    IND      
  N141.                    CALL r2r_ind
                               Use:<I15>(#78) Fixed:rcx(#77) *
        Kill: rax rcx rdx r8 r9 r10 r11 




Linear scan intervals after buildIntervals:
Interval  0: (V00) ref (SPILLED) (writeThru) RefPositions {#0@0 #2@9 #74@135} physReg:rcx Preferences=[rcx]
Interval  1: (V01) ref RefPositions {#5@12 #6@19 #8@33} physReg:NA Preferences=[allIntButFP]
Interval  2: (V02) ref RefPositions {#27@64 #40@107 #69@125} physReg:NA Preferences=[rbx rsi rdi r12-r15]
Interval  3: (V07) ref RefPositions {#30@72 #33@83 #35@93 #44@115} physReg:NA Preferences=[rcx]
Interval  4: (V10) long (field) RefPositions {#38@96 #41@107 #67@124 #68@125} physReg:NA Preferences=[allIntButFP]
Interval  5: (V12) ref RefPositions {#11@36 #12@41 #14@51 #29@71} physReg:NA Preferences=[rbx rsi rdi r12-r15] RelatedInterval <V07/L3>
Interval  6: ref RefPositions {#3@10 #4@11} physReg:NA Preferences=[allIntButFP] RelatedInterval <V01/L1>
Interval  7: ref RefPositions {#9@34 #10@35} physReg:NA Preferences=[allIntButFP] RelatedInterval <V12/L5>
Interval  8: ref RefPositions {#25@62 #26@63} physReg:NA Preferences=[rax] RelatedInterval <V02/L2>
Interval  9: long RefPositions {#31@78 #32@83} physReg:NA Preferences=[allIntButFP]
Interval 10: long RefPositions {#36@94 #37@95} physReg:NA Preferences=[allIntButFP] RelatedInterval <V10/L4>
Interval 11: ref RefPositions {#46@116 #54@121} physReg:NA Preferences=[rcx]
Interval 12: long (constant) RefPositions {#48@118 #50@119} physReg:NA Preferences=[r11]
Interval 13: long RefPositions {#52@120 #56@121} physReg:NA Preferences=[r11]
Interval 14: long RefPositions {#65@122 #66@123} physReg:NA Preferences=[rax] RelatedInterval <V10/L4>
Interval 15: ref RefPositions {#76@136 #78@141} physReg:NA Preferences=[rcx]

*************** In LinearScan::allocateRegisters()

Linear scan intervals before allocateRegisters:
Interval  0: (V00) ref (SPILLED) (writeThru) RefPositions {#0@0 #2@9 #74@135} physReg:rcx Preferences=[rcx]
Interval  1: (V01) ref RefPositions {#5@12 #6@19 #8@33} physReg:NA Preferences=[allIntButFP]
Interval  2: (V02) ref RefPositions {#27@64 #40@107 #69@125} physReg:NA Preferences=[rbx rsi rdi r12-r15]
Interval  3: (V07) ref RefPositions {#30@72 #33@83 #35@93 #44@115} physReg:NA Preferences=[rcx]
Interval  4: (V10) long (field) RefPositions {#38@96 #41@107 #67@124 #68@125} physReg:NA Preferences=[allIntButFP]
Interval  5: (V12) ref RefPositions {#11@36 #12@41 #14@51 #29@71} physReg:NA Preferences=[rbx rsi rdi r12-r15] RelatedInterval <V07/L3>
Interval  6: ref RefPositions {#3@10 #4@11} physReg:NA Preferences=[allIntButFP] RelatedInterval <V01/L1>
Interval  7: ref RefPositions {#9@34 #10@35} physReg:NA Preferences=[allIntButFP] RelatedInterval <V12/L5>
Interval  8: ref RefPositions {#25@62 #26@63} physReg:NA Preferences=[rax] RelatedInterval <V02/L2>
Interval  9: long RefPositions {#31@78 #32@83} physReg:NA Preferences=[allIntButFP]
Interval 10: long RefPositions {#36@94 #37@95} physReg:NA Preferences=[allIntButFP] RelatedInterval <V10/L4>
Interval 11: ref RefPositions {#46@116 #54@121} physReg:NA Preferences=[rcx]
Interval 12: long (constant) RefPositions {#48@118 #50@119} physReg:NA Preferences=[r11]
Interval 13: long RefPositions {#52@120 #56@121} physReg:NA Preferences=[r11]
Interval 14: long RefPositions {#65@122 #66@123} physReg:NA Preferences=[rax] RelatedInterval <V10/L4>
Interval 15: ref RefPositions {#76@136 #78@141} physReg:NA Preferences=[rcx]

------------
REFPOSITIONS BEFORE ALLOCATION: 
------------
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rcx] minReg=1 fixed regOptional wt=100.00>
<RefPosition #1   @1   RefTypeBB  BB01 regmask=[] minReg=1 wt=100.00>
<RefPosition #2   @9   RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[allIntButFP] minReg=1 wt=150.00>
<RefPosition #3   @10  RefTypeDef <Ivl:6> IND BB01 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #4   @11  RefTypeUse <Ivl:6>  BB01 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #5   @12  RefTypeDef <Ivl:1 V01> STORE_LCL_VAR BB01 regmask=[allIntButFP] minReg=1 wt=300.00>
<RefPosition #6   @19  RefTypeUse <Ivl:1 V01> LCL_VAR BB01 regmask=[allIntButFP] minReg=1 regOptional wt=300.00>
<RefPosition #7   @23  RefTypeBB  BB02 regmask=[] minReg=1 wt=100.00>
<RefPosition #8   @33  RefTypeUse <Ivl:1 V01> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 last wt=300.00>
<RefPosition #9   @34  RefTypeDef <Ivl:7> IND BB02 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #10  @35  RefTypeUse <Ivl:7>  BB02 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #11  @36  RefTypeDef <Ivl:5 V12> STORE_LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=300.00>
<RefPosition #12  @41  RefTypeUse <Ivl:5 V12> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 regOptional wt=300.00>
<RefPosition #13  @45  RefTypeBB  BB14 regmask=[] minReg=1 wt=100.00>
<RefPosition #14  @51  RefTypeDummyDef <Ivl:5 V12>  BB17 regmask=[allIntButFP] minReg=1 regOptional wt=100.00>
<RefPosition #15  @51  RefTypeBB  BB17 regmask=[] minReg=1 wt=100.00>
<RefPosition #16  @53  RefTypeBB  BB08 regmask=[] minReg=1 wt=100.00>
<RefPosition #17  @62  RefTypeKill <Reg:rax>  BB08 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #18  @62  RefTypeKill <Reg:rcx>  BB08 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #19  @62  RefTypeKill <Reg:rdx>  BB08 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #20  @62  RefTypeKill <Reg:r8 >  BB08 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #21  @62  RefTypeKill <Reg:r9 >  BB08 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #22  @62  RefTypeKill <Reg:r10>  BB08 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #23  @62  RefTypeKill <Reg:r11>  BB08 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #24  @62  RefTypeFixedReg <Reg:rax>  BB08 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #25  @62  RefTypeDef <Ivl:8> CALL BB08 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #26  @63  RefTypeUse <Ivl:8>  BB08 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #27  @64  RefTypeDef <Ivl:2 V02> STORE_LCL_VAR BB08 regmask=[allIntButFP] minReg=1 wt=200.00>
<RefPosition #28  @65  RefTypeBB  BB10 regmask=[] minReg=1 wt=100.00>
<RefPosition #29  @71  RefTypeUse <Ivl:5 V12> LCL_VAR BB10 regmask=[allIntButFP] minReg=1 last wt=300.00>
<RefPosition #30  @72  RefTypeDef <Ivl:3 V07> STORE_LCL_VAR BB10 regmask=[allIntButFP] minReg=1 wt=600.00>
<RefPosition #31  @78  RefTypeDef <Ivl:9> IND BB10 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #32  @83  RefTypeUse <Ivl:9>  BB10 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #33  @83  RefTypeUse <Ivl:3 V07> LCL_VAR BB10 regmask=[allIntButFP] minReg=1 wt=600.00>
<RefPosition #34  @87  RefTypeBB  BB11 regmask=[] minReg=1 wt=100.00>
<RefPosition #35  @93  RefTypeUse <Ivl:3 V07> LCL_VAR BB11 regmask=[allIntButFP] minReg=1 last wt=600.00>
<RefPosition #36  @94  RefTypeDef <Ivl:10> IND BB11 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #37  @95  RefTypeUse <Ivl:10>  BB11 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #38  @96  RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB11 regmask=[allIntButFP] minReg=1 wt=200.00>
<RefPosition #39  @97  RefTypeBB  BB13 regmask=[] minReg=1 wt=100.00>
<RefPosition #40  @107 RefTypeUse <Ivl:2 V02> LCL_VAR BB13 regmask=[allIntButFP] minReg=1 last wt=200.00>
<RefPosition #41  @107 RefTypeUse <Ivl:4 V10> LCL_VAR BB13 regmask=[allIntButFP] minReg=1 last wt=200.00>
<RefPosition #42  @109 RefTypeBB  BB12 regmask=[] minReg=1 wt=0.00>
<RefPosition #43  @115 RefTypeFixedReg <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #44  @115 RefTypeUse <Ivl:3 V07> LCL_VAR BB12 regmask=[rcx] minReg=1 last fixed wt=600.00>
<RefPosition #45  @116 RefTypeFixedReg <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #46  @116 RefTypeDef <Ivl:11> PUTARG_REG BB12 regmask=[rcx] minReg=1 fixed wt=0.00>
<RefPosition #47  @118 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #48  @118 RefTypeDef <Ivl:12> CNS_INT BB12 regmask=[r11] minReg=1 fixed wt=0.00>
<RefPosition #49  @119 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #50  @119 RefTypeUse <Ivl:12>  BB12 regmask=[r11] minReg=1 last fixed wt=0.00>
<RefPosition #51  @120 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #52  @120 RefTypeDef <Ivl:13> PUTARG_REG BB12 regmask=[r11] minReg=1 fixed wt=0.00>
<RefPosition #53  @121 RefTypeFixedReg <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #54  @121 RefTypeUse <Ivl:11>  BB12 regmask=[rcx] minReg=1 last fixed wt=0.00>
<RefPosition #55  @121 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #56  @121 RefTypeUse <Ivl:13>  BB12 regmask=[r11] minReg=1 last fixed wt=0.00>
<RefPosition #57  @122 RefTypeKill <Reg:rax>  BB12 regmask=[rax] minReg=1 last wt=0.00>
<RefPosition #58  @122 RefTypeKill <Reg:rcx>  BB12 regmask=[rcx] minReg=1 last wt=0.00>
<RefPosition #59  @122 RefTypeKill <Reg:rdx>  BB12 regmask=[rdx] minReg=1 last wt=0.00>
<RefPosition #60  @122 RefTypeKill <Reg:r8 >  BB12 regmask=[r8] minReg=1 last wt=0.00>
<RefPosition #61  @122 RefTypeKill <Reg:r9 >  BB12 regmask=[r9] minReg=1 last wt=0.00>
<RefPosition #62  @122 RefTypeKill <Reg:r10>  BB12 regmask=[r10] minReg=1 last wt=0.00>
<RefPosition #63  @122 RefTypeKill <Reg:r11>  BB12 regmask=[r11] minReg=1 last wt=0.00>
<RefPosition #64  @122 RefTypeFixedReg <Reg:rax>  BB12 regmask=[rax] minReg=1 wt=0.00>
<RefPosition #65  @122 RefTypeDef <Ivl:14> CALL BB12 regmask=[rax] minReg=1 fixed wt=0.00>
<RefPosition #66  @123 RefTypeUse <Ivl:14>  BB12 regmask=[allIntButFP] minReg=1 last wt=0.00>
<RefPosition #67  @124 RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB12 regmask=[allIntButFP] minReg=1 wt=200.00>
<RefPosition #68  @125 RefTypeExpUse <Ivl:4 V10>  BB12 regmask=[allIntButFP] minReg=1 regOptional wt=0.00>
<RefPosition #69  @125 RefTypeExpUse <Ivl:2 V02>  BB12 regmask=[allIntButFP] minReg=1 regOptional wt=0.00>
<RefPosition #70  @125 RefTypeBB  BB05 regmask=[] minReg=1 wt=0.00>
<RefPosition #71  @127 RefTypeBB  BB09 regmask=[] minReg=1 wt=0.00>
<RefPosition #72  @129 RefTypeBB  BB15 regmask=[] minReg=1 wt=0.00>
<RefPosition #73  @135 RefTypeFixedReg <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #74  @135 RefTypeUse <Ivl:0 V00> LCL_VAR BB15 regmask=[rcx] minReg=1 last fixed wt=150.00>
<RefPosition #75  @136 RefTypeFixedReg <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #76  @136 RefTypeDef <Ivl:15> PUTARG_REG BB15 regmask=[rcx] minReg=1 fixed wt=0.00>
<RefPosition #77  @141 RefTypeFixedReg <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #78  @141 RefTypeUse <Ivl:15>  BB15 regmask=[rcx] minReg=1 last fixed wt=0.00>
<RefPosition #79  @142 RefTypeKill <Reg:rax>  BB15 regmask=[rax] minReg=1 last wt=0.00>
<RefPosition #80  @142 RefTypeKill <Reg:rcx>  BB15 regmask=[rcx] minReg=1 last wt=0.00>
<RefPosition #81  @142 RefTypeKill <Reg:rdx>  BB15 regmask=[rdx] minReg=1 last wt=0.00>
<RefPosition #82  @142 RefTypeKill <Reg:r8 >  BB15 regmask=[r8] minReg=1 last wt=0.00>
<RefPosition #83  @142 RefTypeKill <Reg:r9 >  BB15 regmask=[r9] minReg=1 last wt=0.00>
<RefPosition #84  @142 RefTypeKill <Reg:r10>  BB15 regmask=[r10] minReg=1 last wt=0.00>
<RefPosition #85  @142 RefTypeKill <Reg:r11>  BB15 regmask=[r11] minReg=1 last wt=0.00>
<RefPosition #86  @143 RefTypeBB  BB15 regmask=[] minReg=1 wt=0.00>

VAR REFPOSITIONS BEFORE ALLOCATION
--- V00  (Interval 0)
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rcx] minReg=1 fixed regOptional wt=100.00>
<RefPosition #2   @9   RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[allIntButFP] minReg=1 wt=150.00>
<RefPosition #74  @135 RefTypeUse <Ivl:0 V00> LCL_VAR BB15 regmask=[rcx] minReg=1 last fixed wt=150.00>
--- V01  (Interval 1)
<RefPosition #5   @12  RefTypeDef <Ivl:1 V01> STORE_LCL_VAR BB01 regmask=[allIntButFP] minReg=1 wt=300.00>
<RefPosition #6   @19  RefTypeUse <Ivl:1 V01> LCL_VAR BB01 regmask=[allIntButFP] minReg=1 regOptional wt=300.00>
<RefPosition #8   @33  RefTypeUse <Ivl:1 V01> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 last wt=300.00>
--- V02  (Interval 2)
<RefPosition #27  @64  RefTypeDef <Ivl:2 V02> STORE_LCL_VAR BB08 regmask=[allIntButFP] minReg=1 wt=200.00>
<RefPosition #40  @107 RefTypeUse <Ivl:2 V02> LCL_VAR BB13 regmask=[allIntButFP] minReg=1 last wt=200.00>
<RefPosition #69  @125 RefTypeExpUse <Ivl:2 V02>  BB12 regmask=[allIntButFP] minReg=1 regOptional wt=0.00>
--- V03
--- V04
--- V05
--- V06
--- V07  (Interval 3)
<RefPosition #30  @72  RefTypeDef <Ivl:3 V07> STORE_LCL_VAR BB10 regmask=[allIntButFP] minReg=1 wt=600.00>
<RefPosition #33  @83  RefTypeUse <Ivl:3 V07> LCL_VAR BB10 regmask=[allIntButFP] minReg=1 wt=600.00>
<RefPosition #35  @93  RefTypeUse <Ivl:3 V07> LCL_VAR BB11 regmask=[allIntButFP] minReg=1 last wt=600.00>
<RefPosition #44  @115 RefTypeUse <Ivl:3 V07> LCL_VAR BB12 regmask=[rcx] minReg=1 last fixed wt=600.00>
--- V08
--- V09
--- V10  (Interval 4)
<RefPosition #38  @96  RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB11 regmask=[allIntButFP] minReg=1 wt=200.00>
<RefPosition #41  @107 RefTypeUse <Ivl:4 V10> LCL_VAR BB13 regmask=[allIntButFP] minReg=1 last wt=200.00>
<RefPosition #67  @124 RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB12 regmask=[allIntButFP] minReg=1 wt=200.00>
<RefPosition #68  @125 RefTypeExpUse <Ivl:4 V10>  BB12 regmask=[allIntButFP] minReg=1 regOptional wt=0.00>
--- V11
--- V12  (Interval 5)
<RefPosition #11  @36  RefTypeDef <Ivl:5 V12> STORE_LCL_VAR BB02 regmask=[allIntButFP] minReg=1 wt=300.00>
<RefPosition #12  @41  RefTypeUse <Ivl:5 V12> LCL_VAR BB02 regmask=[allIntButFP] minReg=1 regOptional wt=300.00>
<RefPosition #14  @51  RefTypeDummyDef <Ivl:5 V12>  BB17 regmask=[allIntButFP] minReg=1 regOptional wt=100.00>
<RefPosition #29  @71  RefTypeUse <Ivl:5 V12> LCL_VAR BB10 regmask=[allIntButFP] minReg=1 last wt=300.00>



Allocating Registers
--------------------
The following table has one or more rows for each RefPosition that is handled during allocation.
The first column provides the basic information about the RefPosition, with its type (e.g. Def,
Use, Fixd) followed by a '*' if it is a last use, and a 'D' if it is delayRegFree, and then the
action taken during allocation (e.g. Alloc a new register, or Keep an existing one).
The subsequent columns show the Interval occupying each register, if any, followed by 'a' if it is
active, a 'p' if it is a large vector that has been partially spilled, and 'i'if it is inactive.
Columns are only printed up to the last modifed register, which may increase during allocation,
in which case additional columns will appear.  
Registers which are not marked modified have ---- in their column.

----------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
----------------------------------+----+----+----+----+----+----+----+----+----+
                                  |    |V0 a|    |    |    |    |    |    |    |
  0.#0  V0   Parm   Keep     rcx  |    |V0 a|    |    |    |    |    |    |    |
  1.#1  BB1  PredBB0              |    |V0 a|    |    |    |    |    |    |    |
  9.#2  V0   Use    Keep     rcx  |    |V0 a|    |    |    |    |    |    |    |
 10.#3  I6   Def    ORDER(A) rax  |I6 a|V0 a|    |    |    |    |    |    |    |
 11.#4  I6   Use *  Keep     rax  |I6 a|V0 a|    |    |    |    |    |    |    |
 12.#5  V1   Def    COVRS(A) rax  |V1 a|V0 a|    |    |    |    |    |    |    |
 19.#6  V1   Use    Keep     rax  |V1 a|V0 a|    |    |    |    |    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
----------------------------------+----+----+----+----+----+----+----+----+----+
 23.#7  BB2  PredBB1              |V1 a|V0 a|    |    |    |    |    |    |    |
 33.#8  V1   Use *  Keep     rax  |V1 a|V0 a|    |    |    |    |    |    |    |
 34.#9  I7   Def    ORDER(A) rsi  |    |V0 a|    |    |    |I7 a|    |    |    |
 35.#10 I7   Use *  Keep     rsi  |    |V0 a|    |    |    |I7 a|    |    |    |
 36.#11 V12  Def    COVRS(A) rsi  |    |V0 a|    |    |    |V12a|    |    |    |
 41.#12 V12  Use    Keep     rsi  |    |V0 a|    |    |    |V12a|    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
----------------------------------+----+----+----+----+----+----+----+----+----+
 45.#13 BB14 PredBB1              |    |V0 i|    |    |    |V12i|    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
----------------------------------+----+----+----+----+----+----+----+----+----+
                    DDefs        |    |V0 a|    |    |    |V12a|    |    |    |
 51.#14 V12  DDef   Keep     rsi  |    |V0 a|    |    |    |V12a|    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
----------------------------------+----+----+----+----+----+----+----+----+----+
 51.#15 BB17 PredBB1              |    |V0 a|    |    |    |V12a|    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
----------------------------------+----+----+----+----+----+----+----+----+----+
 53.#16 BB8  PredBB17             |    |V0 a|    |    |    |V12a|    |    |    |
 62.#17 rax  Kill   Keep     rax  |    |V0 a|    |    |    |V12a|    |    |    |
 62.#18 rcx  Kill   Spill    rcx  |    |    |    |    |    |V12a|    |    |    |
                    Keep     rcx  |    |    |    |    |    |V12a|    |    |    |
 62.#19 rdx  Kill   Keep     rdx  |    |    |    |    |    |V12a|    |    |    |
 62.#20 r8   Kill   Keep     r8   |    |    |    |    |    |V12a|    |    |    |
 62.#21 r9   Kill   Keep     r9   |    |    |    |    |    |V12a|    |    |    |
 62.#22 r10  Kill   Keep     r10  |    |    |    |    |    |V12a|    |    |    |
 62.#23 r11  Kill   Keep     r11  |    |    |    |    |    |V12a|    |    |    |
 62.#24 rax  Fixd   Keep     rax  |    |    |    |    |    |V12a|    |    |    |
 62.#25 I8   Def    Alloc    rax  |I8 a|    |    |    |    |V12a|    |    |    |
 63.#26 I8   Use *  Keep     rax  |I8 a|    |    |    |    |V12a|    |    |    |
 64.#27 V2   Def    ORDER(A) rdi  |    |    |    |    |    |V12a|V2 a|    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
----------------------------------+----+----+----+----+----+----+----+----+----+
 65.#28 BB10 PredBB8              |    |    |    |    |    |V12a|V2 a|    |    |
 71.#29 V12  Use *  Keep     rsi  |    |    |    |    |    |V12a|V2 a|    |    |
 72.#30 V7   Def    CRCE (A) rcx  |    |V7 a|    |    |    |    |V2 a|    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
 78.#31 I9   Def    BSFIT(A) r11  |    |V7 a|    |    |    |    |V2 a|    |    |I9 a|
 83.#32 I9   Use *  Keep     r11  |    |V7 a|    |    |    |    |V2 a|    |    |I9 a|
 83.#33 V7   Use    Keep     rcx  |    |V7 a|    |    |    |    |V2 a|    |    |I9 a|
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
 87.#34 BB11 PredBB10             |    |V7 a|    |    |    |    |V2 a|    |    |    |
 93.#35 V7   Use *  Keep     rcx  |    |V7 i|    |    |    |    |V2 a|    |    |    |
 94.#36 I10  Def    ORDER(A) rsi  |    |V7 i|    |    |    |I10a|V2 a|    |    |    |
 95.#37 I10  Use *  Keep     rsi  |    |V7 i|    |    |    |I10a|V2 a|    |    |    |
 96.#38 V10  Def    COVRS(A) rsi  |    |V7 i|    |    |    |V10a|V2 a|    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
 97.#39 BB13 PredBB11             |    |V7 i|    |    |    |V10a|V2 a|    |    |    |
107.#40 V2   Use *  Keep     rdi  |    |V7 i|    |    |    |V10a|V2 i|    |    |    |
107.#41 V10  Use *  Keep     rsi  |    |V7 i|    |    |    |V10i|V2 i|    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
109.#42 BB12 PredBB10             |    |V7 a|    |    |    |V10i|V2 a|    |    |    |
115.#43 rcx  Fixd   Keep     rcx  |    |V7 a|    |    |    |V10i|V2 a|    |    |    |
115.#44 V7   Use *  Keep     rcx  |    |V7 a|    |    |    |V10i|V2 a|    |    |    |
116.#45 rcx  Fixd   Keep     rcx  |    |    |    |    |    |V10i|V2 a|    |    |    |
116.#46 I11  Def    Alloc    rcx  |    |I11a|    |    |    |V10i|V2 a|    |    |    |
118.#47 r11  Fixd   Keep     r11  |    |I11a|    |    |    |V10i|V2 a|    |    |    |
118.#48 C12  Def    Alloc    r11  |    |I11a|    |    |    |V10i|V2 a|    |    |C12a|
119.#49 r11  Fixd   Keep     r11  |    |I11a|    |    |    |V10i|V2 a|    |    |C12a|
119.#50 C12  Use *  Keep     r11  |    |I11a|    |    |    |V10i|V2 a|    |    |C12a|
120.#51 r11  Fixd   Keep     r11  |    |I11a|    |    |    |V10i|V2 a|    |    |    |
120.#52 I13  Def    Alloc    r11  |    |I11a|    |    |    |V10i|V2 a|    |    |I13a|
121.#53 rcx  Fixd   Keep     rcx  |    |I11a|    |    |    |V10i|V2 a|    |    |I13a|
121.#54 I11  Use *  Keep     rcx  |    |I11a|    |    |    |V10i|V2 a|    |    |I13a|
121.#55 r11  Fixd   Keep     r11  |    |I11a|    |    |    |V10i|V2 a|    |    |I13a|
121.#56 I13  Use *  Keep     r11  |    |I11a|    |    |    |V10i|V2 a|    |    |I13a|
122.#57 rax  Kill   Keep     rax  |    |    |    |    |    |V10i|V2 a|    |    |    |
122.#58 rcx  Kill   Keep     rcx  |    |    |    |    |    |V10i|V2 a|    |    |    |
122.#59 rdx  Kill   Keep     rdx  |    |    |    |    |    |V10i|V2 a|    |    |    |
122.#60 r8   Kill   Keep     r8   |    |    |    |    |    |V10i|V2 a|    |    |    |
122.#61 r9   Kill   Keep     r9   |    |    |    |    |    |V10i|V2 a|    |    |    |
122.#62 r10  Kill   Keep     r10  |    |    |    |    |    |V10i|V2 a|    |    |    |
122.#63 r11  Kill   Keep     r11  |    |    |    |    |    |V10i|V2 a|    |    |    |
122.#64 rax  Fixd   Keep     rax  |    |    |    |    |    |V10i|V2 a|    |    |    |
122.#65 I14  Def    Alloc    rax  |I14a|    |    |    |    |V10i|V2 a|    |    |    |
123.#66 I14  Use *  Keep     rax  |I14a|    |    |    |    |V10i|V2 a|    |    |    |
124.#67 V10  Def    Keep     rsi  |    |    |    |    |    |V10a|V2 a|    |    |    |
125.#68 V10  ExpU   Keep     NA   |    |    |    |    |    |V10a|V2 a|    |    |    |
125.#69 V2   ExpU   Keep     NA   |    |    |    |    |    |V10a|V2 a|    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
125.#70 BB5  PredBB0              |    |    |    |    |    |    |    |    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
127.#71 BB9  PredBB0              |    |    |    |    |    |    |    |    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
129.#72 BB15 PredBB0              |    |    |    |    |    |    |    |    |    |    |
135.#73 rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |    |
135.#74 V0   Use *  ReLod    NA   |    |    |    |    |    |    |    |    |    |    |
                    Alloc    rcx  |    |V0 a|    |    |    |    |    |    |    |    |
136.#75 rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |    |
136.#76 I15  Def    Alloc    rcx  |    |I15a|    |    |    |    |    |    |    |    |
141.#77 rcx  Fixd   Keep     rcx  |    |I15a|    |    |    |    |    |    |    |    |
141.#78 I15  Use *  Keep     rcx  |    |I15a|    |    |    |    |    |    |    |    |
142.#79 rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |    |
142.#80 rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |    |
142.#81 rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |    |
142.#82 r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |    |
142.#83 r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |    |
142.#84 r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |    |
142.#85 r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |    |
143.#86 END                      |    |    |    |    |    |    |    |    |    |    |

------------
REFPOSITIONS AFTER ALLOCATION: 
------------
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rcx] minReg=1 singleDefSpill fixed regOptional wt=100.00>
<RefPosition #1   @1   RefTypeBB  BB01 regmask=[] minReg=1 wt=100.00>
<RefPosition #2   @9   RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[rcx] minReg=1 spillAfter wt=150.00>
<RefPosition #3   @10  RefTypeDef <Ivl:6> IND BB01 regmask=[rax] minReg=1 wt=400.00>
<RefPosition #4   @11  RefTypeUse <Ivl:6>  BB01 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #5   @12  RefTypeDef <Ivl:1 V01> STORE_LCL_VAR BB01 regmask=[rax] minReg=1 wt=300.00>
<RefPosition #6   @19  RefTypeUse <Ivl:1 V01> LCL_VAR BB01 regmask=[rax] minReg=1 regOptional wt=300.00>
<RefPosition #7   @23  RefTypeBB  BB02 regmask=[] minReg=1 wt=100.00>
<RefPosition #8   @33  RefTypeUse <Ivl:1 V01> LCL_VAR BB02 regmask=[rax] minReg=1 last wt=300.00>
<RefPosition #9   @34  RefTypeDef <Ivl:7> IND BB02 regmask=[rsi] minReg=1 wt=400.00>
<RefPosition #10  @35  RefTypeUse <Ivl:7>  BB02 regmask=[rsi] minReg=1 last wt=100.00>
<RefPosition #11  @36  RefTypeDef <Ivl:5 V12> STORE_LCL_VAR BB02 regmask=[rsi] minReg=1 wt=300.00>
<RefPosition #12  @41  RefTypeUse <Ivl:5 V12> LCL_VAR BB02 regmask=[rsi] minReg=1 regOptional wt=300.00>
<RefPosition #13  @45  RefTypeBB  BB14 regmask=[] minReg=1 wt=100.00>
<RefPosition #14  @51  RefTypeDummyDef <Ivl:5 V12>  BB17 regmask=[rsi] minReg=1 regOptional wt=100.00>
<RefPosition #15  @51  RefTypeBB  BB17 regmask=[] minReg=1 wt=100.00>
<RefPosition #16  @53  RefTypeBB  BB08 regmask=[] minReg=1 wt=100.00>
<RefPosition #17  @62  RefTypeKill <Reg:rax>  BB08 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #18  @62  RefTypeKill <Reg:rcx>  BB08 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #19  @62  RefTypeKill <Reg:rdx>  BB08 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #20  @62  RefTypeKill <Reg:r8 >  BB08 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #21  @62  RefTypeKill <Reg:r9 >  BB08 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #22  @62  RefTypeKill <Reg:r10>  BB08 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #23  @62  RefTypeKill <Reg:r11>  BB08 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #24  @62  RefTypeFixedReg <Reg:rax>  BB08 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #25  @62  RefTypeDef <Ivl:8> CALL BB08 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #26  @63  RefTypeUse <Ivl:8>  BB08 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #27  @64  RefTypeDef <Ivl:2 V02> STORE_LCL_VAR BB08 regmask=[rdi] minReg=1 wt=200.00>
<RefPosition #28  @65  RefTypeBB  BB10 regmask=[] minReg=1 wt=100.00>
<RefPosition #29  @71  RefTypeUse <Ivl:5 V12> LCL_VAR BB10 regmask=[rsi] minReg=1 last outOfOrder wt=300.00>
<RefPosition #30  @72  RefTypeDef <Ivl:3 V07> STORE_LCL_VAR BB10 regmask=[rcx] minReg=1 wt=600.00>
<RefPosition #31  @78  RefTypeDef <Ivl:9> IND BB10 regmask=[r11] minReg=1 wt=400.00>
<RefPosition #32  @83  RefTypeUse <Ivl:9>  BB10 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #33  @83  RefTypeUse <Ivl:3 V07> LCL_VAR BB10 regmask=[rcx] minReg=1 wt=600.00>
<RefPosition #34  @87  RefTypeBB  BB11 regmask=[] minReg=1 wt=100.00>
<RefPosition #35  @93  RefTypeUse <Ivl:3 V07> LCL_VAR BB11 regmask=[rcx] minReg=1 last wt=600.00>
<RefPosition #36  @94  RefTypeDef <Ivl:10> IND BB11 regmask=[rsi] minReg=1 wt=400.00>
<RefPosition #37  @95  RefTypeUse <Ivl:10>  BB11 regmask=[rsi] minReg=1 last wt=100.00>
<RefPosition #38  @96  RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB11 regmask=[rsi] minReg=1 wt=200.00>
<RefPosition #39  @97  RefTypeBB  BB13 regmask=[] minReg=1 wt=100.00>
<RefPosition #40  @107 RefTypeUse <Ivl:2 V02> LCL_VAR BB13 regmask=[rdi] minReg=1 last wt=200.00>
<RefPosition #41  @107 RefTypeUse <Ivl:4 V10> LCL_VAR BB13 regmask=[rsi] minReg=1 last wt=200.00>
<RefPosition #42  @109 RefTypeBB  BB12 regmask=[] minReg=1 wt=0.00>
<RefPosition #43  @115 RefTypeFixedReg <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #44  @115 RefTypeUse <Ivl:3 V07> LCL_VAR BB12 regmask=[rcx] minReg=1 last fixed wt=600.00>
<RefPosition #45  @116 RefTypeFixedReg <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #46  @116 RefTypeDef <Ivl:11> PUTARG_REG BB12 regmask=[rcx] minReg=1 fixed wt=0.00>
<RefPosition #47  @118 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #48  @118 RefTypeDef <Ivl:12> CNS_INT BB12 regmask=[r11] minReg=1 fixed wt=0.00>
<RefPosition #49  @119 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #50  @119 RefTypeUse <Ivl:12>  BB12 regmask=[r11] minReg=1 last fixed wt=0.00>
<RefPosition #51  @120 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #52  @120 RefTypeDef <Ivl:13> PUTARG_REG BB12 regmask=[r11] minReg=1 fixed wt=0.00>
<RefPosition #53  @121 RefTypeFixedReg <Reg:rcx>  BB12 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #54  @121 RefTypeUse <Ivl:11>  BB12 regmask=[rcx] minReg=1 last fixed wt=0.00>
<RefPosition #55  @121 RefTypeFixedReg <Reg:r11>  BB12 regmask=[r11] minReg=1 wt=0.00>
<RefPosition #56  @121 RefTypeUse <Ivl:13>  BB12 regmask=[r11] minReg=1 last fixed wt=0.00>
<RefPosition #57  @122 RefTypeKill <Reg:rax>  BB12 regmask=[rax] minReg=1 last wt=0.00>
<RefPosition #58  @122 RefTypeKill <Reg:rcx>  BB12 regmask=[rcx] minReg=1 last wt=0.00>
<RefPosition #59  @122 RefTypeKill <Reg:rdx>  BB12 regmask=[rdx] minReg=1 last wt=0.00>
<RefPosition #60  @122 RefTypeKill <Reg:r8 >  BB12 regmask=[r8] minReg=1 last wt=0.00>
<RefPosition #61  @122 RefTypeKill <Reg:r9 >  BB12 regmask=[r9] minReg=1 last wt=0.00>
<RefPosition #62  @122 RefTypeKill <Reg:r10>  BB12 regmask=[r10] minReg=1 last wt=0.00>
<RefPosition #63  @122 RefTypeKill <Reg:r11>  BB12 regmask=[r11] minReg=1 last wt=0.00>
<RefPosition #64  @122 RefTypeFixedReg <Reg:rax>  BB12 regmask=[rax] minReg=1 wt=0.00>
<RefPosition #65  @122 RefTypeDef <Ivl:14> CALL BB12 regmask=[rax] minReg=1 fixed wt=0.00>
<RefPosition #66  @123 RefTypeUse <Ivl:14>  BB12 regmask=[rax] minReg=1 last wt=0.00>
<RefPosition #67  @124 RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB12 regmask=[rsi] minReg=1 wt=200.00>
<RefPosition #68  @125 RefTypeExpUse <Ivl:4 V10>  BB12 regmask=[allIntButFP] minReg=1 regOptional wt=0.00>
<RefPosition #69  @125 RefTypeExpUse <Ivl:2 V02>  BB12 regmask=[allIntButFP] minReg=1 regOptional wt=0.00>
<RefPosition #70  @125 RefTypeBB  BB05 regmask=[] minReg=1 wt=0.00>
<RefPosition #71  @127 RefTypeBB  BB09 regmask=[] minReg=1 wt=0.00>
<RefPosition #72  @129 RefTypeBB  BB15 regmask=[] minReg=1 wt=0.00>
<RefPosition #73  @135 RefTypeFixedReg <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #74  @135 RefTypeUse <Ivl:0 V00> LCL_VAR BB15 regmask=[rcx] minReg=1 last reload fixed wt=150.00>
<RefPosition #75  @136 RefTypeFixedReg <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #76  @136 RefTypeDef <Ivl:15> PUTARG_REG BB15 regmask=[rcx] minReg=1 fixed wt=0.00>
<RefPosition #77  @141 RefTypeFixedReg <Reg:rcx>  BB15 regmask=[rcx] minReg=1 wt=0.00>
<RefPosition #78  @141 RefTypeUse <Ivl:15>  BB15 regmask=[rcx] minReg=1 last fixed wt=0.00>
<RefPosition #79  @142 RefTypeKill <Reg:rax>  BB15 regmask=[rax] minReg=1 last wt=0.00>
<RefPosition #80  @142 RefTypeKill <Reg:rcx>  BB15 regmask=[rcx] minReg=1 last wt=0.00>
<RefPosition #81  @142 RefTypeKill <Reg:rdx>  BB15 regmask=[rdx] minReg=1 last wt=0.00>
<RefPosition #82  @142 RefTypeKill <Reg:r8 >  BB15 regmask=[r8] minReg=1 last wt=0.00>
<RefPosition #83  @142 RefTypeKill <Reg:r9 >  BB15 regmask=[r9] minReg=1 last wt=0.00>
<RefPosition #84  @142 RefTypeKill <Reg:r10>  BB15 regmask=[r10] minReg=1 last wt=0.00>
<RefPosition #85  @142 RefTypeKill <Reg:r11>  BB15 regmask=[r11] minReg=1 last wt=0.00>
<RefPosition #86  @143 RefTypeBB  BB15 regmask=[] minReg=1 wt=0.00>

VAR REFPOSITIONS AFTER ALLOCATION
--- V00  (Interval 0)
<RefPosition #0   @0   RefTypeParamDef <Ivl:0 V00>  BB00 regmask=[rcx] minReg=1 singleDefSpill fixed regOptional wt=100.00>
<RefPosition #2   @9   RefTypeUse <Ivl:0 V00> LCL_VAR BB01 regmask=[rcx] minReg=1 spillAfter wt=150.00>
<RefPosition #74  @135 RefTypeUse <Ivl:0 V00> LCL_VAR BB15 regmask=[rcx] minReg=1 last reload fixed wt=150.00>
--- V01  (Interval 1)
<RefPosition #5   @12  RefTypeDef <Ivl:1 V01> STORE_LCL_VAR BB01 regmask=[rax] minReg=1 wt=300.00>
<RefPosition #6   @19  RefTypeUse <Ivl:1 V01> LCL_VAR BB01 regmask=[rax] minReg=1 regOptional wt=300.00>
<RefPosition #8   @33  RefTypeUse <Ivl:1 V01> LCL_VAR BB02 regmask=[rax] minReg=1 last wt=300.00>
--- V02  (Interval 2)
<RefPosition #27  @64  RefTypeDef <Ivl:2 V02> STORE_LCL_VAR BB08 regmask=[rdi] minReg=1 wt=200.00>
<RefPosition #40  @107 RefTypeUse <Ivl:2 V02> LCL_VAR BB13 regmask=[rdi] minReg=1 last wt=200.00>
<RefPosition #69  @125 RefTypeExpUse <Ivl:2 V02>  BB12 regmask=[allIntButFP] minReg=1 regOptional wt=0.00>
--- V03
--- V04
--- V05
--- V06
--- V07  (Interval 3)
<RefPosition #30  @72  RefTypeDef <Ivl:3 V07> STORE_LCL_VAR BB10 regmask=[rcx] minReg=1 wt=600.00>
<RefPosition #33  @83  RefTypeUse <Ivl:3 V07> LCL_VAR BB10 regmask=[rcx] minReg=1 wt=600.00>
<RefPosition #35  @93  RefTypeUse <Ivl:3 V07> LCL_VAR BB11 regmask=[rcx] minReg=1 last wt=600.00>
<RefPosition #44  @115 RefTypeUse <Ivl:3 V07> LCL_VAR BB12 regmask=[rcx] minReg=1 last fixed wt=600.00>
--- V08
--- V09
--- V10  (Interval 4)
<RefPosition #38  @96  RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB11 regmask=[rsi] minReg=1 wt=200.00>
<RefPosition #41  @107 RefTypeUse <Ivl:4 V10> LCL_VAR BB13 regmask=[rsi] minReg=1 last wt=200.00>
<RefPosition #67  @124 RefTypeDef <Ivl:4 V10> STORE_LCL_VAR BB12 regmask=[rsi] minReg=1 wt=200.00>
<RefPosition #68  @125 RefTypeExpUse <Ivl:4 V10>  BB12 regmask=[allIntButFP] minReg=1 regOptional wt=0.00>
--- V11
--- V12  (Interval 5)
<RefPosition #11  @36  RefTypeDef <Ivl:5 V12> STORE_LCL_VAR BB02 regmask=[rsi] minReg=1 wt=300.00>
<RefPosition #12  @41  RefTypeUse <Ivl:5 V12> LCL_VAR BB02 regmask=[rsi] minReg=1 regOptional wt=300.00>
<RefPosition #14  @51  RefTypeDummyDef <Ivl:5 V12>  BB17 regmask=[rsi] minReg=1 regOptional wt=100.00>
<RefPosition #29  @71  RefTypeUse <Ivl:5 V12> LCL_VAR BB10 regmask=[rsi] minReg=1 last outOfOrder wt=300.00>

Active intervals at end of allocation:

-----------------------
RESOLVING BB BOUNDARIES
-----------------------
Resolution Candidates: {V00 V01 V02 V07 V10 V12}
Has Critical Edges

Prior to Resolution

BB01
use def in out
{V00}
{V01}
{V00}
{V00 V01}
Var=Reg beg of BB01: V00=rcx 
Var=Reg end of BB01: V01=rax 

BB02
use def in out
{V01}
{V12}
{V00 V01}
{V00 V12}
Var=Reg beg of BB02: V01=rax 
Var=Reg end of BB02: V12=rsi 

BB17
use def in out
{}
{}
{V00 V12}
{V00 V12}
Var=Reg beg of BB17: V12=rsi 
Var=Reg end of BB17: V12=rsi 

BB05
use def in out
{}
{}
{}
{}
Var=Reg beg of BB05: none
Var=Reg end of BB05: none

BB08
use def in out
{}
{V02}
{V00 V12}
{V00 V02 V12}
Var=Reg beg of BB08: V12=rsi 
Var=Reg end of BB08: V12=rsi V02=rdi 

BB10
use def in out
{V12}
{V07}
{V02 V12}
{V02 V07}
Var=Reg beg of BB10: V12=rsi V02=rdi 
Var=Reg end of BB10: V07=rcx V02=rdi 

BB11
use def in out
{V07}
{V10}
{V02 V07}
{V02 V10}
Var=Reg beg of BB11: V07=rcx V02=rdi 
Var=Reg end of BB11: V10=rsi V02=rdi 

BB13
use def in out
{V02 V10}
{}
{V02 V10}
{}
Var=Reg beg of BB13: V10=rsi V02=rdi 
Var=Reg end of BB13: none

BB14
use def in out
{}
{}
{}
{}
Var=Reg beg of BB14: none
Var=Reg end of BB14: none

BB09
use def in out
{}
{}
{}
{}
Var=Reg beg of BB09: none
Var=Reg end of BB09: none

BB12
use def in out
{V07}
{V10}
{V02 V07}
{V02 V10}
Var=Reg beg of BB12: V07=rcx V02=rdi 
Var=Reg end of BB12: V10=rsi V02=rdi 

BB15  EH flow in  EH flow out
use def in out
{V00}
{}
{V00}
{}
Var=Reg beg of BB15: none
Var=Reg end of BB15: none


RESOLVING EDGES

  Set V00 argument initial register to rcx
Trees after linear scan register allocator (LSRA)

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB14 ( cond )                     keep i IBC LIR 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC LIR 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal LIR 
BB05 [0031]  0                             0      0    [???..???)        (throw )                     keep i rare IBC LIR 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC LIR 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC LIR 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC LIR 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC LIR 
BB14 [0017]  4       BB01,BB02,BB09,BB13   1     85    [048..049)        (return)                     i IBC LIR 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe LIR 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC LIR 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [000..010) -> BB14 (cond), preds={} succs={BB02,BB14}
N003 (???,???) [000127] -----------                            IL_OFFSET void   INLRT @ 0x000[E-] REG NA
N005 (  1,  1) [000000] ----------Z                    t0 =    LCL_VAR   ref    V00 this         u:1 rcx REG rcx $80
                                                            /--*  t0     ref    
N007 (  2,  2) [000097] -c---------                   t97 = *  LEA(b+24) byref  REG NA
                                                            /--*  t97    byref  
N009 (  4,  4) [000001] ---XG------                    t1 = *  IND       ref    REG rax <l:$202, c:$203>
                                                            /--*  t1     ref    
N011 (  4,  4) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V01 loc0         d:1 rax REG rax
N013 (???,???) [000128] -----------                            IL_OFFSET void   INL01 @ 0x003[E-] <- INLRT @ 0x007[E-] REG NA
N015 (  1,  1) [000004] -----------                    t4 =    LCL_VAR   ref    V01 loc0         u:1 rax REG rax <l:$200, c:$81>
N017 (  1,  1) [000076] -c---------                   t76 =    CNS_INT   ref    null REG NA $VN.Null
                                                            /--*  t4     ref    
                                                            +--*  t76    ref    
N019 (  3,  3) [000077] J------N---                         *  EQ        void   REG NA <l:$241, c:$240>
N021 (  5,  5) [000078] -----------                         *  JTRUE     void   REG NA $VN.Void

------------ BB02 [007..01A) -> BB14 (cond), preds={BB01} succs={BB17,BB14}
N025 (???,???) [000129] -----------                            IL_OFFSET void   INL01 @ 0x006[E-] <- INLRT @ 0x007[E-] REG NA
N027 (???,???) [000130] -----------                            IL_OFFSET void   INLRT @ 0x012[E-] REG NA
N029 (  1,  1) [000012] -----------                   t12 =    LCL_VAR   ref    V01 loc0         u:1 rax (last use) REG rax <l:$200, c:$81>
                                                            /--*  t12    ref    
N031 (  2,  2) [000099] -c---------                   t99 = *  LEA(b+16) byref  REG NA
                                                            /--*  t99    byref  
N033 (  4,  4) [000013] n---GO-----                   t13 = *  IND       ref    REG rsi <l:$208, c:$209>
                                                            /--*  t13    ref    
N035 (  4,  4) [000123] DA--GO-----                         *  STORE_LCL_VAR ref    V12 cse0         d:1 rsi REG rsi
N037 (  1,  1) [000124] -----------                  t124 =    LCL_VAR   ref    V12 cse0         u:1 rsi REG rsi <l:$208, c:$209>
N039 (  1,  1) [000014] -c---------                   t14 =    CNS_INT   ref    null REG NA $VN.Null
                                                            /--*  t124   ref    
                                                            +--*  t14    ref    
N041 (  7,  7) [000015] J---GO-N---                         *  EQ        void   REG NA
N043 (  9,  9) [000016] ----GO-----                         *  JTRUE     void   REG NA <l:$20b, c:$20a>

------------ BB17 [???..???) -> BB08 (always), preds={BB02} succs={BB08}

------------ BB05 [???..???) (throw), preds={} succs={}

------------ BB08 [01C..025), preds={BB17} succs={BB10}
N055 (???,???) [000132] -----------                            IL_OFFSET void   INLRT @ 0x022[--] REG NA
N057 (  1,  4) [000140] Hc---------                  t140 =    CNS_INT(h) long   0x4000000000426c78 ftn REG NA
                                                            /--*  t140   long   
N059 (  3,  6) [000141] -c---------                  t141 = *  IND       long   REG NA
                                                            /--*  t141   long   control expr
N061 ( 14,  5) [000021] --C--------                   t21 = *  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW REG rax $20c
                                                            /--*  t21    ref    
N063 ( 18,  8) [000028] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         d:1 rdi REG rdi

------------ BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}
N067 (???,???) [000133] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-] REG NA
N069 (  1,  1) [000126] -----------                  t126 =    LCL_VAR   ref    V12 cse0         u:1 rsi (last use) REG rsi <l:$205, c:$83>
                                                            /--*  t126   ref    
N071 (  1,  3) [000051] DA--G------                         *  STORE_LCL_VAR ref    V07 tmp4         d:1 rcx REG rcx
N073 (???,???) [000134] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-] REG NA
N075 (  1,  4) [000055] Hc---------                   t55 =    CNS_INT(h) long   0x40000000004258b8 class REG NA $183
                                                            /--*  t55    long   
N077 (  3,  6) [000056] #----------                   t56 = *  IND       long   REG r11 $280
N079 (  1,  1) [000052] -----------                   t52 =    LCL_VAR   ref    V07 tmp4         u:1 rcx REG rcx <l:$205, c:$87>
                                                            /--*  t52    ref    
N081 (  3,  2) [000054] #c-X-------                   t54 = *  IND       long   REG NA <l:$2c0, c:$2c1>
                                                            /--*  t56    long   
                                                            +--*  t54    long   
N083 (  7,  9) [000057] J--X---N---                         *  NE        void   REG NA <l:$249, c:$248>
N085 (  9, 11) [000058] ---X-------                         *  JTRUE     void   REG NA <l:$211, c:$210>

------------ BB11 [???..???), preds={BB10} succs={BB13}
N089 (  1,  1) [000059] -----------                   t59 =    LCL_VAR   ref    V07 tmp4         u:1 rcx (last use) REG rcx <l:$205, c:$87>
                                                            /--*  t59    ref    
N091 (  2,  2) [000103] -c---------                  t103 = *  LEA(b+80) byref  REG NA
                                                            /--*  t103   byref  
N093 (  4,  4) [000105] n----O-----                  t105 = *  IND       long   REG rsi <l:$2c3, c:$2c4>
                                                            /--*  t105   long   
N095 (  8,  7) [000106] DA---O-----                         *  STORE_LCL_VAR long   V10 tmp7         d:3 rsi REG rsi

------------ BB13 [02E..041), preds={BB11,BB12} succs={BB14}
N099 (???,???) [000135] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-] REG NA
N101 (  3,  2) [000029] -----------                   t29 =    LCL_VAR   ref    V02 loc1         u:1 rdi (last use) REG rdi $20c
                                                            /--*  t29    ref    
N103 (  4,  3) [000109] -c---------                  t109 = *  LEA(b+8)  byref  REG NA
N105 (  3,  2) [000111] -----------                  t111 =    LCL_VAR   long   V10 tmp7         u:1 rsi (last use) REG rsi $380
                                                            /--*  t109   byref  
                                                            +--*  t111   long   
N107 (???,???) [000136] -A---O-----                         *  STOREIND  long   REG NA

------------ BB14 [048..049) (return), preds={BB01,BB02,BB09,BB13} succs={}
N047 (???,???) [000137] -----------                            IL_OFFSET void   INLRT @ 0x048[E-] REG NA
N049 (  0,  0) [000038] -----------                            RETURN    void   REG NA $VN.Void

------------ BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}

------------ BB12 [???..???) -> BB13 (always), preds={BB10} succs={BB13}
N111 (???,???) [000138] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-] REG NA
N113 (  1,  1) [000053] -----------                   t53 =    LCL_VAR   ref    V07 tmp4         u:1 rcx (last use) REG rcx <l:$205, c:$87>
                                                            /--*  t53    ref    
N115 (???,???) [000142] -----------                  t142 = *  PUTARG_REG ref    REG rcx
N117 (  1,  4) [000107] H----------                  t107 =    CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
                                                            /--*  t107   long   
N119 (???,???) [000143] -----------                  t143 = *  PUTARG_REG long   REG r11
                                                            /--*  t142   ref    this in rcx
                                                            +--*  t143   long   vsd cell in r11
N121 ( 22, 14) [000032] --CXG--N---                   t32 = *  CALLV stub long   System.IRuntimeMethodInfo.get_Value REG rax $300
                                                            /--*  t32    long   
N123 ( 26, 17) [000071] DA-XG------                         *  STORE_LCL_VAR long   V10 tmp7          rsi REG rsi

------------ BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}
N131 (???,???) [000139] -----------                            IL_OFFSET void   INLRT @ 0x026[E-] REG NA
N133 (  1,  1) [000042] ----------z                   t42 =    LCL_VAR   ref    V00 this         u:1 rcx (last use) REG rcx $80
                                                            /--*  t42    ref    
N135 (???,???) [000145] -----------                  t145 = *  PUTARG_REG ref    REG rcx
N137 (  1,  4) [000146] Hc---------                  t146 =    CNS_INT(h) long   0x4000000000426868 ftn REG NA
                                                            /--*  t146   long   
N139 (  3,  6) [000147] -c---------                  t147 = *  IND       long   REG NA
                                                            /--*  t145   ref    arg0 in rcx
                                                            +--*  t147   long   control expr
N141 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize REG NA $VN.Void

-------------------------------------------------------------------------------------------------------------------

Final allocation
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
  0.#0  V0   Parm   Alloc    rcx  |    |V0 a|    |    |    |    |    |    |    |    |
  1.#1  BB1  PredBB0              |    |V0 a|    |    |    |    |    |    |    |    |
  9.#2  V0   Use    Keep     rcx  |    |V0 i|    |    |    |    |    |    |    |    |
                    Spill    rcx  |    |V0 i|    |    |    |    |    |    |    |    |
 10.#3  I6   Def    Alloc    rax  |I6 a|    |    |    |    |    |    |    |    |    |
 11.#4  I6   Use *  Keep     rax  |I6 i|    |    |    |    |    |    |    |    |    |
 12.#5  V1   Def    Alloc    rax  |V1 a|    |    |    |    |    |    |    |    |    |
 19.#6  V1   Use    Keep     rax  |V1 a|    |    |    |    |    |    |    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
 23.#7  BB2  PredBB1              |V1 a|    |    |    |    |    |    |    |    |    |
 33.#8  V1   Use *  Keep     rax  |V1 i|    |    |    |    |    |    |    |    |    |
 34.#9  I7   Def    Alloc    rsi  |    |    |    |    |    |I7 a|    |    |    |    |
 35.#10 I7   Use *  Keep     rsi  |    |    |    |    |    |I7 i|    |    |    |    |
 36.#11 V12  Def    Alloc    rsi  |    |    |    |    |    |V12a|    |    |    |    |
 41.#12 V12  Use    Keep     rsi  |    |    |    |    |    |V12a|    |    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
 45.#13 BB14 PredBB1              |    |    |    |    |    |    |    |    |    |    |
 51.#14 V12  DDef                 |    |    |    |    |    |    |    |    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
 51.#15 BB17 PredBB1              |    |    |    |    |    |V12a|    |    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
 53.#16 BB8  PredBB17             |    |    |    |    |    |V12a|    |    |    |    |
 62.#17 rax  Kill   Keep     rax  |    |    |    |    |    |V12a|    |    |    |    |
 62.#18 rcx  Kill   Keep     rcx  |    |    |    |    |    |V12a|    |    |    |    |
 62.#19 rdx  Kill   Keep     rdx  |    |    |    |    |    |V12a|    |    |    |    |
 62.#20 r8   Kill   Keep     r8   |    |    |    |    |    |V12a|    |    |    |    |
 62.#21 r9   Kill   Keep     r9   |    |    |    |    |    |V12a|    |    |    |    |
 62.#22 r10  Kill   Keep     r10  |    |    |    |    |    |V12a|    |    |    |    |
 62.#23 r11  Kill   Keep     r11  |    |    |    |    |    |V12a|    |    |    |    |
 62.#24 rax  Fixd   Keep     rax  |    |    |    |    |    |V12a|    |    |    |    |
 62.#25 I8   Def    Alloc    rax  |I8 a|    |    |    |    |V12a|    |    |    |    |
 63.#26 I8   Use *  Keep     rax  |I8 i|    |    |    |    |V12a|    |    |    |    |
 64.#27 V2   Def    Alloc    rdi  |    |    |    |    |    |V12a|V2 a|    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
 65.#28 BB10 PredBB8              |    |    |    |    |    |V12a|V2 a|    |    |    |
 71.#29 V12  Use *  Keep     rsi  |    |    |    |    |    |V12i|V2 a|    |    |    |
 72.#30 V7   Def    Alloc    rcx  |    |V7 a|    |    |    |    |V2 a|    |    |    |
 78.#31 I9   Def    Alloc    r11  |    |V7 a|    |    |    |    |V2 a|    |    |I9 a|
 83.#32 I9   Use *  Keep     r11  |    |V7 a|    |    |    |    |V2 a|    |    |I9 i|
 83.#33 V7   Use    Keep     rcx  |    |V7 a|    |    |    |    |V2 a|    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
 87.#34 BB11 PredBB10             |    |V7 a|    |    |    |    |V2 a|    |    |    |
 93.#35 V7   Use *  Keep     rcx  |    |V7 i|    |    |    |    |V2 a|    |    |    |
 94.#36 I10  Def    Alloc    rsi  |    |    |    |    |    |I10a|V2 a|    |    |    |
 95.#37 I10  Use *  Keep     rsi  |    |    |    |    |    |I10i|V2 a|    |    |    |
 96.#38 V10  Def    Alloc    rsi  |    |    |    |    |    |V10a|V2 a|    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
 97.#39 BB13 PredBB11             |    |    |    |    |    |V10a|V2 a|    |    |    |
107.#40 V2   Use *  Keep     rdi  |    |    |    |    |    |V10a|V2 i|    |    |    |
107.#41 V10  Use *  Keep     rsi  |    |    |    |    |    |V10i|    |    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
109.#42 BB12 PredBB10             |    |V7 a|    |    |    |    |V2 a|    |    |    |
115.#43 rcx  Fixd   Keep     rcx  |    |V7 a|    |    |    |    |V2 a|    |    |    |
115.#44 V7   Use *  Keep     rcx  |    |V7 i|    |    |    |    |V2 a|    |    |    |
116.#45 rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |V2 a|    |    |    |
116.#46 I11  Def    Alloc    rcx  |    |I11a|    |    |    |    |V2 a|    |    |    |
118.#47 r11  Fixd   Keep     r11  |    |I11a|    |    |    |    |V2 a|    |    |    |
118.#48 C12  Def    Alloc    r11  |    |I11a|    |    |    |    |V2 a|    |    |C12a|
119.#49 r11  Fixd   Keep     r11  |    |I11a|    |    |    |    |V2 a|    |    |C12a|
119.#50 C12  Use *  Keep     r11  |    |I11a|    |    |    |    |V2 a|    |    |C12i|
120.#51 r11  Fixd   Keep     r11  |    |I11a|    |    |    |    |V2 a|    |    |    |
120.#52 I13  Def    Alloc    r11  |    |I11a|    |    |    |    |V2 a|    |    |I13a|
121.#53 rcx  Fixd   Keep     rcx  |    |I11a|    |    |    |    |V2 a|    |    |I13a|
121.#54 I11  Use *  Keep     rcx  |    |I11i|    |    |    |    |V2 a|    |    |I13a|
121.#55 r11  Fixd   Keep     r11  |    |    |    |    |    |    |V2 a|    |    |I13a|
121.#56 I13  Use *  Keep     r11  |    |    |    |    |    |    |V2 a|    |    |I13i|
122.#57 rax  Kill   Keep     rax  |    |    |    |    |    |    |V2 a|    |    |    |
122.#58 rcx  Kill   Keep     rcx  |    |    |    |    |    |    |V2 a|    |    |    |
122.#59 rdx  Kill   Keep     rdx  |    |    |    |    |    |    |V2 a|    |    |    |
122.#60 r8   Kill   Keep     r8   |    |    |    |    |    |    |V2 a|    |    |    |
122.#61 r9   Kill   Keep     r9   |    |    |    |    |    |    |V2 a|    |    |    |
122.#62 r10  Kill   Keep     r10  |    |    |    |    |    |    |V2 a|    |    |    |
122.#63 r11  Kill   Keep     r11  |    |    |    |    |    |    |V2 a|    |    |    |
122.#64 rax  Fixd   Keep     rax  |    |    |    |    |    |    |V2 a|    |    |    |
122.#65 I14  Def    Alloc    rax  |I14a|    |    |    |    |    |V2 a|    |    |    |
123.#66 I14  Use *  Keep     rax  |I14i|    |    |    |    |    |V2 a|    |    |    |
124.#67 V10  Def    Alloc    rsi  |    |    |    |    |    |V10a|V2 a|    |    |    |
125.#68 V10  ExpU                 |    |    |    |    |    |V10a|V2 a|    |    |    |
125.#69 V2   ExpU                 |    |    |    |    |    |V10a|V2 a|    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
125.#70 BB5  PredBB0              |    |    |    |    |    |    |    |    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
127.#71 BB9  PredBB0              |    |    |    |    |    |    |    |    |    |    |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
Loc RP# Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |r11 |
----------------------------------+----+----+----+----+----+----+----+----+----+----+
129.#72 BB15 PredBB0              |    |    |    |    |    |    |    |    |    |    |
135.#73 rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |    |
135.#74 V0   Use *  ReLod    rcx  |    |V0 a|    |    |    |    |    |    |    |    |
                    Keep     rcx  |    |V0 i|    |    |    |    |    |    |    |    |
136.#75 rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |    |
136.#76 I15  Def    Alloc    rcx  |    |I15a|    |    |    |    |    |    |    |    |
141.#77 rcx  Fixd   Keep     rcx  |    |I15a|    |    |    |    |    |    |    |    |
141.#78 I15  Use *  Keep     rcx  |    |I15i|    |    |    |    |    |    |    |    |
142.#79 rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |    |
142.#80 rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |    |
142.#81 rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |    |
142.#82 r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |    |
142.#83 r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |    |
142.#84 r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |    |
142.#85 r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |    |

Recording the maximum number of concurrent spills:

----------
LSRA Stats
----------
Register selection order: ABCDEFGHIJKLMNOPQ
Total Tracked Vars:  8
Total Reg Cand Vars: 6
Total number of Intervals: 15
Total number of RefPositions: 86
Total Number of spill temps created: 0
..........
BB01 [   85.00]: SpillCount = 1, COVERS = 1, REG_ORDER = 1
BB02 [   85.00]: COVERS = 1, REG_ORDER = 1
BB08 [   85.00]: REG_ORDER = 1
BB10 [   85.00]: CALLER_CALLEE = 1, BEST_FIT = 1
BB11 [   85.00]: COVERS = 1, REG_ORDER = 1
..........
Total SpillCount : 1   Weighted: 85.000000
Total CopyReg : 0   Weighted: 0.000000
Total ResolutionMovs : 0   Weighted: 0.000000
Total SplitEdges : 0   Weighted: 0.000000
..........
Total COVERS [# 4] : 3   Weighted: 255.000000
Total CALLER_CALLEE [# 8] : 1   Weighted: 85.000000
Total BEST_FIT [#11] : 1   Weighted: 85.000000
Total REG_ORDER [#13] : 4   Weighted: 340.000000

TUPLE STYLE DUMP WITH REGISTER ASSIGNMENTS
Incoming Parameters:  V00(rcx)
BB01 [000..010) -> BB14 (cond), preds={} succs={BB02,BB14}
=====
  N003.                    IL_OFFSET INLRT @ 0x000[E-]
S N005.                    V00(rcx)
  N007. STK             =  LEA(b+24); rcx
  N009. rax             =  IND      ; STK
* N011.                    V01(rax); rax
  N013.                    IL_OFFSET INL01 @ 0x003[E-] <- INLRT @ 0x007[E-]
  N015.                    V01(rax)
  N017.                    CNS_INT   null
  N019.                    EQ       ; rax
  N021.                    JTRUE    
Var=Reg end of BB01: V01=rax 

BB02 [007..01A) -> BB14 (cond), preds={BB01} succs={BB17,BB14}
=====
Predecessor for variable locations: BB01
Var=Reg beg of BB02: V01=rax 
  N025.                    IL_OFFSET INL01 @ 0x006[E-] <- INLRT @ 0x007[E-]
  N027.                    IL_OFFSET INLRT @ 0x012[E-]
  N029.                    V01(rax*)
  N031. STK             =  LEA(b+16); rax*
  N033. rsi             =  IND      ; STK
* N035.                    V12(rsi); rsi
  N037.                    V12(rsi)
  N039.                    CNS_INT   null
  N041.                    EQ       ; rsi
  N043.                    JTRUE    
Var=Reg end of BB02: V12=rsi 

BB14 [048..049) (return), preds={BB01,BB02,BB09,BB13} succs={}
=====
Predecessor for variable locations: BB01
Var=Reg beg of BB14: none
  N047.                    IL_OFFSET INLRT @ 0x048[E-]
  N049.                    RETURN   
Var=Reg end of BB14: none

BB17 [???..???) -> BB08 (always), preds={BB02} succs={BB08}
=====
Predecessor for variable locations: BB01
Var=Reg beg of BB17: V12=rsi 
Var=Reg end of BB17: V12=rsi 

BB08 [01C..025), preds={BB17} succs={BB10}
=====
Predecessor for variable locations: BB17
Var=Reg beg of BB08: V12=rsi 
  N055.                    IL_OFFSET INLRT @ 0x022[--]
  N057.                    CNS_INT(h) 0x4000000000426c78 ftn
  N059.                    IND      
  N061. rax             =  CALL help r2r_ind
* N063.                    V02(rdi); rax
Var=Reg end of BB08: V12=rsi V02=rdi 

BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12}
=====
Predecessor for variable locations: BB08
Var=Reg beg of BB10: V12=rsi V02=rdi 
  N067.                    IL_OFFSET INLRT @ 0x02E[E-]
  N069.                    V12(rsi*)
* N071.                    V07(rcx); rsi*
  N073.                    IL_OFFSET INLRT @ 0x02E[E-]
  N075.                    CNS_INT(h) 0x40000000004258b8 class
  N077. r11             =  IND      
  N079.                    V07(rcx)
  N081. STK             =  IND      ; rcx
  N083.                    NE       ; r11,STK
  N085.                    JTRUE    
Var=Reg end of BB10: V07=rcx V02=rdi 

BB11 [???..???), preds={BB10} succs={BB13}
=====
Predecessor for variable locations: BB10
Var=Reg beg of BB11: V07=rcx V02=rdi 
  N089.                    V07(rcx*)
  N091. STK             =  LEA(b+80); rcx*
  N093. rsi             =  IND      ; STK
* N095.                    V10(rsi); rsi
Var=Reg end of BB11: V10=rsi V02=rdi 

BB13 [02E..041), preds={BB11,BB12} succs={BB14}
=====
Predecessor for variable locations: BB11
Var=Reg beg of BB13: V10=rsi V02=rdi 
  N099.                    IL_OFFSET INLRT @ 0x02E[E-]
  N101.                    V02(rdi*)
  N103. STK             =  LEA(b+8) ; rdi*
  N105.                    V10(rsi*)
  N107.                    STOREIND ; STK,rsi*
Var=Reg end of BB13: none

BB12 [???..???) -> BB13 (always), preds={BB10} succs={BB13}
=====
Predecessor for variable locations: BB10
Var=Reg beg of BB12: V07=rcx V02=rdi 
  N111.                    IL_OFFSET INLRT @ 0x02E[E-]
  N113.                    V07(rcx*)
  N115. rcx             =  PUTARG_REG; rcx*
  N117. r11             =  CNS_INT(h) 0x4000000000424a90 ftn
  N119. r11             =  PUTARG_REG; r11
  N121. rax             =  CALLV stub; rcx,r11
* N123.                    V10(rsi); rax
Var=Reg end of BB12: V10=rsi V02=rdi 

BB05 [???..???) (throw), preds={} succs={}
=====
Predecessor for variable locations: BB00
Var=Reg beg of BB05: none
Var=Reg end of BB05: none

BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14}
=====
Predecessor for variable locations: BB00
Var=Reg beg of BB09: none
Var=Reg end of BB09: none

BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09}
=====
Predecessor for variable locations: BB00
Var=Reg beg of BB15: none
  N131.                    IL_OFFSET INLRT @ 0x026[E-]
  N133.                    V00(rcx*)R
  N135. rcx             =  PUTARG_REG; rcx*
  N137.                    CNS_INT(h) 0x4000000000426868 ftn
  N139.                    IND      
  N141.                    CALL r2r_ind; rcx
Var=Reg end of BB15: none




*************** Finishing PHASE Linear scan register alloc

*************** Starting PHASE Place 'align' instructions

*************** Finishing PHASE Place 'align' instructions
*************** In genGenerateCode()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB14 ( cond )                     keep i IBC LIR 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC LIR 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal LIR 
BB05 [0031]  0                             0      0    [???..???)        (throw )                     keep i rare IBC LIR 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try hascall newobj IBC LIR 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i IBC LIR 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC LIR 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal IBC LIR 
BB14 [0017]  4       BB01,BB02,BB09,BB13   1     85    [048..049)        (return)                     i IBC LIR 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare gcsafe LIR 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare hascall gcsafe IBC LIR 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare hascall gcsafe flet LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Generate code
*************** In fgDebugCheckBBlist
Finalizing stack frame
Recording Var Locations at start of BB01
  V00(rcx)
Modified regs: [rax rcx rdx rsi rdi r8-r11]
Callee-saved registers pushed: 2 [rsi rdi]
*************** In lvaAssignFrameOffsets(FINAL_FRAME_LAYOUT)
Assign V11 PSPSym, size=8, stkOffs=-0x28
Assign V03 OutArgs, size=32, stkOffs=-0x48
--- delta bump 8 for RA
--- delta bump 8 for FP
--- delta bump 0 for FP frame
--- virtual stack offset to actual stack offset delta is 16
-- V00 was 0, now 16
-- V03 was -72, now -56
-- V11 was -48, now -32
; Final local variable assignments
;
;  V00 this         [V00,T01] (  4,  3   )     ref  ->  [rbp+10H]   this class-hnd EH-live single-def
;  V01 loc0         [V01,T02] (  3,  3   )     ref  ->  rax         class-hnd single-def
;  V02 loc1         [V02,T05] (  2,  2   )     ref  ->  rdi         class-hnd exact single-def
;  V03 OutArgs      [V03    ] (  1,  1   )  lclBlk (32) [rsp+00H]   "OutgoingArgSpace"
;* V04 tmp1         [V04    ] (  0,  0   )     ref  ->  zero-ref    class-hnd exact "NewObj constructor temp"
;* V05 tmp2         [V05    ] (  0,  0   )     ref  ->  zero-ref    class-hnd single-def "impSpillSpecialSideEff"
;* V06 tmp3         [V06    ] (  0,  0   )  struct ( 8) zero-ref    "guarded devirt return temp"
;  V07 tmp4         [V07,T00] (  4,  6   )     ref  ->  rcx         single-def "guarded devirt this temp"
;* V08 tmp5         [V08    ] (  0,  0   )     ref  ->  zero-ref    class-hnd exact "guarded devirt this exact temp"
;* V09 tmp6         [V09,T06] (  0,  0   )    bool  ->  zero-ref    "Inline return value spill temp"
;  V10 tmp7         [V10,T04] (  3,  2   )    long  ->  rsi         V06.m_handle(offs=0x00) P-INDEP "field V06.m_handle (fldOffset=0x0)"
;  V11 PSPSym       [V11,T07] (  1,  1   )    long  ->  [rbp-20H]   do-not-enreg[V] "PSPSym"
;  V12 cse0         [V12,T03] (  3,  3   )     ref  ->  rsi         "CSE - aggressive"
;
; Lcl frame size = 48
Mark labels for codegen
  BB01 : first block
  BB14 : branch target
  BB14 : branch target
  BB08 : branch target
  BB12 : branch target
  BB14 : branch target
  BB13 : branch target
  BB09 : branch target
  BB08 : try begin
  BB15 : hnd begin
  BB10 : try end
*************** After genMarkLabelsForCodegen()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight   IBC  lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1     85    [000..010)-> BB14 ( cond )                     keep i label IBC LIR 
BB02 [0024]  1       BB01                  1     85    [007..01A)-> BB14 ( cond )                     i IBC LIR 
BB17 [0038]  1       BB02                  1           [???..???)-> BB08 (always)                     internal LIR 
BB05 [0031]  0                             0      0    [???..???)        (throw )                     keep i rare IBC LIR 
BB08 [0005]  1  0    BB17                  1     85    [01C..025)                 T0      try { }     keep i try label hascall newobj IBC LIR 
BB10 [0007]  1       BB08                  1     85    [02E..02E)-> BB12 ( cond )                     i label IBC LIR 
BB11 [0020]  1       BB10                  1     85    [???..???)                                     i internal IBC LIR 
BB13 [0019]  2       BB11,BB12             1     85    [02E..041)                                     i internal label IBC LIR 
BB14 [0017]  4       BB01,BB02,BB09,BB13   1     85    [048..049)        (return)                     i label IBC LIR 
BB09 [0012]  1       BB15                  0           [???..???)-> BB14 (always)                     i internal rare label gcsafe LIR 
BB12 [0021]  1       BB10                  0      0    [???..???)-> BB13 (always)                     i internal rare label hascall gcsafe IBC LIR 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ funclets follow
BB15 [0006]  1     0                       0           [025..02E)-> BB09 ( cret )    H0 F catch { }   keep i rare label hascall gcsafe flet LIR 
-----------------------------------------------------------------------------------------------------------------------------------------
Setting stack level from -572662307 to 0

=============== Generating BB01 [000..010) -> BB14 (cond), preds={} succs={BB02,BB14} flags=0x00000000.30010030: keep i label IBC LIR 
BB01 IN (1)={V00    } + ByrefExposed + GcHeap
     OUT(2)={V00 V01} + ByrefExposed + GcHeap

Recording Var Locations at start of BB01
  V00(rcx)
Change life 0000000000000000 {} -> 0000000000000002 {V00}
							V00 in reg rcx is becoming live  [------]
							Live regs: 00000000 {} => 00000002 {rcx}
New debug range: first
							Live regs: (unchanged) 00000002 {rcx}
							Added GCVars: {V00}
							GC regs: (unchanged) 00000002 {rcx}
							Byref regs: (unchanged) 00000000 {}

      L_M11341_BB01:
Mapped BB01 to G_M11341_IG02
Label: IG02, GCvars=0000000000000002 {V00}, gcrefRegs=00000002 {rcx}, byrefRegs=00000000 {}

Scope info: begin block BB01, IL range [000..010)
Added IP mapping: 0x0000 STACK_EMPTY (G_M11341_IG02,ins#0,ofs#0) label
Generating: N003 (???,???) [000127] -----------                            IL_OFFSET void   INLRT @ 0x000[E-] REG NA
Generating: N005 (  1,  1) [000000] ----------Z                    t0 =    LCL_VAR   ref    V00 this         u:1 rcx REG rcx $80
                                                                        /--*  t0     ref    
Generating: N007 (  2,  2) [000097] -c---------                   t97 = *  LEA(b+24) byref  REG NA
                                                                        /--*  t97    byref  
Generating: N009 (  4,  4) [000001] ---XG------                    t1 = *  IND       ref    REG rax <l:$202, c:$203>
							V00 in reg rcx is becoming dead  [000000]
							Live regs: 00000002 {rcx} => 00000000 {}
							GC regs: 00000002 {rcx} => 00000000 {}
							Var V00 continuing live
New debug range: not adjacent
IN0001:        mov      rax, gword ptr [rcx+24]
							GC regs: 00000000 {} => 00000001 {rax}
                                                                        /--*  t1     ref    
Generating: N011 (  4,  4) [000003] DA-XG------                         *  STORE_LCL_VAR ref    V01 loc0         d:1 rax REG rax
							GC regs: 00000001 {rax} => 00000000 {}
							V01 in reg rax is becoming live  [000003]
							Live regs: 00000000 {} => 00000001 {rax}
							Live vars: {V00} => {V00 V01}
New debug range: first
							GC regs: 00000000 {} => 00000001 {rax}
Added IP mapping: 0x0007 STACK_EMPTY (G_M11341_IG02,ins#1,ofs#4)
Generating: N013 (???,???) [000128] -----------                            IL_OFFSET void   INL01 @ 0x003[E-] <- INLRT @ 0x007[E-] REG NA
Generating: N015 (  1,  1) [000004] -----------                    t4 =    LCL_VAR   ref    V01 loc0         u:1 rax REG rax <l:$200, c:$81>
Generating: N017 (  1,  1) [000076] -c---------                   t76 =    CNS_INT   ref    null REG NA $VN.Null
                                                                        /--*  t4     ref    
                                                                        +--*  t76    ref    
Generating: N019 (  3,  3) [000077] J------N---                         *  EQ        void   REG NA <l:$241, c:$240>
IN0002:        test     rax, rax
Generating: N021 (  5,  5) [000078] -----------                         *  JTRUE     void   REG NA $VN.Void
IN0003:        je       L_M11341_BB14

Variable Live Range History Dump for BB01
V00 this: rcx [(G_M11341_IG02,ins#0,ofs#0), (G_M11341_IG02,ins#0,ofs#0)]; rbp[16] (1 slot) [(G_M11341_IG02,ins#0,ofs#0), ...]
V01 loc0: rax [(G_M11341_IG02,ins#1,ofs#4), ...]

=============== Generating BB02 [007..01A) -> BB14 (cond), preds={BB01} succs={BB17,BB14} flags=0x00000000.30000020: i IBC LIR 
BB02 IN (2)={V00 V01    } + ByrefExposed + GcHeap
     OUT(2)={V00     V12} + ByrefExposed + GcHeap

Recording Var Locations at start of BB02
  V01(rax)
Liveness not changing: 0000000000000006 {V00 V01}
							Live regs: 00000000 {} => 00000001 {rax}
							GC regs: 00000000 {} => 00000001 {rax}
							Byref regs: (unchanged) 00000000 {}

      L_M11341_BB02:

Scope info: begin block BB02, IL range [007..01A)
genIPmappingAdd: ignoring duplicate IL offset 0x7
Generating: N025 (???,???) [000129] -----------                            IL_OFFSET void   INL01 @ 0x006[E-] <- INLRT @ 0x007[E-] REG NA
Added IP mapping: 0x0012 STACK_EMPTY (G_M11341_IG02,ins#3,ofs#13)
Generating: N027 (???,???) [000130] -----------                            IL_OFFSET void   INLRT @ 0x012[E-] REG NA
Generating: N029 (  1,  1) [000012] -----------                   t12 =    LCL_VAR   ref    V01 loc0         u:1 rax (last use) REG rax <l:$200, c:$81>
                                                                        /--*  t12    ref    
Generating: N031 (  2,  2) [000099] -c---------                   t99 = *  LEA(b+16) byref  REG NA
                                                                        /--*  t99    byref  
Generating: N033 (  4,  4) [000013] n---GO-----                   t13 = *  IND       ref    REG rsi <l:$208, c:$209>
							V01 in reg rax is becoming dead  [000012]
							Live regs: 00000001 {rax} => 00000000 {}
							Live vars: {V00 V01} => {V00}
							GC regs: 00000001 {rax} => 00000000 {}
IN0004:        mov      rsi, gword ptr [rax+16]
							GC regs: 00000000 {} => 00000040 {rsi}
                                                                        /--*  t13    ref    
Generating: N035 (  4,  4) [000123] DA--GO-----                         *  STORE_LCL_VAR ref    V12 cse0         d:1 rsi REG rsi
							GC regs: 00000040 {rsi} => 00000000 {}
							V12 in reg rsi is becoming live  [000123]
							Live regs: 00000000 {} => 00000040 {rsi}
							Live vars: {V00} => {V00 V12}
							GC regs: 00000000 {} => 00000040 {rsi}
Generating: N037 (  1,  1) [000124] -----------                  t124 =    LCL_VAR   ref    V12 cse0         u:1 rsi REG rsi <l:$208, c:$209>
Generating: N039 (  1,  1) [000014] -c---------                   t14 =    CNS_INT   ref    null REG NA $VN.Null
                                                                        /--*  t124   ref    
                                                                        +--*  t14    ref    
Generating: N041 (  7,  7) [000015] J---GO-N---                         *  EQ        void   REG NA
IN0005:        test     rsi, rsi
Generating: N043 (  9,  9) [000016] ----GO-----                         *  JTRUE     void   REG NA <l:$20b, c:$20a>
IN0006:        je       L_M11341_BB14

Variable Live Range History Dump for BB02
V00 this: rbp[16] (1 slot) [(G_M11341_IG02,ins#0,ofs#0), ...]
V01 loc0: rax [(G_M11341_IG02,ins#1,ofs#4), (G_M11341_IG02,ins#3,ofs#13)]

=============== Generating BB17 [???..???) -> BB08 (always), preds={BB02} succs={BB08} flags=0x00000000.20000040: internal LIR 
BB17 IN (2)={V00 V12} + ByrefExposed + GcHeap
     OUT(2)={V00 V12} + ByrefExposed + GcHeap

Recording Var Locations at start of BB17
  V12(rsi)
Liveness not changing: 000000000000000A {V00 V12}
							Live regs: 00000000 {} => 00000040 {rsi}
							GC regs: 00000000 {} => 00000040 {rsi}
							Byref regs: (unchanged) 00000000 {}

      L_M11341_BB17:

Scope info: begin block BB17, IL range [???..???)
Scope info: ignoring block beginning
Added IP mapping: NO_MAP (G_M11341_IG02,ins#6,ofs#26) label
Scope info: ignoring block end
IN0007:        jmp      L_M11341_BB08

Variable Live Range History Dump for BB17
V00 this: rbp[16] (1 slot) [(G_M11341_IG02,ins#0,ofs#0), ...]

=============== Generating BB05 [???..???) (throw), preds={} succs={} flags=0x00000000.30001030: keep i rare IBC LIR 
BB05 IN (0)={}
     OUT(0)={}

Recording Var Locations at start of BB05
  <none>

Change life 000000000000000A {V00 V12} -> 0000000000000000 {}
							V00 becoming dead
							V12 in reg rsi is becoming dead  [------]
							Live regs: (unchanged) 00000000 {}
							Live regs: (unchanged) 00000000 {}
							GC regs: (unchanged) 00000000 {}
							Byref regs: (unchanged) 00000000 {}

      L_M11341_BB05:

Scope info: begin block BB05, IL range [???..???)
Scope info: ignoring block beginning
Scope info: ignoring block end
IN0008:        int3     

Variable Live Range History Dump for BB05
V00 this: rbp[16] (1 slot) [(G_M11341_IG02,ins#0,ofs#0), (G_M11341_IG02,ins#7,ofs#31)]

=============== Generating BB08 [01C..025), preds={BB17} succs={BB10} flags=0x00000002.30410130: keep i try label hascall newobj IBC LIR 
BB08 IN (2)={V00 V12    } + ByrefExposed + GcHeap
     OUT(3)={V00 V12 V02} + ByrefExposed + GcHeap

Recording Var Locations at start of BB08
  V12(rsi)
Change life 0000000000000000 {} -> 000000000000000A {V00 V12}
							V00 becoming live
Extending debug range...
							V12 in reg rsi is becoming live  [------]
							Live regs: 00000000 {} => 00000040 {rsi}
							Live regs: (unchanged) 00000040 {rsi}
							GC regs: (unchanged) 00000040 {rsi}
							Byref regs: (unchanged) 00000000 {}

      L_M11341_BB08:

      G_M11341_IG02:        ; offs=000000H, funclet=00, bbWeight=1   , gcvars, byref
Mapped BB08 to G_M11341_IG03
Label: IG03, GCvars=0000000000000002 {V00}, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}

Scope info: begin block BB08, IL range [01C..025)
Added IP mapping: 0x0022 (G_M11341_IG03,ins#0,ofs#0) label
Generating: N055 (???,???) [000132] -----------                            IL_OFFSET void   INLRT @ 0x022[--] REG NA
Generating: N057 (  1,  4) [000140] Hc---------                  t140 =    CNS_INT(h) long   0x4000000000426c78 ftn REG NA
                                                                        /--*  t140   long   
Generating: N059 (  3,  6) [000141] -c---------                  t141 = *  IND       long   REG NA
                                                                        /--*  t141   long   control expr
Generating: N061 ( 14,  5) [000021] --C--------                   t21 = *  CALL help r2r_ind ref    HELPER.CORINFO_HELP_READYTORUN_NEW REG rax $20c
							Call: GCvars=0000000000000002 {V00}, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}
IN0009:        call     [CORINFO_HELP_READYTORUN_NEW]
							GC regs: 00000040 {rsi} => 00000041 {rax rsi}
                                                                        /--*  t21    ref    
Generating: N063 ( 18,  8) [000028] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         d:1 rdi REG rdi
							GC regs: 00000041 {rax rsi} => 00000040 {rsi}
IN000a:        mov      rdi, rax
							V02 in reg rdi is becoming live  [000028]
							Live regs: 00000040 {rsi} => 000000C0 {rsi rdi}
							Live vars: {V00 V12} => {V00 V02 V12}
New debug range: first
							GC regs: 00000040 {rsi} => 000000C0 {rsi rdi}

Variable Live Range History Dump for BB08
V00 this: rbp[16] (1 slot) [(G_M11341_IG02,ins#0,ofs#0), ...]
V02 loc1: rdi [(G_M11341_IG03,ins#2,ofs#9), ...]

=============== Generating BB10 [02E..02E) -> BB12 (cond), preds={BB08} succs={BB11,BB12} flags=0x00000000.30010020: i label IBC LIR 
BB10 IN (2)={    V12 V02} + ByrefExposed + GcHeap
     OUT(2)={V07     V02} + ByrefExposed + GcHeap

Recording Var Locations at start of BB10
  V12(rsi)  V02(rdi)
Change life 000000000000002A {V00 V02 V12} -> 0000000000000028 {V02 V12}
							V00 becoming dead
							Live regs: 00000000 {} => 000000C0 {rsi rdi}
							GC regs: 00000000 {} => 000000C0 {rsi rdi}
							Byref regs: (unchanged) 00000000 {}

      L_M11341_BB10:

      G_M11341_IG03:        ; offs=000020H, funclet=00, bbWeight=1   , byref
Mapped BB10 to G_M11341_IG04
Label: IG04, GCvars=0000000000000000 {}, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}

Scope info: begin block BB10, IL range [02E..02E)
Added IP mapping: 0x002E STACK_EMPTY (G_M11341_IG04,ins#0,ofs#0) label
Generating: N067 (???,???) [000133] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-] REG NA
Generating: N069 (  1,  1) [000126] -----------                  t126 =    LCL_VAR   ref    V12 cse0         u:1 rsi (last use) REG rsi <l:$205, c:$83>
                                                                        /--*  t126   ref    
Generating: N071 (  1,  3) [000051] DA--G------                         *  STORE_LCL_VAR ref    V07 tmp4         d:1 rcx REG rcx
							V12 in reg rsi is becoming dead  [000126]
							Live regs: 000000C0 {rsi rdi} => 00000080 {rdi}
							Live vars: {V02 V12} => {V02}
							GC regs: 000000C0 {rsi rdi} => 00000080 {rdi}
IN000b:        mov      rcx, rsi
							V07 in reg rcx is becoming live  [000051]
							Live regs: 00000080 {rdi} => 00000082 {rcx rdi}
							Live vars: {V02} => {V02 V07}
							GC regs: 00000080 {rdi} => 00000082 {rcx rdi}
genIPmappingAdd: ignoring duplicate IL offset 0x2e
Generating: N073 (???,???) [000134] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-] REG NA
Generating: N075 (  1,  4) [000055] Hc---------                   t55 =    CNS_INT(h) long   0x40000000004258b8 class REG NA $183
                                                                        /--*  t55    long   
Generating: N077 (  3,  6) [000056] #----------                   t56 = *  IND       long   REG r11 $280
IN000c:        mov      r11, qword ptr [(reloc 0x40000000004258b8)]
Generating: N079 (  1,  1) [000052] -----------                   t52 =    LCL_VAR   ref    V07 tmp4         u:1 rcx REG rcx <l:$205, c:$87>
                                                                        /--*  t52    ref    
Generating: N081 (  3,  2) [000054] #c-X-------                   t54 = *  IND       long   REG NA <l:$2c0, c:$2c1>
                                                                        /--*  t56    long   
                                                                        +--*  t54    long   
Generating: N083 (  7,  9) [000057] J--X---N---                         *  NE        void   REG NA <l:$249, c:$248>
IN000d:        cmp      r11, qword ptr [rcx]
Generating: N085 (  9, 11) [000058] ---X-------                         *  JTRUE     void   REG NA <l:$211, c:$210>
IN000e:        jne      L_M11341_BB12

Variable Live Range History Dump for BB10
V00 this: rbp[16] (1 slot) [(G_M11341_IG02,ins#0,ofs#0), (G_M11341_IG03,ins#2,ofs#9)]
V02 loc1: rdi [(G_M11341_IG03,ins#2,ofs#9), ...]

=============== Generating BB11 [???..???), preds={BB10} succs={BB13} flags=0x00000000.30000060: i internal IBC LIR 
BB11 IN (2)={V07     V02} + ByrefExposed + GcHeap
     OUT(2)={    V10 V02}

Recording Var Locations at start of BB11
  V07(rcx)  V02(rdi)
Liveness not changing: 0000000000000021 {V02 V07}
							Live regs: 00000000 {} => 00000082 {rcx rdi}
							GC regs: 00000000 {} => 00000082 {rcx rdi}
							Byref regs: (unchanged) 00000000 {}

      L_M11341_BB11:

Scope info: begin block BB11, IL range [???..???)
Scope info: ignoring block beginning
Added IP mapping: NO_MAP (G_M11341_IG04,ins#4,ofs#19) label
Generating: N089 (  1,  1) [000059] -----------                   t59 =    LCL_VAR   ref    V07 tmp4         u:1 rcx (last use) REG rcx <l:$205, c:$87>
                                                                        /--*  t59    ref    
Generating: N091 (  2,  2) [000103] -c---------                  t103 = *  LEA(b+80) byref  REG NA
                                                                        /--*  t103   byref  
Generating: N093 (  4,  4) [000105] n----O-----                  t105 = *  IND       long   REG rsi <l:$2c3, c:$2c4>
							V07 in reg rcx is becoming dead  [000059]
							Live regs: 00000082 {rcx rdi} => 00000080 {rdi}
							Live vars: {V02 V07} => {V02}
							GC regs: 00000082 {rcx rdi} => 00000080 {rdi}
IN000f:        mov      rsi, qword ptr [rcx+80]
                                                                        /--*  t105   long   
Generating: N095 (  8,  7) [000106] DA---O-----                         *  STORE_LCL_VAR long   V10 tmp7         d:3 rsi REG rsi
							V10 in reg rsi is becoming live  [000106]
							Live regs: 00000080 {rdi} => 000000C0 {rsi rdi}
							Live vars: {V02} => {V02 V10}
Scope info: ignoring block end

Variable Live Range History Dump for BB11
V02 loc1: rdi [(G_M11341_IG03,ins#2,ofs#9), ...]

=============== Generating BB13 [02E..041), preds={BB11,BB12} succs={BB14} flags=0x00000000.30010060: i internal label IBC LIR 
BB13 IN (2)={V10 V02}
     OUT(0)={       }

Recording Var Locations at start of BB13
  V10(rsi)  V02(rdi)
Liveness not changing: 0000000000000030 {V02 V10}
							Live regs: 00000000 {} => 000000C0 {rsi rdi}
							GC regs: 00000000 {} => 00000080 {rdi}
							Byref regs: (unchanged) 00000000 {}

      L_M11341_BB13:

      G_M11341_IG04:        ; offs=000029H, funclet=00, bbWeight=1   , gcvars, byref
Mapped BB13 to G_M11341_IG05
Label: IG05, GCvars=0000000000000000 {}, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}

Scope info: begin block BB13, IL range [02E..041)
genIPmappingAdd: ignoring duplicate IL offset 0xffffffff
Added IP mapping: 0x002E STACK_EMPTY (G_M11341_IG05,ins#0,ofs#0) label
Generating: N099 (???,???) [000135] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-] REG NA
Generating: N101 (  3,  2) [000029] -----------                   t29 =    LCL_VAR   ref    V02 loc1         u:1 rdi (last use) REG rdi $20c
                                                                        /--*  t29    ref    
Generating: N103 (  4,  3) [000109] -c---------                  t109 = *  LEA(b+8)  byref  REG NA
Generating: N105 (  3,  2) [000111] -----------                  t111 =    LCL_VAR   long   V10 tmp7         u:1 rsi (last use) REG rsi $380
                                                                        /--*  t109   byref  
                                                                        +--*  t111   long   
Generating: N107 (???,???) [000136] -A---O-----                         *  STOREIND  long   REG NA
							V02 in reg rdi is becoming dead  [000029]
							Live regs: 000000C0 {rsi rdi} => 00000040 {rsi}
							Live vars: {V02 V10} => {V10}
							GC regs: 00000080 {rdi} => 00000000 {}
							V10 in reg rsi is becoming dead  [000111]
							Live regs: 00000040 {rsi} => 00000000 {}
							Live vars: {V10} => {}
IN0010:        mov      qword ptr [rdi+8], rsi

Variable Live Range History Dump for BB13
V02 loc1: rdi [(G_M11341_IG03,ins#2,ofs#9), (G_M11341_IG05,ins#0,ofs#0)]

=============== Generating BB14 [048..049) (return), preds={BB01,BB02,BB09,BB13} succs={} flags=0x00000000.30010020: i label IBC LIR 
BB14 IN (0)={}
     OUT(0)={}

Recording Var Locations at start of BB14
  <none>

Liveness not changing: 0000000000000000 {}
							Live regs: (unchanged) 00000000 {}
							GC regs: (unchanged) 00000000 {}
							Byref regs: (unchanged) 00000000 {}

      L_M11341_BB14:

      G_M11341_IG05:        ; offs=000040H, funclet=00, bbWeight=1   , byref
Mapped BB14 to G_M11341_IG06
Label: IG06, GCvars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}

Scope info: begin block BB14, IL range [048..049)
Added IP mapping: 0x0048 STACK_EMPTY (G_M11341_IG06,ins#0,ofs#0) label
Generating: N047 (???,???) [000137] -----------                            IL_OFFSET void   INLRT @ 0x048[E-] REG NA
Generating: N049 (  0,  0) [000038] -----------                            RETURN    void   REG NA $VN.Void
Added IP mapping: EPILOG (G_M11341_IG06,ins#0,ofs#0) label
Reserving epilog IG for block BB14
*************** After placeholder IG creation
G_M11341_IG01:        ; func=00, offs=000000H, size=0000H, gcrefRegs=00000000 {} <-- Prolog IG
G_M11341_IG02:        ; offs=000000H, size=0020H, gcVars=0000000000000002 {V00}, gcrefRegs=00000002 {rcx}, byrefRegs=00000000 {}, BB01 [0000], BB02 [0024], BB17 [0038], BB05 [0031], gcvars, byref
G_M11341_IG03:        ; offs=000020H, size=0009H, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}, BB08 [0005], byref
G_M11341_IG04:        ; offs=000029H, size=0017H, gcVars=0000000000000000 {}, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}, BB10 [0007], BB11 [0020], gcvars, byref
G_M11341_IG05:        ; offs=000040H, size=0004H, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}, BB13 [0019], byref
G_M11341_IG06:        ; epilog placeholder, next placeholder=<END>, BB14 [0017], epilog <-- First placeholder <-- Last placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000080 {rdi}, PrevByrefRegs=00000000 {}
                      ;   InitGCVars=0000000000000000 {}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}
G_M11341_IG07:        ; offs=000144H, size=0000H, gcrefRegs=00000000 {} <-- Current IG

Variable Live Range History Dump for BB14
..None..

=============== Generating BB09 [???..???) -> BB14 (always), preds={BB15} succs={BB14} flags=0x00000004.20091060: i internal rare label gcsafe LIR 
BB09 IN (0)={}
     OUT(0)={}

Recording Var Locations at start of BB09
  <none>

Liveness not changing: 0000000000000000 {}
							Live regs: (unchanged) 00000000 {}
							GC regs: (unchanged) 00000000 {}
							Byref regs: (unchanged) 00000000 {}

      L_M11341_BB09:
Mapped BB09 to G_M11341_IG07
Label: IG07, GCvars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}

Scope info: begin block BB09, IL range [???..???)
Scope info: ignoring block beginning
Added IP mapping: NO_MAP (G_M11341_IG07,ins#0,ofs#0) label
Scope info: ignoring block end
IN0011:        jmp      L_M11341_BB14

Variable Live Range History Dump for BB09
..None..

=============== Generating BB12 [???..???) -> BB13 (always), preds={BB10} succs={BB13} flags=0x00000002.30091060: i internal rare label hascall gcsafe IBC LIR 
BB12 IN (2)={V07     V02} + ByrefExposed + GcHeap
     OUT(2)={    V10 V02}

Recording Var Locations at start of BB12
  V07(rcx)  V02(rdi)
Change life 0000000000000000 {} -> 0000000000000021 {V02 V07}
							V07 in reg rcx is becoming live  [------]
							Live regs: 00000000 {} => 00000002 {rcx}
							V02 in reg rdi is becoming live  [------]
							Live regs: 00000002 {rcx} => 00000082 {rcx rdi}
New debug range: new var or location
							Live regs: (unchanged) 00000082 {rcx rdi}
							GC regs: (unchanged) 00000082 {rcx rdi}
							Byref regs: (unchanged) 00000000 {}

      L_M11341_BB12:

      G_M11341_IG07:        ; offs=000144H, funclet=00, bbWeight=0   , gcvars, byref
Mapped BB12 to G_M11341_IG08
Label: IG08, GCvars=0000000000000000 {}, gcrefRegs=00000082 {rcx rdi}, byrefRegs=00000000 {}

Scope info: begin block BB12, IL range [???..???)
Scope info: ignoring block beginning
genIPmappingAdd: ignoring duplicate IL offset 0xffffffff
Added IP mapping: 0x002E STACK_EMPTY (G_M11341_IG08,ins#0,ofs#0) label
Generating: N111 (???,???) [000138] -----------                            IL_OFFSET void   INLRT @ 0x02E[E-] REG NA
Generating: N113 (  1,  1) [000053] -----------                   t53 =    LCL_VAR   ref    V07 tmp4         u:1 rcx (last use) REG rcx <l:$205, c:$87>
                                                                        /--*  t53    ref    
Generating: N115 (???,???) [000142] -----------                  t142 = *  PUTARG_REG ref    REG rcx
							V07 in reg rcx is becoming dead  [000053]
							Live regs: 00000082 {rcx rdi} => 00000080 {rdi}
							Live vars: {V02 V07} => {V02}
							GC regs: 00000082 {rcx rdi} => 00000080 {rdi}
							GC regs: 00000080 {rdi} => 00000082 {rcx rdi}
Generating: N117 (  1,  4) [000107] H----------                  t107 =    CNS_INT(h) long   0x4000000000424a90 ftn REG r11 $184
IN0012:        lea      r11, [(reloc 0x4000000000424a90)]
                                                                        /--*  t107   long   
Generating: N119 (???,???) [000143] -----------                  t143 = *  PUTARG_REG long   REG r11
                                                                        /--*  t142   ref    this in rcx
                                                                        +--*  t143   long   vsd cell in r11
Generating: N121 ( 22, 14) [000032] --CXG--N---                   t32 = *  CALLV stub long   System.IRuntimeMethodInfo.get_Value REG rax $300
							GC regs: 00000082 {rcx rdi} => 00000080 {rdi}
							Call: GCvars=0000000000000000 {}, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}
IN0013:        call     [r11]System.IRuntimeMethodInfo:get_Value():System.RuntimeMethodHandleInternal:this
                                                                        /--*  t32    long   
Generating: N123 ( 26, 17) [000071] DA-XG------                         *  STORE_LCL_VAR long   V10 tmp7          rsi REG rsi
IN0014:        mov      rsi, rax
							V10 in reg rsi is becoming live  [000071]
							Live regs: 00000080 {rdi} => 000000C0 {rsi rdi}
							Live vars: {V02} => {V02 V10}
Scope info: ignoring block end
IN0015:        jmp      L_M11341_BB13

Variable Live Range History Dump for BB12
V02 loc1: rdi [(G_M11341_IG07,ins#1,ofs#5), ...]

=============== Generating BB15 [025..02E) -> BB09 (cret), preds={} succs={BB09} flags=0x00000006.20091230: keep i rare label hascall gcsafe flet LIR 
BB15 IN (1)={V00} + ByrefExposed + GcHeap
     OUT(0)={   }

Recording Var Locations at start of BB15
  <none>

Change life 0000000000000030 {V02 V10} -> 0000000000000002 {V00}
							V10 in reg rsi is becoming dead  [------]
							Live regs: (unchanged) 00000000 {}
							V02 in reg rdi is becoming dead  [------]
							Live regs: (unchanged) 00000000 {}
							V00 becoming live
New debug range: new var or location
							Live regs: (unchanged) 00000000 {}
							GC regs: (unchanged) 00000000 {}
							Byref regs: (unchanged) 00000000 {}

      L_M11341_BB15:

      G_M11341_IG08:        ; offs=000149H, funclet=00, bbWeight=0   , byref
Mapped BB15 to G_M11341_IG09
Label: IG09, GCvars=0000000000000002 {V00}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}
Scope info: found beginning of funclet region at block BB15; ignoring following blocks
Reserving funclet prolog IG for block BB15
Added IP mapping: PROLOG (G_M11341_IG09,ins#0,ofs#256) label
*************** After placeholder IG creation
G_M11341_IG01:        ; func=00, offs=000000H, size=0000H, gcrefRegs=00000000 {} <-- Prolog IG
G_M11341_IG02:        ; offs=000000H, size=0020H, gcVars=0000000000000002 {V00}, gcrefRegs=00000002 {rcx}, byrefRegs=00000000 {}, BB01 [0000], BB02 [0024], BB17 [0038], BB05 [0031], gcvars, byref
G_M11341_IG03:        ; offs=000020H, size=0009H, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}, BB08 [0005], byref
G_M11341_IG04:        ; offs=000029H, size=0017H, gcVars=0000000000000000 {}, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}, BB10 [0007], BB11 [0020], gcvars, byref
G_M11341_IG05:        ; offs=000040H, size=0004H, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}, BB13 [0019], byref
G_M11341_IG06:        ; epilog placeholder, next placeholder=IG09 , BB14 [0017], epilog <-- First placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000080 {rdi}, PrevByrefRegs=00000000 {}
                      ;   InitGCVars=0000000000000000 {}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}
G_M11341_IG07:        ; offs=000144H, size=0005H, gcVars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB09 [0012], gcvars, byref
G_M11341_IG08:        ; offs=000149H, size=0012H, gcrefRegs=00000082 {rcx rdi}, byrefRegs=00000000 {}, BB12 [0021], byref
G_M11341_IG09:        ; func=01, funclet prolog placeholder, next placeholder=<END>, BB15 [0006], funclet prolog <-- Last placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000080 {rdi}, PrevByrefRegs=00000000 {}
                      ;   InitGCVars=0000000000000002 {V00}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}
G_M11341_IG10:        ; offs=00025BH, size=0000H, gcrefRegs=00000000 {} <-- Current IG
Added IP mapping: 0x0026 STACK_EMPTY (G_M11341_IG10,ins#0,ofs#0) label
Generating: N131 (???,???) [000139] -----------                            IL_OFFSET void   INLRT @ 0x026[E-] REG NA
Generating: N133 (  1,  1) [000042] ----------z                   t42 =    LCL_VAR   ref    V00 this         u:1 rcx (last use) REG rcx $80
                                                                        /--*  t42    ref    
Generating: N135 (???,???) [000145] -----------                  t145 = *  PUTARG_REG ref    REG rcx
IN0016:        mov      rcx, gword ptr [V00 rbp+10H]
							V00 in reg rcx is becoming live  [000042]
							Live regs: 00000000 {} => 00000002 {rcx}
							GC regs: 00000000 {} => 00000002 {rcx}
							V00 in reg rcx is becoming dead  [000042]
							Live regs: 00000002 {rcx} => 00000000 {}
							Live vars: {V00} => {}
							GCvars: {V00} => {}
							GC regs: 00000002 {rcx} => 00000000 {}
							GC regs: 00000000 {} => 00000002 {rcx}
Generating: N137 (  1,  4) [000146] Hc---------                  t146 =    CNS_INT(h) long   0x4000000000426868 ftn REG NA
                                                                        /--*  t146   long   
Generating: N139 (  3,  6) [000147] -c---------                  t147 = *  IND       long   REG NA
                                                                        /--*  t145   ref    arg0 in rcx
                                                                        +--*  t147   long   control expr
Generating: N141 ( 15,  7) [000043] --CXG------                         *  CALL r2r_ind void   System.GC.ReRegisterForFinalize REG NA $VN.Void
							GC regs: 00000002 {rcx} => 00000000 {}
							Call: GCvars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}
IN0017:        call     [System.GC:ReRegisterForFinalize(System.Object)]
IN0018:        lea      rax, L_M11341_BB09
Reserving funclet epilog IG for block BB15

      G_M11341_IG10:        ; offs=00025BH, funclet=01, bbWeight=0   , gcvars, byref
Added IP mapping: EPILOG (G_M11341_IG11,ins#0,ofs#256) label
*************** After placeholder IG creation
G_M11341_IG01:        ; func=00, offs=000000H, size=0000H, gcrefRegs=00000000 {} <-- Prolog IG
G_M11341_IG02:        ; offs=000000H, size=0020H, gcVars=0000000000000002 {V00}, gcrefRegs=00000002 {rcx}, byrefRegs=00000000 {}, BB01 [0000], BB02 [0024], BB17 [0038], BB05 [0031], gcvars, byref
G_M11341_IG03:        ; offs=000020H, size=0009H, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}, BB08 [0005], byref
G_M11341_IG04:        ; offs=000029H, size=0017H, gcVars=0000000000000000 {}, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}, BB10 [0007], BB11 [0020], gcvars, byref
G_M11341_IG05:        ; offs=000040H, size=0004H, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}, BB13 [0019], byref
G_M11341_IG06:        ; epilog placeholder, next placeholder=IG09 , BB14 [0017], epilog <-- First placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000080 {rdi}, PrevByrefRegs=00000000 {}
                      ;   InitGCVars=0000000000000000 {}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}
G_M11341_IG07:        ; offs=000144H, size=0005H, gcVars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB09 [0012], gcvars, byref
G_M11341_IG08:        ; offs=000149H, size=0012H, gcrefRegs=00000082 {rcx rdi}, byrefRegs=00000000 {}, BB12 [0021], byref
G_M11341_IG09:        ; func=01, funclet prolog placeholder, next placeholder=IG11 , BB15 [0006], funclet prolog
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000080 {rdi}, PrevByrefRegs=00000000 {}
                      ;   InitGCVars=0000000000000002 {V00}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}
G_M11341_IG10:        ; offs=00025BH, size=0011H, gcVars=0000000000000002 {V00}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB15 [0006], gcvars, byref
G_M11341_IG11:        ; funclet epilog placeholder, next placeholder=<END>, BB15 [0006], funclet epilog, extend <-- Last placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000080 {rdi}, PrevByrefRegs=00000000 {}
                      ;   InitGCVars=0000000000000002 {V00}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}

Variable Live Range History Dump for BB15
V00 this: rbp[16] (1 slot) [(G_M11341_IG08,ins#4,ofs#18), (G_M11341_IG10,ins#1,ofs#4)]
V02 loc1: rdi [(G_M11341_IG07,ins#1,ofs#5), (G_M11341_IG08,ins#4,ofs#18)]
Liveness not changing: 0000000000000000 {}

# compCycleEstimate =    115, compSizeEstimate =    87 System.Reflection.Emit.DynamicResolver:Finalize():this
; Final local variable assignments
;
;  V00 this         [V00,T01] (  4,  3   )     ref  ->  [rbp+10H]   this class-hnd EH-live single-def
;  V01 loc0         [V01,T02] (  3,  3   )     ref  ->  rax         class-hnd single-def
;  V02 loc1         [V02,T05] (  2,  2   )     ref  ->  rdi         class-hnd exact single-def
;  V03 OutArgs      [V03    ] (  1,  1   )  lclBlk (32) [rsp+00H]   "OutgoingArgSpace"
;* V04 tmp1         [V04    ] (  0,  0   )     ref  ->  zero-ref    class-hnd exact "NewObj constructor temp"
;* V05 tmp2         [V05    ] (  0,  0   )     ref  ->  zero-ref    class-hnd single-def "impSpillSpecialSideEff"
;* V06 tmp3         [V06    ] (  0,  0   )  struct ( 8) zero-ref    "guarded devirt return temp"
;  V07 tmp4         [V07,T00] (  4,  6   )     ref  ->  rcx         single-def "guarded devirt this temp"
;* V08 tmp5         [V08    ] (  0,  0   )     ref  ->  zero-ref    class-hnd exact "guarded devirt this exact temp"
;* V09 tmp6         [V09,T06] (  0,  0   )    bool  ->  zero-ref    "Inline return value spill temp"
;  V10 tmp7         [V10,T04] (  3,  2   )    long  ->  rsi         V06.m_handle(offs=0x00) P-INDEP "field V06.m_handle (fldOffset=0x0)"
;  V11 PSPSym       [V11,T07] (  1,  1   )    long  ->  [rbp-20H]   do-not-enreg[V] "PSPSym"
;  V12 cse0         [V12,T03] (  3,  3   )     ref  ->  rsi         "CSE - aggressive"
;
; Lcl frame size = 48
*************** Before prolog / epilog generation
G_M11341_IG01:        ; func=00, offs=000000H, size=0000H, gcrefRegs=00000000 {} <-- Prolog IG
G_M11341_IG02:        ; offs=000000H, size=0020H, gcVars=0000000000000002 {V00}, gcrefRegs=00000002 {rcx}, byrefRegs=00000000 {}, BB01 [0000], BB02 [0024], BB17 [0038], BB05 [0031], gcvars, byref
G_M11341_IG03:        ; offs=000020H, size=0009H, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}, BB08 [0005], byref
G_M11341_IG04:        ; offs=000029H, size=0017H, gcVars=0000000000000000 {}, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}, BB10 [0007], BB11 [0020], gcvars, byref
G_M11341_IG05:        ; offs=000040H, size=0004H, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}, BB13 [0019], byref
G_M11341_IG06:        ; epilog placeholder, next placeholder=IG09 , BB14 [0017], epilog <-- First placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000080 {rdi}, PrevByrefRegs=00000000 {}
                      ;   InitGCVars=0000000000000000 {}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}
G_M11341_IG07:        ; offs=000144H, size=0005H, gcVars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB09 [0012], gcvars, byref
G_M11341_IG08:        ; offs=000149H, size=0012H, gcrefRegs=00000082 {rcx rdi}, byrefRegs=00000000 {}, BB12 [0021], byref
G_M11341_IG09:        ; func=01, funclet prolog placeholder, next placeholder=IG11 , BB15 [0006], funclet prolog
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000080 {rdi}, PrevByrefRegs=00000000 {}
                      ;   InitGCVars=0000000000000002 {V00}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}
G_M11341_IG10:        ; offs=00025BH, size=0011H, gcVars=0000000000000002 {V00}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB15 [0006], gcvars, byref
G_M11341_IG11:        ; funclet epilog placeholder, next placeholder=<END>, BB15 [0006], funclet epilog, extend <-- Last placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=00000080 {rdi}, PrevByrefRegs=00000000 {}
                      ;   InitGCVars=0000000000000002 {V00}, InitGCrefRegs=00000000 {}, InitByrefRegs=00000000 {}
Recording Var Locations at start of BB01
  V00(rcx)
*************** In genFnProlog()
Added IP mapping to front: PROLOG (G_M11341_IG01,ins#0,ofs#0) label

__prolog:
New debug range: first
IN0019:        push     rbp
IN001a:        push     rdi
IN001b:        push     rsi
IN001c:        sub      rsp, 48
IN001d:        lea      rbp, [rsp+40H]
IN001e:        mov      qword ptr [V11 rbp-20H], rsp
*************** In genFnPrologCalleeRegArgs() for int regs
IN001f:        mov      gword ptr [V00 rbp+10H], rcx
*************** In genEnregisterIncomingStackArgs()
1 tracked GC refs are at stack offsets  0010 ...  0018


      G_M11341_IG01:        ; offs=000000H, funclet=00, bbWeight=1   , gcvars, byref, nogc

Funclet prolog / epilog info
   Function InitialSP-to-FP delta: 64
                         SP delta: 48
       PSP slot Initial SP offset: 32
*************** In genFnEpilog()

__epilog:
gcVarPtrSetCur=0000000000000000 {}, gcRegGCrefSetCur=00000000 {}, gcRegByrefSetCur=00000000 {}
IN0020:        add      rsp, 48
IN0021:        pop      rsi
IN0022:        pop      rdi
IN0023:        pop      rbp
IN0024:        ret      

      G_M11341_IG06:        ; offs=000044H, funclet=00, bbWeight=1   , byref, epilog, nogc
*************** In genFuncletProlog()
IN0025:        push     rbp
IN0026:        push     rdi
IN0027:        push     rsi
IN0028:        sub      rsp, 48
IN0029:        mov      rbp, qword ptr [rcx+32]
Marking regs modified: [rbp] ([rax rcx rdx rsi rdi r8-r11] => [rax rcx rdx rbp rsi rdi r8-r11])
IN002a:        mov      qword ptr [rsp+20H], rbp
IN002b:        lea      rbp, [rbp+40H]
Removing modified regs: [rbp] ([rax rcx rdx rbp rsi rdi r8-r11] => [rax rcx rdx rsi rdi r8-r11])

      G_M11341_IG09:        ; offs=00015BH, funclet=01, bbWeight=0   , gcvars, byref, funclet prolog, nogc
*************** In genFuncletEpilog()
IN002c:        add      rsp, 48
IN002d:        pop      rsi
IN002e:        pop      rdi
IN002f:        pop      rbp
IN0030:        ret      

      G_M11341_IG11:        ; offs=00026CH, funclet=01, bbWeight=0   , funclet epilog, nogc, extend
0 prologs, 1 epilogs, 1 funclet prologs, 1 funclet epilogs
*************** After prolog / epilog generation
G_M11341_IG01:        ; func=00, offs=000000H, size=0014H, gcVars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, gcvars, byref, nogc <-- Prolog IG
G_M11341_IG02:        ; offs=000014H, size=0020H, gcVars=0000000000000002 {V00}, gcrefRegs=00000002 {rcx}, byrefRegs=00000000 {}, BB01 [0000], BB02 [0024], BB17 [0038], BB05 [0031], gcvars, byref
G_M11341_IG03:        ; offs=000034H, size=0009H, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}, BB08 [0005], byref
G_M11341_IG04:        ; offs=00003DH, size=0017H, gcVars=0000000000000000 {}, gcrefRegs=000000C0 {rsi rdi}, byrefRegs=00000000 {}, BB10 [0007], BB11 [0020], gcvars, byref
G_M11341_IG05:        ; offs=000054H, size=0004H, gcrefRegs=00000080 {rdi}, byrefRegs=00000000 {}, BB13 [0019], byref
G_M11341_IG06:        ; offs=000058H, size=0008H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, epilog, nogc
G_M11341_IG07:        ; offs=000060H, size=0005H, gcVars=0000000000000000 {}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB09 [0012], gcvars, byref
G_M11341_IG08:        ; offs=000065H, size=0012H, gcrefRegs=00000082 {rcx rdi}, byrefRegs=00000000 {}, BB12 [0021], byref
G_M11341_IG09:        ; func=01, offs=000077H, size=0014H, gcVars=0000000000000002 {V00}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, gcvars, byref, funclet prolog, nogc
G_M11341_IG10:        ; offs=00008BH, size=0011H, gcVars=0000000000000002 {V00}, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, BB15 [0006], gcvars, byref
G_M11341_IG11:        ; offs=00009CH, size=0008H, funclet epilog, nogc, extend
*************** In emitRemoveJumpToNextInst()
Emitter Jump List:
IG02 IN0003  je[6] -> IG06 
IG02 IN0006  je[6] -> IG06 
IG02 IN0007 jmp[5] -> IG03  ; removal candidate
IG04 IN000e jne[6] -> IG08 
IG07 IN0011 jmp[5] -> IG06  ; removal candidate
IG08 IN0015 jmp[5] -> IG05  ; removal candidate
IG10 IN0018 lea[7] -> IG07 
  total jump count: 7
jmp != id, dumping context information
method: Finalize
  jmp: 73: IN0007: 000000 jmp      L_M11341_BB08
  id: 83: IN0008: 000000 int3     
jump group:
G_M11341_IG02:        ; func=00, offs=000014H, size=0020H, gcVars=0000000000000002 {V00}, gcrefRegs=00000002 {rcx}, byrefRegs=00000000 {}, BB01 [0000], BB02 [0024], BB17 [0038], BB05 [0031], gcvars, byref

IN0001: 000014 mov      rax, gword ptr [rcx+24]
IN0002: 000018 test     rax, rax
IN0003: 00001B je       L_M11341_BB14
IN0004: 000021 mov      rsi, gword ptr [rax+16]
IN0005: 000025 test     rsi, rsi
IN0006: 000028 je       L_M11341_BB14
IN0007: 00002E jmp      L_M11341_BB08
IN0008: 000033 int3     

target group:
G_M11341_IG03:        ; func=00, offs=000034H, size=0009H, gcrefRegs=00000040 {rsi}, byrefRegs=00000000 {}, BB08 [0005], byref
E:\Programming\csharp7\runtime\src\coreclr\jit\emit.cpp:4217
Assertion failed 'jmp == id' in 'System.Reflection.Emit.DynamicResolver:Finalize():this' during 'Generate code' (IL size 73; hash 0x00d7d3b2; FullOpts)

